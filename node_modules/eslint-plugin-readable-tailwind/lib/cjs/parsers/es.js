"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLiteralsByESVariableDeclarator = getLiteralsByESVariableDeclarator;
exports.getLiteralsByESCallExpression = getLiteralsByESCallExpression;
exports.getLiteralsByTaggedTemplateExpression = getLiteralsByTaggedTemplateExpression;
exports.getLiteralsByESLiteralNode = getLiteralsByESLiteralNode;
exports.getLiteralsByESMatchers = getLiteralsByESMatchers;
exports.getLiteralNodesByRegex = getLiteralNodesByRegex;
exports.getStringLiteralByESStringLiteral = getStringLiteralByESStringLiteral;
exports.getLiteralsByESTemplateLiteral = getLiteralsByESTemplateLiteral;
exports.findParentESTemplateLiteralByESTemplateElement = findParentESTemplateLiteralByESTemplateElement;
exports.isESObjectKey = isESObjectKey;
exports.isInsideObjectValue = isInsideObjectValue;
exports.isESSimpleStringLiteral = isESSimpleStringLiteral;
exports.isESStringLike = isESStringLike;
exports.isESTemplateLiteral = isESTemplateLiteral;
exports.isESTemplateElement = isESTemplateElement;
exports.isESNode = isESNode;
exports.isESCallExpression = isESCallExpression;
exports.isESVariableDeclarator = isESVariableDeclarator;
exports.hasESNodeParentExtension = hasESNodeParentExtension;
const readable_tailwind_types_rule_js_1 = require("../types/rule.js");
const readable_tailwind_utils_matchers_js_1 = require("../utils/matchers.js");
const readable_tailwind_utils_regex_js_1 = require("../utils/regex.js");
const readable_tailwind_utils_utils_js_1 = require("../utils/utils.js");
function getLiteralsByESVariableDeclarator(ctx, node, variables) {
    const literals = variables.reduce((literals, variable) => {
        if (!node.init) {
            return literals;
        }
        if (!isESVariableSymbol(node.id)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isVariableName)(variable)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(variable, node.id.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESExpression(ctx, [node.init]));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isVariableRegex)(variable)) {
            literals.push(...(0, readable_tailwind_utils_regex_js_1.getLiteralsByESNodeAndRegex)(ctx, node, variable));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isVariableMatchers)(variable)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(variable[0], node.id.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node.init, variable[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByESCallExpression(ctx, node, callees) {
    const literals = callees.reduce((literals, callee) => {
        if (!isESCalleeSymbol(node.callee)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isCalleeName)(callee)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(callee, node.callee.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESExpression(ctx, node.arguments));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isCalleeRegex)(callee)) {
            literals.push(...(0, readable_tailwind_utils_regex_js_1.getLiteralsByESNodeAndRegex)(ctx, node, callee));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isCalleeMatchers)(callee)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(callee[0], node.callee.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node, callee[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByTaggedTemplateExpression(ctx, node, tags) {
    const literals = tags.reduce((literals, tag) => {
        if (!isTaggedTemplateSymbol(node.tag)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isTagName)(tag)) {
            if (tag !== node.tag.name) {
                return literals;
            }
            literals.push(...getLiteralsByESTemplateLiteral(ctx, node.quasi));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isTagRegex)(tag)) {
            literals.push(...(0, readable_tailwind_utils_regex_js_1.getLiteralsByESNodeAndRegex)(ctx, node, tag));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isTagMatchers)(tag)) {
            if (tag[0] !== node.tag.name) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node, tag[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByESLiteralNode(ctx, node) {
    if (isESSimpleStringLiteral(node)) {
        const literal = getStringLiteralByESStringLiteral(ctx, node);
        return literal ? [literal] : [];
    }
    if (isESTemplateLiteral(node)) {
        return getLiteralsByESTemplateLiteral(ctx, node);
    }
    if (isESTemplateElement(node) && hasESNodeParentExtension(node)) {
        const literal = getLiteralByESTemplateElement(ctx, node);
        return literal ? [literal] : [];
    }
    return [];
}
function getLiteralsByESMatchers(ctx, node, matchers) {
    const matcherFunctions = getESMatcherFunctions(matchers);
    const literalNodes = (0, readable_tailwind_utils_matchers_js_1.getLiteralNodesByMatchers)(ctx, node, matcherFunctions);
    const literals = literalNodes.reduce((literals, literalNode) => {
        literals.push(...getLiteralsByESLiteralNode(ctx, literalNode));
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralNodesByRegex(ctx, node, regex) {
    const sourceCode = ctx.sourceCode.getText(node);
    const matchedNodes = [];
    const matches = sourceCode.matchAll(regex);
    for (const groups of matches) {
        if (!groups.indices || groups.indices.length < 2) {
            continue;
        }
        for (const [startIndex] of groups.indices.slice(1)) {
            const literalNode = ctx.sourceCode.getNodeByRangeIndex((node.range?.[0] ?? 0) + startIndex);
            if (!literalNode) {
                continue;
            }
            matchedNodes.push(literalNode);
        }
    }
    return matchedNodes;
}
function getStringLiteralByESStringLiteral(ctx, node) {
    const raw = node.raw;
    const content = node.value;
    if (!raw || !node.loc || !node.range || !node.parent.loc || !node.parent.range) {
        return;
    }
    const quotes = (0, readable_tailwind_utils_utils_js_1.getQuotes)(raw);
    const whitespaces = (0, readable_tailwind_utils_utils_js_1.getWhitespace)(content);
    return {
        ...quotes,
        ...whitespaces,
        content,
        loc: node.loc,
        node: node,
        parent: node.parent,
        range: node.range,
        raw,
        type: "StringLiteral"
    };
}
function getLiteralByESTemplateElement(ctx, node) {
    const raw = ctx.sourceCode.getText(node);
    const content = node.value.raw;
    if (!raw || !node.loc || !node.range || !node.parent.loc || !node.parent.range) {
        return;
    }
    const quotes = (0, readable_tailwind_utils_utils_js_1.getQuotes)(raw);
    const whitespaces = (0, readable_tailwind_utils_utils_js_1.getWhitespace)(content);
    const braces = getBracesByString(ctx, raw);
    return {
        ...whitespaces,
        ...quotes,
        ...braces,
        content,
        loc: node.loc,
        node: node,
        parent: node.parent,
        range: node.range,
        raw,
        type: "TemplateLiteral"
    };
}
function getLiteralsByESExpression(ctx, args) {
    return args.reduce((acc, node) => {
        if (node.type === "SpreadElement") {
            return acc;
        }
        acc.push(...getLiteralsByESLiteralNode(ctx, node));
        return acc;
    }, []);
}
function getLiteralsByESTemplateLiteral(ctx, node) {
    return node.quasis.map(quasi => {
        if (!hasESNodeParentExtension(quasi)) {
            return;
        }
        return getLiteralByESTemplateElement(ctx, quasi);
    }).filter((literal) => literal !== undefined);
}
function findParentESTemplateLiteralByESTemplateElement(node) {
    if (!hasESNodeParentExtension(node)) {
        return;
    }
    if (node.parent.type === "TemplateLiteral") {
        return node.parent;
    }
    return findParentESTemplateLiteralByESTemplateElement(node.parent);
}
function isESObjectKey(node) {
    return (node.parent.type === "Property" &&
        node.parent.parent.type === "ObjectExpression" &&
        node.parent.key === node);
}
function isInsideObjectValue(node) {
    if (!hasESNodeParentExtension(node)) {
        return false;
    }
    // Allow call expressions as object values
    if (isESCallExpression(node)) {
        return false;
    }
    if (node.parent.type === "Property" &&
        node.parent.parent.type === "ObjectExpression" &&
        node.parent.value === node) {
        return true;
    }
    return isInsideObjectValue(node.parent);
}
function isESSimpleStringLiteral(node) {
    return (node.type === "Literal" &&
        "value" in node &&
        typeof node.value === "string");
}
function isESStringLike(node) {
    return isESSimpleStringLiteral(node) || isESTemplateElement(node);
}
function isESTemplateLiteral(node) {
    return node.type === "TemplateLiteral";
}
function isESTemplateElement(node) {
    return node.type === "TemplateElement";
}
function isESNode(node) {
    return (node !== null &&
        typeof node === "object" &&
        "type" in node);
}
function isESCallExpression(node) {
    return node.type === "CallExpression";
}
function isESCalleeSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isESCallExpression(node.parent);
}
function isTaggedTemplateExpression(node) {
    return node.type === "TaggedTemplateExpression";
}
function isTaggedTemplateSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isTaggedTemplateExpression(node.parent);
}
function isESVariableDeclarator(node) {
    return node.type === "VariableDeclarator";
}
function isESVariableSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isESVariableDeclarator(node.parent);
}
function hasESNodeParentExtension(node) {
    return "parent" in node && !!node.parent;
}
function getBracesByString(ctx, raw) {
    const closingBraces = raw.startsWith("}") ? "}" : undefined;
    const openingBraces = raw.endsWith("${") ? "${" : undefined;
    return {
        closingBraces,
        openingBraces
    };
}
function getESMatcherFunctions(matchers) {
    return matchers.reduce((matcherFunctions, matcher) => {
        switch (matcher.match) {
            case readable_tailwind_types_rule_js_1.MatcherType.String: {
                matcherFunctions.push(node => {
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    return (!isESObjectKey(node) &&
                        !isInsideObjectValue(node) &&
                        isESStringLike(node));
                });
                break;
            }
            case readable_tailwind_types_rule_js_1.MatcherType.ObjectKey: {
                matcherFunctions.push(node => {
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (!isESObjectKey(node)) {
                        return false;
                    }
                    const path = (0, readable_tailwind_utils_matchers_js_1.getObjectPath)(node);
                    return path && matcher.pathPattern ? (0, readable_tailwind_utils_matchers_js_1.matchesPathPattern)(path, matcher.pathPattern) : true;
                });
                break;
            }
            case readable_tailwind_types_rule_js_1.MatcherType.ObjectValue: {
                matcherFunctions.push(node => {
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (isESObjectKey(node)) {
                        return false;
                    }
                    const path = (0, readable_tailwind_utils_matchers_js_1.getObjectPath)(node);
                    const matchesPattern = path !== undefined &&
                        matcher.pathPattern
                        ? (0, readable_tailwind_utils_matchers_js_1.matchesPathPattern)(path, matcher.pathPattern)
                        : true;
                    return isInsideObjectValue(node) && isESStringLike(node) && matchesPattern;
                });
                break;
            }
        }
        return matcherFunctions;
    }, []);
}
//# sourceMappingURL=es.js.map