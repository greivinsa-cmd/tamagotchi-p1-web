"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommonOptions = getCommonOptions;
exports.getWhitespace = getWhitespace;
exports.getQuotes = getQuotes;
exports.splitClasses = splitClasses;
exports.display = display;
exports.splitWhitespaces = splitWhitespaces;
exports.findLineStartPosition = findLineStartPosition;
exports.findLiteralStartPosition = findLiteralStartPosition;
exports.isLiteral = isLiteral;
exports.matchesName = matchesName;
exports.deduplicateLiterals = deduplicateLiterals;
const readable_tailwind_options_default_options_js_1 = require("../options/default-options.js");
function getCommonOptions(ctx) {
    const attributes = getOption(ctx, "attributes") ?? readable_tailwind_options_default_options_js_1.DEFAULT_ATTRIBUTE_NAMES;
    const callees = getOption(ctx, "callees") ?? readable_tailwind_options_default_options_js_1.DEFAULT_CALLEE_NAMES;
    const variables = getOption(ctx, "variables") ?? readable_tailwind_options_default_options_js_1.DEFAULT_VARIABLE_NAMES;
    const tags = getOption(ctx, "tags") ?? readable_tailwind_options_default_options_js_1.DEFAULT_TAG_NAMES;
    const tailwindConfig = getOption(ctx, "entryPoint") ?? getOption(ctx, "tailwindConfig");
    return {
        attributes,
        callees,
        tags,
        tailwindConfig,
        variables
    };
}
function getOption(ctx, key) {
    return ctx.options[0]?.[key] ?? ctx.settings["eslint-plugin-readable-tailwind"]?.[key] ??
        ctx.settings["readable-tailwind"]?.[key];
}
function getWhitespace(classes) {
    const leadingWhitespace = classes.match(/^\s*/)?.[0];
    const trailingWhitespace = classes.match(/\s*$/)?.[0];
    return { leadingWhitespace, trailingWhitespace };
}
function getQuotes(raw) {
    const openingQuote = raw.at(0);
    const closingQuote = raw.at(-1);
    return {
        closingQuote: closingQuote === "'" || closingQuote === '"' || closingQuote === "`" ? closingQuote : undefined,
        openingQuote: openingQuote === "'" || openingQuote === '"' || openingQuote === "`" ? openingQuote : undefined
    };
}
function splitClasses(classes) {
    if (classes.trim() === "") {
        return [];
    }
    return classes
        .trim()
        .split(/\s+/);
}
function display(classes) {
    return classes
        .replaceAll(" ", "·")
        .replaceAll("\n", "↵\n")
        .replaceAll("\r", "↩\r")
        .replaceAll("\t", "→");
}
function splitWhitespaces(classes) {
    return classes.split(/\S+/);
}
function findLineStartPosition(ctx, node) {
    const line = node.loc.start.line;
    return ctx.sourceCode.lines[line - 1].match(/^\s*/)?.[0]?.length ?? 0;
}
function findLiteralStartPosition(ctx, literal) {
    const column = literal.loc.start.column;
    return column;
}
function isLiteral(node) {
    return node.type === "Literal";
}
function matchesName(pattern, name) {
    if (!name) {
        return false;
    }
    const match = name.match(pattern);
    return !!match && match[0] === name;
}
function deduplicateLiterals(literals) {
    return literals.filter((l1, index) => {
        return literals.findIndex(l2 => {
            return l1.content === l2.content &&
                l1.range[0] === l2.range[0] &&
                l1.range[1] === l2.range[1];
        }) === index;
    });
}
//# sourceMappingURL=utils.js.map