"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLiteralNodesByMatchers = getLiteralNodesByMatchers;
exports.findMatchingNestedNodes = findMatchingNestedNodes;
exports.findMatchingParentNodes = findMatchingParentNodes;
exports.getObjectPath = getObjectPath;
exports.matchesPathPattern = matchesPathPattern;
exports.isCalleeName = isCalleeName;
exports.isCalleeRegex = isCalleeRegex;
exports.isCalleeMatchers = isCalleeMatchers;
exports.isVariableName = isVariableName;
exports.isVariableRegex = isVariableRegex;
exports.isVariableMatchers = isVariableMatchers;
exports.isTagName = isTagName;
exports.isTagRegex = isTagRegex;
exports.isTagMatchers = isTagMatchers;
exports.isAttributesName = isAttributesName;
exports.isAttributesRegex = isAttributesRegex;
exports.isAttributesMatchers = isAttributesMatchers;
exports.isInsideConditionalExpressionTest = isInsideConditionalExpressionTest;
exports.isInsideLogicalExpressionLeft = isInsideLogicalExpressionLeft;
const readable_tailwind_parsers_es_js_1 = require("../parsers/es.js");
function getLiteralNodesByMatchers(ctx, node, matcherFunctions) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return [];
    }
    const nestedLiterals = findMatchingNestedNodes(node, matcherFunctions);
    const self = nodeMatches(node, matcherFunctions) ? [node] : [];
    return [...nestedLiterals, ...self];
}
function findMatchingNestedNodes(node, matcherFunctions) {
    return Object.entries(node).reduce((matchedNodes, [key, value]) => {
        if (!value || typeof value !== "object" || key === "parent") {
            return matchedNodes;
        }
        if ((0, readable_tailwind_parsers_es_js_1.isESCallExpression)(value)) {
            return matchedNodes;
        }
        if ((0, readable_tailwind_parsers_es_js_1.isESVariableDeclarator)(value)) {
            return matchedNodes;
        }
        if (nodeMatches(value, matcherFunctions)) {
            matchedNodes.push(value);
        }
        matchedNodes.push(...findMatchingNestedNodes(value, matcherFunctions));
        return matchedNodes;
    }, []);
}
function findMatchingParentNodes(node, matcherFunctions) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return [];
    }
    if (nodeMatches(node.parent, matcherFunctions)) {
        return [node.parent];
    }
    return findMatchingParentNodes(node.parent, matcherFunctions);
}
function nodeMatches(node, matcherFunctions) {
    for (const matcherFunction of matcherFunctions) {
        if (matcherFunction(node)) {
            return true;
        }
    }
    return false;
}
function isChildNodeOfNode(node, parent) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return false;
    }
    if (node.parent === parent) {
        return true;
    }
    return isChildNodeOfNode(node.parent, parent);
}
function getObjectPath(node) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return;
    }
    if (node.type !== "Property" &&
        node.type !== "ObjectExpression" &&
        node.type !== "ArrayExpression" &&
        node.type !== "Identifier" &&
        node.type !== "Literal") {
        return;
    }
    const paths = [];
    if (node.type === "Property") {
        if (node.key.type === "Identifier") {
            paths.unshift(createObjectPathElement(node.key.name));
        }
        else if (node.key.type === "Literal") {
            paths.unshift(createObjectPathElement(node.key.value?.toString() ?? node.key.raw));
        }
        else {
            return "";
        }
    }
    if ((0, readable_tailwind_parsers_es_js_1.isESStringLike)(node) && (0, readable_tailwind_parsers_es_js_1.isInsideObjectValue)(node)) {
        const property = findMatchingParentNodes(node, [node => {
                return node.type === "Property";
            }])[0];
        return getObjectPath(property);
    }
    if ((0, readable_tailwind_parsers_es_js_1.isESObjectKey)(node)) {
        const property = node.parent;
        return getObjectPath(property);
    }
    if (node.parent.type === "ArrayExpression" && node.type !== "Property") {
        const index = node.parent.elements.indexOf(node);
        paths.unshift(`[${index}]`);
    }
    paths.unshift(getObjectPath(node.parent));
    return paths.reduce((paths, currentPath) => {
        if (!currentPath) {
            return paths;
        }
        if (paths.length === 0) {
            return [currentPath];
        }
        if (currentPath.startsWith("[") && currentPath.endsWith("]")) {
            return [...paths, currentPath];
        }
        return [...paths, ".", currentPath];
    }, []).join("");
}
function createObjectPathElement(path) {
    if (!path) {
        return "";
    }
    return path.match(/^[A-Z_a-z]\w*$/)
        ? path
        : `["${path}"]`;
}
function matchesPathPattern(path, pattern) {
    const regex = new RegExp(pattern);
    return regex.test(path);
}
function isCalleeName(callee) {
    return typeof callee === "string";
}
function isCalleeRegex(callee) {
    return Array.isArray(callee) && typeof callee[0] === "string" && typeof callee[1] === "string";
}
function isCalleeMatchers(callee) {
    return Array.isArray(callee) && typeof callee[0] === "string" && Array.isArray(callee[1]);
}
function isVariableName(variable) {
    return typeof variable === "string";
}
function isVariableRegex(variable) {
    return Array.isArray(variable) && typeof variable[0] === "string" && typeof variable[1] === "string";
}
function isVariableMatchers(variable) {
    return Array.isArray(variable) && typeof variable[0] === "string" && Array.isArray(variable[1]);
}
function isTagName(tag) {
    return typeof tag === "string";
}
function isTagRegex(tag) {
    return Array.isArray(tag) && typeof tag[0] === "string" && typeof tag[1] === "string";
}
function isTagMatchers(tag) {
    return Array.isArray(tag) && typeof tag[0] === "string" && Array.isArray(tag[1]);
}
function isAttributesName(attributes) {
    return typeof attributes === "string";
}
function isAttributesRegex(attributes) {
    return Array.isArray(attributes) && typeof attributes[0] === "string" && typeof attributes[1] === "string";
}
function isAttributesMatchers(attributes) {
    return Array.isArray(attributes) && typeof attributes[0] === "string" && Array.isArray(attributes[1]);
}
function isInsideConditionalExpressionTest(node) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return false;
    }
    if (node.parent.type === "ConditionalExpression" && node.parent.test === node) {
        return true;
    }
    return isInsideConditionalExpressionTest(node.parent);
}
function isInsideLogicalExpressionLeft(node) {
    if (!(0, readable_tailwind_parsers_es_js_1.hasESNodeParentExtension)(node)) {
        return false;
    }
    if (node.parent.type === "LogicalExpression" && node.parent.left === node) {
        return true;
    }
    return isInsideLogicalExpressionLeft(node.parent);
}
//# sourceMappingURL=matchers.js.map