import { getLiteralsByESLiteralNode, hasESNodeParentExtension, isESObjectKey, isESStringLike, isInsideObjectValue } from "./es.js";
import { MatcherType } from "../types/rule.js";
import { getLiteralNodesByMatchers, getObjectPath, isAttributesMatchers, isAttributesName, isAttributesRegex, isInsideConditionalExpressionTest, isInsideLogicalExpressionLeft, matchesPathPattern } from "../utils/matchers.js";
import { getLiteralsByESNodeAndRegex } from "../utils/regex.js";
import { deduplicateLiterals, getQuotes, getWhitespace, matchesName } from "../utils/utils.js";
export function getAttributesBySvelteTag(ctx, node) {
    return node.attributes.reduce((acc, attribute) => {
        if (isSvelteAttribute(attribute)) {
            acc.push(attribute);
        }
        return acc;
    }, []);
}
export function getLiteralsBySvelteAttribute(ctx, attribute, attributes) {
    // skip shorthand attributes #42
    if (!Array.isArray(attribute.value)) {
        return [];
    }
    const [value] = attribute.value;
    if (!value) { // empty attribute
        return [];
    }
    const literals = attributes.reduce((literals, attributes) => {
        if (isAttributesName(attributes)) {
            if (!matchesName(attributes.toLowerCase(), attribute.key.name.toLowerCase())) {
                return literals;
            }
            literals.push(...getLiteralsBySvelteLiteralNode(ctx, value));
        }
        else if (isAttributesRegex(attributes)) {
            literals.push(...getLiteralsByESNodeAndRegex(ctx, attribute, attributes));
        }
        else if (isAttributesMatchers(attributes)) {
            if (!matchesName(attributes[0].toLowerCase(), attribute.key.name.toLowerCase())) {
                return literals;
            }
            literals.push(...getLiteralsBySvelteMatchers(ctx, value, attributes[1]));
        }
        return literals;
    }, []);
    return deduplicateLiterals(literals);
}
function getLiteralsBySvelteMatchers(ctx, node, matchers) {
    const matcherFunctions = getSvelteMatcherFunctions(matchers);
    const literalNodes = getLiteralNodesByMatchers(ctx, node, matcherFunctions);
    const literals = literalNodes.reduce((literals, literalNode) => {
        literals.push(...getLiteralsBySvelteLiteralNode(ctx, literalNode));
        return literals;
    }, []);
    return deduplicateLiterals(literals);
}
function getLiteralsBySvelteLiteralNode(ctx, node) {
    if (isSvelteStringLiteral(node)) {
        const stringLiteral = getStringLiteralBySvelteStringLiteral(ctx, node);
        if (stringLiteral) {
            return [stringLiteral];
        }
    }
    if (isSvelteMustacheTag(node)) {
        return getLiteralsBySvelteLiteralNode(ctx, node.expression);
    }
    if (isESStringLike(node)) {
        return getLiteralsByESLiteralNode(ctx, node);
    }
    return [];
}
function getStringLiteralBySvelteStringLiteral(ctx, node) {
    const content = node.value;
    const raw = ctx.sourceCode.getText(node, 1, 1);
    const quotes = getQuotes(raw);
    const whitespaces = getWhitespace(content);
    return {
        ...whitespaces,
        ...quotes,
        content,
        loc: node.loc,
        node: node,
        parent: node.parent,
        range: [node.range[0] - 1, node.range[1] + 1], // include quotes in range
        raw,
        type: "StringLiteral"
    };
}
function isSvelteAttribute(attribute) {
    return "key" in attribute && "name" in attribute.key && typeof attribute.key.name === "string";
}
function isSvelteStringLiteral(node) {
    return node.type === "SvelteLiteral";
}
function isSvelteMustacheTag(node) {
    return node.type === "SvelteMustacheTag" &&
        "kind" in node && node.kind === "text";
}
function getSvelteMatcherFunctions(matchers) {
    return matchers.reduce((matcherFunctions, matcher) => {
        switch (matcher.match) {
            case MatcherType.String: {
                matcherFunctions.push(node => {
                    if (isInsideConditionalExpressionTest(node)) {
                        return false;
                    }
                    if (isInsideLogicalExpressionLeft(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    return (!isESObjectKey(node) &&
                        !isInsideObjectValue(node) &&
                        (isESStringLike(node) || isSvelteStringLiteral(node)));
                });
                break;
            }
            case MatcherType.ObjectKey: {
                matcherFunctions.push(node => {
                    if (isInsideConditionalExpressionTest(node)) {
                        return false;
                    }
                    if (isInsideLogicalExpressionLeft(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (!isESObjectKey(node)) {
                        return false;
                    }
                    const path = getObjectPath(node);
                    return path && matcher.pathPattern ? matchesPathPattern(path, matcher.pathPattern) : true;
                });
                break;
            }
            case MatcherType.ObjectValue: {
                matcherFunctions.push(node => {
                    if (isInsideConditionalExpressionTest(node)) {
                        return false;
                    }
                    if (isInsideLogicalExpressionLeft(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (isESObjectKey(node)) {
                        return false;
                    }
                    const path = getObjectPath(node);
                    const matchesPattern = path !== undefined &&
                        matcher.pathPattern
                        ? matchesPathPattern(path, matcher.pathPattern)
                        : true;
                    return isInsideObjectValue(node) && isESStringLike(node) && matchesPattern;
                });
                break;
            }
        }
        return matcherFunctions;
    }, []);
}
//# sourceMappingURL=svelte.js.map