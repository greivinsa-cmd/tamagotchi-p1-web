import { hasESNodeParentExtension, isESCallExpression, isESObjectKey, isESStringLike, isESVariableDeclarator, isInsideObjectValue } from "../parsers/es.js";
export function getLiteralNodesByMatchers(ctx, node, matcherFunctions) {
    if (!hasESNodeParentExtension(node)) {
        return [];
    }
    const nestedLiterals = findMatchingNestedNodes(node, matcherFunctions);
    const self = nodeMatches(node, matcherFunctions) ? [node] : [];
    return [...nestedLiterals, ...self];
}
export function findMatchingNestedNodes(node, matcherFunctions) {
    return Object.entries(node).reduce((matchedNodes, [key, value]) => {
        if (!value || typeof value !== "object" || key === "parent") {
            return matchedNodes;
        }
        if (isESCallExpression(value)) {
            return matchedNodes;
        }
        if (isESVariableDeclarator(value)) {
            return matchedNodes;
        }
        if (nodeMatches(value, matcherFunctions)) {
            matchedNodes.push(value);
        }
        matchedNodes.push(...findMatchingNestedNodes(value, matcherFunctions));
        return matchedNodes;
    }, []);
}
export function findMatchingParentNodes(node, matcherFunctions) {
    if (!hasESNodeParentExtension(node)) {
        return [];
    }
    if (nodeMatches(node.parent, matcherFunctions)) {
        return [node.parent];
    }
    return findMatchingParentNodes(node.parent, matcherFunctions);
}
function nodeMatches(node, matcherFunctions) {
    for (const matcherFunction of matcherFunctions) {
        if (matcherFunction(node)) {
            return true;
        }
    }
    return false;
}
function isChildNodeOfNode(node, parent) {
    if (!hasESNodeParentExtension(node)) {
        return false;
    }
    if (node.parent === parent) {
        return true;
    }
    return isChildNodeOfNode(node.parent, parent);
}
export function getObjectPath(node) {
    if (!hasESNodeParentExtension(node)) {
        return;
    }
    if (node.type !== "Property" &&
        node.type !== "ObjectExpression" &&
        node.type !== "ArrayExpression" &&
        node.type !== "Identifier" &&
        node.type !== "Literal") {
        return;
    }
    const paths = [];
    if (node.type === "Property") {
        if (node.key.type === "Identifier") {
            paths.unshift(createObjectPathElement(node.key.name));
        }
        else if (node.key.type === "Literal") {
            paths.unshift(createObjectPathElement(node.key.value?.toString() ?? node.key.raw));
        }
        else {
            return "";
        }
    }
    if (isESStringLike(node) && isInsideObjectValue(node)) {
        const property = findMatchingParentNodes(node, [node => {
                return node.type === "Property";
            }])[0];
        return getObjectPath(property);
    }
    if (isESObjectKey(node)) {
        const property = node.parent;
        return getObjectPath(property);
    }
    if (node.parent.type === "ArrayExpression" && node.type !== "Property") {
        const index = node.parent.elements.indexOf(node);
        paths.unshift(`[${index}]`);
    }
    paths.unshift(getObjectPath(node.parent));
    return paths.reduce((paths, currentPath) => {
        if (!currentPath) {
            return paths;
        }
        if (paths.length === 0) {
            return [currentPath];
        }
        if (currentPath.startsWith("[") && currentPath.endsWith("]")) {
            return [...paths, currentPath];
        }
        return [...paths, ".", currentPath];
    }, []).join("");
}
function createObjectPathElement(path) {
    if (!path) {
        return "";
    }
    return path.match(/^[A-Z_a-z]\w*$/)
        ? path
        : `["${path}"]`;
}
export function matchesPathPattern(path, pattern) {
    const regex = new RegExp(pattern);
    return regex.test(path);
}
export function isCalleeName(callee) {
    return typeof callee === "string";
}
export function isCalleeRegex(callee) {
    return Array.isArray(callee) && typeof callee[0] === "string" && typeof callee[1] === "string";
}
export function isCalleeMatchers(callee) {
    return Array.isArray(callee) && typeof callee[0] === "string" && Array.isArray(callee[1]);
}
export function isVariableName(variable) {
    return typeof variable === "string";
}
export function isVariableRegex(variable) {
    return Array.isArray(variable) && typeof variable[0] === "string" && typeof variable[1] === "string";
}
export function isVariableMatchers(variable) {
    return Array.isArray(variable) && typeof variable[0] === "string" && Array.isArray(variable[1]);
}
export function isTagName(tag) {
    return typeof tag === "string";
}
export function isTagRegex(tag) {
    return Array.isArray(tag) && typeof tag[0] === "string" && typeof tag[1] === "string";
}
export function isTagMatchers(tag) {
    return Array.isArray(tag) && typeof tag[0] === "string" && Array.isArray(tag[1]);
}
export function isAttributesName(attributes) {
    return typeof attributes === "string";
}
export function isAttributesRegex(attributes) {
    return Array.isArray(attributes) && typeof attributes[0] === "string" && typeof attributes[1] === "string";
}
export function isAttributesMatchers(attributes) {
    return Array.isArray(attributes) && typeof attributes[0] === "string" && Array.isArray(attributes[1]);
}
export function isInsideConditionalExpressionTest(node) {
    if (!hasESNodeParentExtension(node)) {
        return false;
    }
    if (node.parent.type === "ConditionalExpression" && node.parent.test === node) {
        return true;
    }
    return isInsideConditionalExpressionTest(node.parent);
}
export function isInsideLogicalExpressionLeft(node) {
    if (!hasESNodeParentExtension(node)) {
        return false;
    }
    if (node.parent.type === "LogicalExpression" && node.parent.left === node) {
        return true;
    }
    return isInsideLogicalExpressionLeft(node.parent);
}
//# sourceMappingURL=matchers.js.map