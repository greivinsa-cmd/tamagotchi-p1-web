import { _ } from '@eslint-react/eff';
import { Scope, Variable } from '@typescript-eslint/scope-manager';
import { TSESTree } from '@typescript-eslint/types';

declare function findPropertyInProperties(name: string, properties: (TSESTree.Property | TSESTree.RestElement | TSESTree.SpreadElement)[], initialScope: Scope, seen?: Set<string>): (typeof properties)[number] | _;

declare const findVariable: {
    (initialScope: Scope): (nameOrNode: string | TSESTree.Identifier | _) => Variable | _;
    (nameOrNode: string | TSESTree.Identifier | _, initialScope: Scope): Variable | _;
};

declare function getChidScopes(scope: Scope): readonly Scope[];

declare function getVariableDeclaratorId(node: TSESTree.Node | _, prev?: TSESTree.Node): TSESTree.BindingName | TSESTree.Expression | _;

declare function getVariableInitNode(variable: Variable | _, at: number): _ | TSESTree.ClassDeclaration | TSESTree.ClassDeclarationWithName | TSESTree.ClassDeclarationWithOptionalName | TSESTree.Expression | TSESTree.FunctionDeclaration | TSESTree.FunctionDeclarationWithName | TSESTree.FunctionDeclarationWithOptionalName;

/**
 * Get all variables from the given scope up to the global scope
 * @param initialScope The scope to start from
 * @returns All variables from the given scope up to the global scope
 */
declare function getVariables(initialScope: Scope): Variable[];

/**
 * Determines whether node value equals to another node value
 * @param a node to compare
 * @param b node to compare
 * @param initialScopes initial scopes of the two nodes
 * @returns `true` if node value equal
 */
declare function isNodeValueEqual(a: TSESTree.Node, b: TSESTree.Node, initialScopes: [
    aScope: Scope,
    bScope: Scope
]): boolean;

type LazyValue = {
    kind: "lazy";
    node: TSESTree.Node;
    initialScope: Scope | _;
} | {
    kind: "none";
    node: TSESTree.Node;
    initialScope: Scope | _;
} | {
    kind: "some";
    node: TSESTree.Node;
    value: unknown;
    initialScope: Scope | _;
};
declare function toStaticValue(lazyValue: LazyValue): {
    readonly kind: "none";
    readonly node: TSESTree.Node;
    readonly initialScope: Scope | undefined;
    readonly value?: never;
} | {
    readonly kind: "some";
    readonly node: TSESTree.Node;
    readonly initialScope: Scope | undefined;
    readonly value: unknown;
};

type ValueConstruction = {
    kind: "ArrayExpression";
    node: TSESTree.ArrayExpression;
} | {
    kind: "CallExpression";
    node: TSESTree.CallExpression;
} | {
    kind: "ClassExpression";
    node: TSESTree.ClassExpression;
} | {
    kind: "FunctionDeclaration";
    node: TSESTree.FunctionDeclaration;
} | {
    kind: "FunctionExpression";
    node: TSESTree.FunctionExpression | TSESTree.ArrowFunctionExpression;
} | {
    kind: "JSXElement";
    node: TSESTree.JSXElement | TSESTree.JSXFragment;
} | {
    kind: "NewExpression";
    node: TSESTree.NewExpression;
} | {
    kind: "ObjectExpression";
    node: TSESTree.ObjectExpression;
} | {
    kind: "RegExpLiteral";
    node: TSESTree.RegExpLiteral;
};
declare const ValueConstructionHint: {
    None: bigint;
    StrictCallExpression: bigint;
};
/**
 * Get a function that detects the construction of a given node.
 * @param node The AST node to detect the construction of
 * @param initialScope The initial scope to use when detecting the construction
 * @param hint The hint to use when detecting the construction
 * @returns A function that detects the construction of a given node
 */
declare function getValueConstruction(node: TSESTree.Node | _, initialScope: Scope, hint?: bigint): ValueConstruction | _;

export { type LazyValue, type ValueConstruction, ValueConstructionHint, findPropertyInProperties, findVariable, getChidScopes, getValueConstruction, getVariableDeclaratorId, getVariableInitNode, getVariables, isNodeValueEqual, toStaticValue };
