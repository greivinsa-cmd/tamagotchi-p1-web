'use strict';

var AST6 = require('@eslint-react/ast');
var eff = require('@eslint-react/eff');
var JSX3 = require('@eslint-react/jsx');
var shared = require('@eslint-react/shared');
var types = require('@typescript-eslint/types');
var VAR = require('@eslint-react/var');
var tsPattern = require('ts-pattern');
var birecord = require('birecord');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST6__namespace = /*#__PURE__*/_interopNamespace(AST6);
var JSX3__namespace = /*#__PURE__*/_interopNamespace(JSX3);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);
var birecord__default = /*#__PURE__*/_interopDefault(birecord);

// src/component/component-collector.ts

// src/constants.ts
var DISPLAY_NAME_ASSIGNMENT_SELECTOR = [
  "AssignmentExpression",
  "[type]",
  "[operator='=']",
  "[left.type='MemberExpression']",
  "[left.property.name='displayName']"
].join("");

// src/hook/hook-name.ts
var RE_HOOK_NAME = /^use[A-Z\d]/u;
function isReactHookName(name) {
  return name === "use" || RE_HOOK_NAME.test(name);
}

// ../../node_modules/.pnpm/valibot@1.0.0-rc.4_typescript@5.8.2/node_modules/valibot/dist/index.js
var store;
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config2.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
  if (message !== void 0) {
    issue.message = typeof message === "function" ? (
      // @ts-expect-error
      message(issue)
    ) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, /* @__PURE__ */ getGlobalConfig());
    }
  };
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
// @__NO_SIDE_EFFECTS__
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item["~run"]({ value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = /* @__PURE__ */ getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// ../shared/src/schemas.ts
var CustomComponentPropSchema = object({
  /**
   * The name of the prop in the user-defined component.
   * @example
   * "to"
   */
  name: string(),
  /**
   * The name of the prop in the built-in component.
   * @example
   * "href"
   */
  as: optional(string()),
  /**
   * Whether the prop is controlled or not in the user-defined component.
   * @internal
   * @example
   * `true`
   */
  controlled: optional(boolean()),
  /**
   * The default value of the prop in the user-defined component.
   * @example
   * `"/"`
   */
  defaultValue: optional(string())
});
var CustomComponentSchema = object({
  /**
   * The name of the user-defined component.
   * @example
   * "Link"
   */
  name: string(),
  /**
   * The name of the built-in component that the user-defined component represents.
   * @example
   * "a"
   */
  as: optional(string()),
  /**
   * Attributes mapping between the user-defined component and the built-in component.
   * @example
   * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
   */
  attributes: optional(array(CustomComponentPropSchema)),
  /**
   * The ESQuery selector to select the component precisely.
   * @internal
   * @example
   * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
   */
  selector: optional(string())
});
var CustomHooksSchema = object({
  use: optional(array(string())),
  useActionState: optional(array(string())),
  useCallback: optional(array(string())),
  useContext: optional(array(string())),
  useDebugValue: optional(array(string())),
  useDeferredValue: optional(array(string())),
  useEffect: optional(array(string())),
  useFormStatus: optional(array(string())),
  useId: optional(array(string())),
  useImperativeHandle: optional(array(string())),
  useInsertionEffect: optional(array(string())),
  useLayoutEffect: optional(array(string())),
  useMemo: optional(array(string())),
  useOptimistic: optional(array(string())),
  useReducer: optional(array(string())),
  useRef: optional(array(string())),
  useState: optional(array(string())),
  useSyncExternalStore: optional(array(string())),
  useTransition: optional(array(string()))
});
var ESLintReactSettingsSchema = object({
  /**
   * The source where React is imported from.
   * @description This allows to specify a custom import location for React when not using the official distribution.
   * @default `"react"`
   * @example `"@pika/react"`
   */
  importSource: optional(string()),
  /**
   * The identifier that's used for JSX Element creation.
   * @default `"createElement"`
   * @deprecated
   */
  jsxPragma: optional(string()),
  /**
   * The identifier that's used for JSX fragment elements.
   * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
   * @default `"Fragment"`
   * @deprecated
   */
  jsxPragmaFrag: optional(string()),
  /**
   * The name of the prop that is used for polymorphic components.
   * @description This is used to determine the type of the component.
   * @example `"as"`
   */
  polymorphicPropName: optional(string()),
  /**
   * @internal
   */
  strict: optional(boolean(), false),
  /**
   * Check both the shape and the import to determine if an API is from React.
   * @description This can prevent false positives when using a irrelevant third-party library that has similar APIs to React.
   * @default `true`
   */
  skipImportCheck: optional(boolean(), true),
  /**
   * React version to use, "detect" means auto detect React version from the project's dependencies.
   * If `importSource` is specified, an equivalent version of React should be provided here.
   * @example `"18.3.1"`
   * @default `"detect"`
   */
  version: optional(string()),
  /**
   * A object to define additional hooks that are equivalent to the built-in React Hooks.
   * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
   * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
   */
  additionalHooks: optional(CustomHooksSchema),
  /**
   * An array of user-defined components
   * @description This is used to inform the ESLint React plugins how to treat these components during checks.
   * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
   */
  additionalComponents: optional(array(CustomComponentSchema))
});
var DEFAULT_ESLINT_REACT_SETTINGS = {
  ...parse(ESLintReactSettingsSchema, {}),
  importSource: "react"};
function getInstanceId(node, prev) {
  switch (true) {
    case (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init === prev):
      return node.id;
    case (node.type === types.AST_NODE_TYPES.AssignmentExpression && node.right === prev):
      return node.left;
    case (node.type === types.AST_NODE_TYPES.PropertyDefinition && node.value === prev):
      return node.key;
    case (node.type === types.AST_NODE_TYPES.BlockStatement || node.type === types.AST_NODE_TYPES.Program || node.parent === node):
      return eff._;
    default:
      return getInstanceId(node.parent, node);
  }
}
function getRequireExpressionArguments(node) {
  return tsPattern.match(node).with({ type: types.AST_NODE_TYPES.CallExpression, arguments: tsPattern.P.select(), callee: { type: types.AST_NODE_TYPES.Identifier, name: "require" } }, eff.identity).with({ type: types.AST_NODE_TYPES.MemberExpression, object: tsPattern.P.select() }, getRequireExpressionArguments).otherwise(() => eff._);
}
function isInitializedFromReact(name, importSource, initialScope) {
  if (name.toLowerCase() === "react") return true;
  const latestDef = VAR__namespace.findVariable(name, initialScope)?.defs.at(-1);
  if (latestDef == null) return false;
  const { node, parent } = latestDef;
  if (node.type === types.AST_NODE_TYPES.VariableDeclarator && node.init != null) {
    const { init } = node;
    if (init.type === types.AST_NODE_TYPES.MemberExpression && init.object.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.object.name, importSource, initialScope);
    }
    if (init.type === types.AST_NODE_TYPES.Identifier) {
      return isInitializedFromReact(init.name, importSource, initialScope);
    }
    const args = getRequireExpressionArguments(init);
    const arg0 = args?.[0];
    if (arg0 == null || !AST6__namespace.isKindOfLiteral(arg0, "string")) {
      return false;
    }
    return arg0.value === importSource || arg0.value.startsWith(`${importSource}/`);
  }
  return parent?.type === types.AST_NODE_TYPES.ImportDeclaration && parent.source.value === importSource;
}

// src/utils/is-from-react.ts
var defaultImportSource = shared.DEFAULT_ESLINT_REACT_SETTINGS.importSource;
function isFromReactLoose(node, name) {
  switch (node?.type) {
    case types.AST_NODE_TYPES.Identifier:
      return node.name === name;
    case types.AST_NODE_TYPES.MemberExpression:
      return node.object.type === types.AST_NODE_TYPES.Identifier && node.property.type === types.AST_NODE_TYPES.Identifier && node.property.name === name;
    default:
      return false;
  }
}
function isFromReactStrict(node, name, importSource, initialScope) {
  switch (node?.type) {
    case types.AST_NODE_TYPES.Identifier:
      return node.name === name && isInitializedFromReact(name, importSource, initialScope);
    case types.AST_NODE_TYPES.MemberExpression:
      return node.object.type === types.AST_NODE_TYPES.Identifier && node.property.type === types.AST_NODE_TYPES.Identifier && node.property.name === name && isInitializedFromReact(node.object.name, importSource, initialScope);
    default:
      return false;
  }
}
function isFromReact(name) {
  return eff.dual(2, (context, node) => {
    if (node == null) return false;
    const { importSource = defaultImportSource, skipImportCheck = true } = shared.unsafeDecodeSettings(context.settings);
    if (skipImportCheck) return isFromReactLoose(node, name);
    return isFromReactStrict(node, name, importSource, context.sourceCode.getScope(node));
  });
}
function isFromReactObject(objectName, propertyName) {
  return eff.dual(2, (context, node) => {
    if (node?.type !== types.AST_NODE_TYPES.MemberExpression) return false;
    const { importSource = defaultImportSource, skipImportCheck = true } = shared.unsafeDecodeSettings(context.settings);
    const { object: object2, property } = node;
    if (skipImportCheck) return isFromReactLoose(object2, objectName) && isFromReactLoose(property, propertyName);
    return isFromReactStrict(
      object2,
      objectName,
      importSource,
      context.sourceCode.getScope(object2)
    ) && isFromReactLoose(property, propertyName);
  });
}
function isCallFromReact(name) {
  return eff.dual(2, (context, node) => {
    if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
    return isFromReact(name)(context, node.callee);
  });
}
function isCallFromReactObject(objectName, propertyName) {
  return eff.dual(2, (context, node) => {
    if (node.type !== types.AST_NODE_TYPES.CallExpression) return false;
    return isFromReactObject(objectName, propertyName)(context, node.callee);
  });
}
function isInstanceIdEqual(context, a, b) {
  return AST6__namespace.isNodeEqual(a, b) || VAR__namespace.isNodeValueEqual(a, b, [
    context.sourceCode.getScope(a),
    context.sourceCode.getScope(b)
  ]);
}

// src/utils/is-react-api.ts
function isReactAPI(arg0, arg1) {
  return arg1 == null ? isFromReact(arg0) : isFromReactObject(arg0, arg1);
}
function isReactAPICall(arg0, arg1) {
  return arg1 == null ? isCallFromReact(arg0) : isCallFromReactObject(arg0, arg1);
}
var isChildrenCount = isReactAPI("Children", "count");
var isChildrenForEach = isReactAPI("Children", "forEach");
var isChildrenMap = isReactAPI("Children", "map");
var isChildrenOnly = isReactAPI("Children", "only");
var isChildrenToArray = isReactAPI("Children", "toArray");
var isCloneElement = isReactAPI("cloneElement");
var isCreateContext = isReactAPI("createContext");
var isCreateElement = isReactAPI("createElement");
var isCreateRef = isReactAPI("createRef");
var isForwardRef = isReactAPI("forwardRef");
var isMemo = isReactAPI("memo");
var isChildrenCountCall = isReactAPICall("Children", "count");
var isChildrenForEachCall = isReactAPICall("Children", "forEach");
var isChildrenMapCall = isReactAPICall("Children", "map");
var isChildrenOnlyCall = isReactAPICall("Children", "only");
var isChildrenToArrayCall = isReactAPICall("Children", "toArray");
var isCloneElementCall = isReactAPICall("cloneElement");
var isCreateContextCall = isReactAPICall("createContext");
var isCreateElementCall = isReactAPICall("createElement");
var isCreateRefCall = isReactAPICall("createRef");
var isForwardRefCall = isReactAPICall("forwardRef");
var isMemoCall = isReactAPICall("memo");

// src/hook/is.ts
function isReactHook(node) {
  if (node == null) return eff._;
  const id = AST6__namespace.getFunctionIdentifier(node);
  return id?.name != null && isReactHookName(id.name);
}
function isReactHookCall(node) {
  if (node == null) return false;
  if (node.type !== types.AST_NODE_TYPES.CallExpression) {
    return false;
  }
  if (node.callee.type === types.AST_NODE_TYPES.Identifier) {
    return isReactHookName(node.callee.name);
  }
  if (node.callee.type === types.AST_NODE_TYPES.MemberExpression) {
    return node.callee.property.type === types.AST_NODE_TYPES.Identifier && isReactHookName(node.callee.property.name);
  }
  return false;
}
function isReactHookCallWithName(context, node) {
  if (node == null) return eff.constFalse;
  const {
    importSource = DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = shared.unsafeDecodeSettings(context.settings);
  const initialScope = context.sourceCode.getScope(node);
  return (name) => {
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameLoose(node) {
  if (node == null) return eff.constFalse;
  return (name) => {
    switch (node.callee.type) {
      case types.AST_NODE_TYPES.Identifier:
        return node.callee.name === name;
      case types.AST_NODE_TYPES.MemberExpression:
        return node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name;
      default:
        return false;
    }
  };
}
function isReactHookCallWithNameAlias(context, name, alias = []) {
  const {
    importSource = DEFAULT_ESLINT_REACT_SETTINGS.importSource,
    skipImportCheck = true
  } = shared.unsafeDecodeSettings(context.settings);
  return (node) => {
    const initialScope = context.sourceCode.getScope(node);
    switch (true) {
      case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === name):
        return skipImportCheck || isInitializedFromReact(name, importSource, initialScope);
      case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === name && "name" in node.callee.object):
        return skipImportCheck || isInitializedFromReact(node.callee.object.name, importSource, initialScope);
      default:
        return alias.some(isReactHookCallWithNameLoose(node));
    }
  };
}
function isUseEffectCallLoose(node) {
  if (node == null) return false;
  if (node.type !== types.AST_NODE_TYPES.CallExpression) {
    return false;
  }
  switch (node.callee.type) {
    case types.AST_NODE_TYPES.Identifier:
      return /^use\w*Effect$/u.test(node.callee.name);
    case types.AST_NODE_TYPES.MemberExpression:
      return node.callee.property.type === types.AST_NODE_TYPES.Identifier && /^use\w*Effect$/u.test(node.callee.property.name);
    default:
      return false;
  }
}
var isUseCallbackCall = eff.flip(isReactHookCallWithName)("useCallback");
var isUseContextCall = eff.flip(isReactHookCallWithName)("useContext");
var isUseDebugValueCall = eff.flip(isReactHookCallWithName)("useDebugValue");
var isUseDeferredValueCall = eff.flip(isReactHookCallWithName)("useDeferredValue");
var isUseEffectCall = eff.flip(isReactHookCallWithName)("useEffect");
var isUseIdCall = eff.flip(isReactHookCallWithName)("useId");
var isUseImperativeHandleCall = eff.flip(isReactHookCallWithName)("useImperativeHandle");
var isUseInsertionEffectCall = eff.flip(isReactHookCallWithName)("useInsertionEffect");
var isUseLayoutEffectCall = eff.flip(isReactHookCallWithName)("useLayoutEffect");
var isUseMemoCall = eff.flip(isReactHookCallWithName)("useMemo");
var isUseReducerCall = eff.flip(isReactHookCallWithName)("useReducer");
var isUseRefCall = eff.flip(isReactHookCallWithName)("useRef");
var isUseStateCall = eff.flip(isReactHookCallWithName)("useState");
var isUseSyncExternalStoreCall = eff.flip(isReactHookCallWithName)("useSyncExternalStore");
var isUseTransitionCall = eff.flip(isReactHookCallWithName)("useTransition");

// src/hook/hook-collector.ts
function useHookCollector() {
  const hooks = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const onFunctionEnter = (node) => {
    const id = AST6__namespace.getFunctionIdentifier(node);
    const key = shared.getId();
    const name = id?.name;
    if (name != null && isReactHookName(name)) {
      functionEntries.push({ key, node, isHook: true });
      hooks.set(key, {
        id,
        key,
        kind: "function",
        name,
        node,
        flag: 0n,
        hint: 0n,
        hookCalls: []
      });
      return;
    }
    functionEntries.push({ key, node, isHook: false });
  };
  const onFunctionExit = () => {
    functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllHooks(node) {
      return hooks;
    }
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "CallExpression[type]"(node) {
      if (!isReactHookCall(node)) {
        return;
      }
      const fEntry = functionEntries.at(-1);
      if (fEntry?.key == null) {
        return;
      }
      const hook = hooks.get(fEntry.key);
      if (hook == null) {
        return;
      }
      hook.hookCalls.push(node);
    }
  };
  return { ctx, listeners };
}
var ERComponentHint = {
  /**
   * 1n << 0n - 1n << 63n are reserved for JSXValueHint
   */
  ...JSX3__namespace.JSXValueHint,
  /**
   * Skip function component created by React.memo
   */
  SkipMemo: 1n << 64n,
  /**
   * Skip function component created by React.forwardRef
   */
  SkipForwardRef: 1n << 65n,
  /**
   * Skip function component defined in map function callback
   */
  SkipMapCallback: 1n << 66n,
  /**
   * Skip function component defined on object method
   */
  SkipObjectMethod: 1n << 67n,
  /**
   * Skip function component defined on class method
   */
  SkipClassMethod: 1n << 68n,
  /**
   * Skip function component defined on class property
   */
  SkipClassProperty: 1n << 69n
};
var DEFAULT_COMPONENT_HINT = 0n | ERComponentHint.SkipBooleanLiteral | ERComponentHint.SkipEmptyArray | ERComponentHint.SkipMapCallback | ERComponentHint.SkipNumberLiteral | ERComponentHint.SkipStringLiteral | ERComponentHint.SkipUndefined | ERComponentHint.StrictArray | ERComponentHint.StrictConditional | ERComponentHint.StrictLogical;

// src/component/component-flag.ts
var ERComponentFlag = {
  None: 0n,
  PureComponent: 1n << 0n,
  CreateElement: 1n << 1n,
  Memo: 1n << 2n,
  ForwardRef: 1n << 3n,
  Async: 1n << 4n
};
function isComponentWrapperCall(context, node) {
  if (node.type !== types.AST_NODE_TYPES.CallExpression) {
    return false;
  }
  return isMemoCall(context, node) || isForwardRefCall(context, node) || isReactHookCallWithNameLoose(node)("useCallback");
}
function getFunctionComponentIdentifier(context, node) {
  const functionId = AST6__namespace.getFunctionIdentifier(node);
  if (functionId != null) {
    return functionId;
  }
  const { parent } = node;
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(context, parent) && parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return parent.parent.id;
  }
  if (parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(context, parent) && parent.parent.type === types.AST_NODE_TYPES.CallExpression && isComponentWrapperCall(context, parent.parent) && parent.parent.parent.type === types.AST_NODE_TYPES.VariableDeclarator && parent.parent.parent.id.type === types.AST_NODE_TYPES.Identifier) {
    return parent.parent.parent.id;
  }
  return eff._;
}
var RE_COMPONENT_NAME = /^[A-Z]/u;
var RE_COMPONENT_NAME_LOOSE = /^_?[A-Z]/u;
function isComponentName(name) {
  return RE_COMPONENT_NAME.test(name);
}
function isComponentNameLoose(name) {
  return RE_COMPONENT_NAME_LOOSE.test(name);
}
function getComponentNameFromIdentifier(node) {
  if (node == null) return eff._;
  return Array.isArray(node) ? node.map((n) => n.name).join(".") : node.name;
}
function hasNoneOrLooseComponentName(context, node) {
  const id = getFunctionComponentIdentifier(context, node);
  if (id == null) return true;
  const name = Array.isArray(id) ? id.at(-1)?.name : id.name;
  return name != null && isComponentNameLoose(name);
}
function isClassComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^(?:Pure)?Component$/u;
    switch (true) {
      case node.superClass.type === types.AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === types.AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}
function isPureComponent(node) {
  if ("superClass" in node && node.superClass != null) {
    const re = /^PureComponent$/u;
    switch (true) {
      case node.superClass.type === types.AST_NODE_TYPES.Identifier:
        return re.test(node.superClass.name);
      case (node.superClass.type === types.AST_NODE_TYPES.MemberExpression && node.superClass.property.type === types.AST_NODE_TYPES.Identifier):
        return re.test(node.superClass.property.name);
    }
  }
  return false;
}

// src/component/component-lifecycle.ts
function isComponentDidMount(node) {
  return AST6__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
function isComponentWillUnmount(node) {
  return AST6__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUnmount";
}
function isComponentDidCatch(node) {
  return AST6__namespace.isMethodOrProperty(node) && !node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidCatch";
}
function isGetDerivedStateFromError(node) {
  return AST6__namespace.isMethodOrProperty(node) && node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromError";
}
function isGetDerivedStateFromProps(node) {
  return AST6__namespace.isMethodOrProperty(node) && node.static && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "getDerivedStateFromProps";
}
function isFunctionOfComponentDidMount(node) {
  return AST6__namespace.isFunction(node) && isComponentDidMount(node.parent) && node.parent.value === node;
}
function isFunctionOfComponentWillUnmount(node) {
  return AST6__namespace.isFunction(node) && isComponentWillUnmount(node.parent) && node.parent.value === node;
}
function isRenderMethodLike(node) {
  return AST6__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "render" && node.parent.parent.type === types.AST_NODE_TYPES.ClassDeclaration;
}
function isFunctionOfRenderMethod(node) {
  if (!isRenderMethodLike(node.parent)) {
    return false;
  }
  return isClassComponent(node.parent.parent.parent);
}
function isInsideRenderMethod(node) {
  return AST6__namespace.findParentNode(node, (node2) => isRenderMethodLike(node2) && isClassComponent(node2.parent.parent)) != null;
}

// src/component/hierarchy.ts
function hasValidHierarchy(context, node, hint) {
  if (isChildrenOfCreateElement(context, node) || isFunctionOfRenderMethod(node)) {
    return false;
  }
  if (hint & ERComponentHint.SkipMapCallback && AST6__namespace.isMapCallLoose(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipObjectMethod && isFunctionOfObjectMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassMethod && isFunctionOfClassMethod(node.parent)) {
    return false;
  }
  if (hint & ERComponentHint.SkipClassProperty && isFunctionOfClassProperty(node.parent)) {
    return false;
  }
  const boundaryNode = AST6__namespace.findParentNode(
    node,
    AST6__namespace.isOneOf([
      types.AST_NODE_TYPES.JSXExpressionContainer,
      types.AST_NODE_TYPES.ArrowFunctionExpression,
      types.AST_NODE_TYPES.FunctionExpression,
      types.AST_NODE_TYPES.Property,
      types.AST_NODE_TYPES.ClassBody
    ])
  );
  return boundaryNode == null || boundaryNode.type !== types.AST_NODE_TYPES.JSXExpressionContainer;
}
function isChildrenOfCreateElement(context, node) {
  const parent = node.parent;
  if (parent == null || parent.type !== types.AST_NODE_TYPES.CallExpression) return false;
  if (!isCreateElementCall(context, parent)) return false;
  return parent.arguments.slice(2).some((arg) => arg === node);
}
function isFunctionOfClassMethod(node) {
  return (node.type === types.AST_NODE_TYPES.FunctionExpression || node.type === types.AST_NODE_TYPES.ArrowFunctionExpression) && node.parent.type === types.AST_NODE_TYPES.MethodDefinition;
}
function isFunctionOfClassProperty(node) {
  return (node.type === types.AST_NODE_TYPES.FunctionExpression || node.type === types.AST_NODE_TYPES.ArrowFunctionExpression) && node.parent.type === types.AST_NODE_TYPES.Property;
}
function isFunctionOfObjectMethod(node) {
  return (node.type === types.AST_NODE_TYPES.FunctionExpression || node.type === types.AST_NODE_TYPES.ArrowFunctionExpression) && node.parent.type === types.AST_NODE_TYPES.Property && node.parent.parent.type === types.AST_NODE_TYPES.ObjectExpression;
}

// src/component/component-collector.ts
function useComponentCollector(context, options = {}) {
  const {
    collectDisplayName = false,
    collectHookCalls = false,
    hint = DEFAULT_COMPONENT_HINT
  } = options;
  const jsxCtx = { getScope: (node) => context.sourceCode.getScope(node) };
  const components = /* @__PURE__ */ new Map();
  const functionEntries = [];
  const getCurrentEntry = () => functionEntries.at(-1);
  const onFunctionEnter = (node) => {
    const key = shared.getId();
    functionEntries.push({ key, node, hookCalls: [], isComponent: false });
  };
  const onFunctionExit = () => {
    const entry = functionEntries.at(-1);
    if (entry == null) return;
    if (!entry.isComponent) return functionEntries.pop();
    const shouldDrop = AST6__namespace.getNestedReturnStatements(entry.node.body).slice().reverse().some((r) => {
      return context.sourceCode.getScope(r).block === entry.node && r.argument != null && !JSX3__namespace.isJSXValue(r.argument, jsxCtx, hint);
    });
    if (shouldDrop) {
      components.delete(entry.key);
    }
    return functionEntries.pop();
  };
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    },
    getCurrentEntries() {
      return [...functionEntries];
    },
    getCurrentEntry
  };
  const listeners = {
    ":function[type]": onFunctionEnter,
    ":function[type]:exit": onFunctionExit,
    "ArrowFunctionExpression[type][body.type!='BlockStatement']"() {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const { body } = entry.node;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && JSX3__namespace.isJSXValue(body, jsxCtx, hint) && hasValidHierarchy(context, entry.node, hint);
      if (!isComponent) return;
      const initPath = AST6__namespace.getFunctionInitPath(entry.node);
      const id = getFunctionComponentIdentifier(context, entry.node);
      const name = getComponentNameFromIdentifier(id);
      const key = shared.getId();
      components.set(key, {
        id,
        key,
        kind: "function",
        name,
        node: entry.node,
        displayName: eff._,
        flag: getComponentFlag(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    },
    ...collectDisplayName ? {
      [DISPLAY_NAME_ASSIGNMENT_SELECTOR](node) {
        const { left, right } = node;
        if (left.type !== types.AST_NODE_TYPES.MemberExpression) return;
        const componentName = left.object.type === types.AST_NODE_TYPES.Identifier ? left.object.name : eff._;
        const component = [...components.values()].findLast(({ name }) => name != null && name === componentName);
        if (component == null) return;
        component.displayName = right;
      }
    } : {},
    ...collectHookCalls ? {
      "CallExpression[type]:exit"(node) {
        if (!isReactHookCall(node)) return;
        const entry = getCurrentEntry();
        if (entry == null) return;
        entry.hookCalls.push(node);
      }
    } : {},
    "ReturnStatement[type]"(node) {
      const entry = getCurrentEntry();
      if (entry == null) return;
      const isComponent = hasNoneOrLooseComponentName(context, entry.node) && JSX3__namespace.isJSXValue(node.argument, jsxCtx, hint) && hasValidHierarchy(context, entry.node, hint);
      if (!isComponent) return;
      entry.isComponent = true;
      const initPath = AST6__namespace.getFunctionInitPath(entry.node);
      const id = getFunctionComponentIdentifier(context, entry.node);
      const name = getComponentNameFromIdentifier(id);
      components.set(entry.key, {
        id,
        key: entry.key,
        kind: "function",
        name,
        node: entry.node,
        displayName: eff._,
        flag: getComponentFlag(initPath),
        hint,
        hookCalls: entry.hookCalls,
        initPath
      });
    }
  };
  return { ctx, listeners };
}
function getComponentFlag(initPath) {
  let flag = ERComponentFlag.None;
  if (initPath != null && AST6__namespace.hasCallInFunctionInitPath("memo", initPath)) {
    flag |= ERComponentFlag.Memo;
  }
  if (initPath != null && AST6__namespace.hasCallInFunctionInitPath("forwardRef", initPath)) {
    flag |= ERComponentFlag.ForwardRef;
  }
  return flag;
}
function useComponentCollectorLegacy() {
  const components = /* @__PURE__ */ new Map();
  const ctx = {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAllComponents(node) {
      return components;
    }
  };
  const collect = (node) => {
    if (!isClassComponent(node)) {
      return;
    }
    const id = AST6__namespace.getClassIdentifier(node);
    const key = shared.getId();
    const flag = isPureComponent(node) ? ERComponentFlag.PureComponent : ERComponentFlag.None;
    components.set(
      key,
      {
        id,
        key,
        kind: "class",
        name: id?.name,
        node,
        // TODO: Get displayName of class component
        displayName: eff._,
        flag,
        hint: 0n,
        // TODO: Get methods of class component
        methods: []
      }
    );
  };
  const listeners = {
    "ClassDeclaration[type]": collect,
    "ClassExpression[type]": collect
  };
  return { ctx, listeners };
}
var ERPhaseRelevance = birecord__default.default({
  mount: "unmount",
  setup: "cleanup"
});
var isInversePhase = eff.dual(2, (a, b) => ERPhaseRelevance.get(a) === b);
function isRenderFunctionLoose(context, node) {
  const { body, parent } = node;
  if (AST6__namespace.getFunctionIdentifier(node)?.name.startsWith("render")) {
    return parent.type === types.AST_NODE_TYPES.JSXExpressionContainer && parent.parent.type === types.AST_NODE_TYPES.JSXAttribute && parent.parent.name.type === types.AST_NODE_TYPES.JSXIdentifier && parent.parent.name.name.startsWith("render");
  }
  return JSX3__namespace.isJSXValue(
    body,
    {
      getScope: (node2) => context.sourceCode.getScope(node2)
    },
    JSX3__namespace.JSXValueHint.SkipNullLiteral | JSX3__namespace.JSXValueHint.SkipUndefined | JSX3__namespace.JSXValueHint.StrictLogical | JSX3__namespace.JSXValueHint.StrictConditional
  );
}
function isRenderPropLoose(context, node) {
  if (node.name.type !== types.AST_NODE_TYPES.JSXIdentifier) {
    return false;
  }
  return node.name.name.startsWith("render") && node.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer && AST6__namespace.isFunction(node.value.expression) && isRenderFunctionLoose(context, node.value.expression);
}
function isDirectValueOfRenderPropertyLoose(node) {
  const matching = (node2) => {
    return node2.type === types.AST_NODE_TYPES.Property && node2.key.type === types.AST_NODE_TYPES.Identifier && node2.key.name.startsWith("render");
  };
  return matching(node) || node.parent != null && matching(node.parent);
}
function isDeclaredInRenderPropLoose(node) {
  if (isDirectValueOfRenderPropertyLoose(node)) {
    return true;
  }
  const parent = AST6__namespace.findParentNode(node, AST6__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer))?.parent;
  if (parent?.type !== types.AST_NODE_TYPES.JSXAttribute) {
    return false;
  }
  return parent.name.type === types.AST_NODE_TYPES.JSXIdentifier && parent.name.name.startsWith("render");
}
function isThisSetState(node) {
  const { callee } = node;
  return callee.type === types.AST_NODE_TYPES.MemberExpression && AST6__namespace.isThisExpression(callee.object) && callee.property.type === types.AST_NODE_TYPES.Identifier && callee.property.name === "setState";
}
function isAssignmentToThisState(node) {
  const { left } = node;
  return left.type === types.AST_NODE_TYPES.MemberExpression && AST6__namespace.isThisExpression(left.object) && AST6__namespace.getPropertyName(left.property) === "state";
}
function isFunctionOfUseEffectSetup(node) {
  if (node == null) return eff._;
  return node.parent?.type === types.AST_NODE_TYPES.CallExpression && node.parent.callee !== node && node.parent.callee.type === types.AST_NODE_TYPES.Identifier && node.parent.arguments.at(0) === node && isUseEffectCallLoose(node.parent);
}
function isFunctionOfUseEffectCleanup(node) {
  if (node == null) return eff._;
  const returnStatement = AST6__namespace.findParentNode(node, AST6__namespace.is(types.AST_NODE_TYPES.ReturnStatement));
  const enclosingFunction = AST6__namespace.findParentNode(node, AST6__namespace.isFunction);
  const functionOfReturnStatement = AST6__namespace.findParentNode(returnStatement, AST6__namespace.isFunction);
  return enclosingFunction === functionOfReturnStatement && isFunctionOfUseEffectSetup(enclosingFunction);
}

exports.DEFAULT_COMPONENT_HINT = DEFAULT_COMPONENT_HINT;
exports.DISPLAY_NAME_ASSIGNMENT_SELECTOR = DISPLAY_NAME_ASSIGNMENT_SELECTOR;
exports.ERComponentFlag = ERComponentFlag;
exports.ERComponentHint = ERComponentHint;
exports.ERPhaseRelevance = ERPhaseRelevance;
exports.RE_COMPONENT_NAME = RE_COMPONENT_NAME;
exports.RE_COMPONENT_NAME_LOOSE = RE_COMPONENT_NAME_LOOSE;
exports.RE_HOOK_NAME = RE_HOOK_NAME;
exports.getComponentNameFromIdentifier = getComponentNameFromIdentifier;
exports.getFunctionComponentIdentifier = getFunctionComponentIdentifier;
exports.getInstanceId = getInstanceId;
exports.hasNoneOrLooseComponentName = hasNoneOrLooseComponentName;
exports.hasValidHierarchy = hasValidHierarchy;
exports.isAssignmentToThisState = isAssignmentToThisState;
exports.isCallFromReact = isCallFromReact;
exports.isCallFromReactObject = isCallFromReactObject;
exports.isChildrenCount = isChildrenCount;
exports.isChildrenCountCall = isChildrenCountCall;
exports.isChildrenForEach = isChildrenForEach;
exports.isChildrenForEachCall = isChildrenForEachCall;
exports.isChildrenMap = isChildrenMap;
exports.isChildrenMapCall = isChildrenMapCall;
exports.isChildrenOnly = isChildrenOnly;
exports.isChildrenOnlyCall = isChildrenOnlyCall;
exports.isChildrenToArray = isChildrenToArray;
exports.isChildrenToArrayCall = isChildrenToArrayCall;
exports.isClassComponent = isClassComponent;
exports.isCloneElement = isCloneElement;
exports.isCloneElementCall = isCloneElementCall;
exports.isComponentDidCatch = isComponentDidCatch;
exports.isComponentDidMount = isComponentDidMount;
exports.isComponentName = isComponentName;
exports.isComponentNameLoose = isComponentNameLoose;
exports.isComponentWillUnmount = isComponentWillUnmount;
exports.isCreateContext = isCreateContext;
exports.isCreateContextCall = isCreateContextCall;
exports.isCreateElement = isCreateElement;
exports.isCreateElementCall = isCreateElementCall;
exports.isCreateRef = isCreateRef;
exports.isCreateRefCall = isCreateRefCall;
exports.isDeclaredInRenderPropLoose = isDeclaredInRenderPropLoose;
exports.isDirectValueOfRenderPropertyLoose = isDirectValueOfRenderPropertyLoose;
exports.isForwardRef = isForwardRef;
exports.isForwardRefCall = isForwardRefCall;
exports.isFromReact = isFromReact;
exports.isFromReactLoose = isFromReactLoose;
exports.isFromReactObject = isFromReactObject;
exports.isFromReactStrict = isFromReactStrict;
exports.isFunctionOfComponentDidMount = isFunctionOfComponentDidMount;
exports.isFunctionOfComponentWillUnmount = isFunctionOfComponentWillUnmount;
exports.isFunctionOfRenderMethod = isFunctionOfRenderMethod;
exports.isFunctionOfUseEffectCleanup = isFunctionOfUseEffectCleanup;
exports.isFunctionOfUseEffectSetup = isFunctionOfUseEffectSetup;
exports.isGetDerivedStateFromError = isGetDerivedStateFromError;
exports.isGetDerivedStateFromProps = isGetDerivedStateFromProps;
exports.isInitializedFromReact = isInitializedFromReact;
exports.isInsideRenderMethod = isInsideRenderMethod;
exports.isInstanceIdEqual = isInstanceIdEqual;
exports.isInversePhase = isInversePhase;
exports.isMemo = isMemo;
exports.isMemoCall = isMemoCall;
exports.isPureComponent = isPureComponent;
exports.isReactAPI = isReactAPI;
exports.isReactAPICall = isReactAPICall;
exports.isReactHook = isReactHook;
exports.isReactHookCall = isReactHookCall;
exports.isReactHookCallWithName = isReactHookCallWithName;
exports.isReactHookCallWithNameAlias = isReactHookCallWithNameAlias;
exports.isReactHookCallWithNameLoose = isReactHookCallWithNameLoose;
exports.isReactHookName = isReactHookName;
exports.isRenderFunctionLoose = isRenderFunctionLoose;
exports.isRenderMethodLike = isRenderMethodLike;
exports.isRenderPropLoose = isRenderPropLoose;
exports.isThisSetState = isThisSetState;
exports.isUseCallbackCall = isUseCallbackCall;
exports.isUseContextCall = isUseContextCall;
exports.isUseDebugValueCall = isUseDebugValueCall;
exports.isUseDeferredValueCall = isUseDeferredValueCall;
exports.isUseEffectCall = isUseEffectCall;
exports.isUseEffectCallLoose = isUseEffectCallLoose;
exports.isUseIdCall = isUseIdCall;
exports.isUseImperativeHandleCall = isUseImperativeHandleCall;
exports.isUseInsertionEffectCall = isUseInsertionEffectCall;
exports.isUseLayoutEffectCall = isUseLayoutEffectCall;
exports.isUseMemoCall = isUseMemoCall;
exports.isUseReducerCall = isUseReducerCall;
exports.isUseRefCall = isUseRefCall;
exports.isUseStateCall = isUseStateCall;
exports.isUseSyncExternalStoreCall = isUseSyncExternalStoreCall;
exports.isUseTransitionCall = isUseTransitionCall;
exports.useComponentCollector = useComponentCollector;
exports.useComponentCollectorLegacy = useComponentCollectorLegacy;
exports.useHookCollector = useHookCollector;
