import * as AST from '@eslint-react/ast';
import { _ } from '@eslint-react/eff';
import { RuleContext } from '@eslint-react/shared';
import { TSESTree } from '@typescript-eslint/types';
import { ESLintUtils, TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as birecord from 'birecord';
import * as _typescript_eslint_utils_ts_eslint from '@typescript-eslint/utils/ts-eslint';
import { Scope } from '@typescript-eslint/scope-manager';

type ERComponentHint = bigint;
/**
 * hints for component collector
 */
declare const ERComponentHint: {
    /**
     * Skip function component created by React.memo
     */
    readonly SkipMemo: bigint;
    /**
     * Skip function component created by React.forwardRef
     */
    readonly SkipForwardRef: bigint;
    /**
     * Skip function component defined in map function callback
     */
    readonly SkipMapCallback: bigint;
    /**
     * Skip function component defined on object method
     */
    readonly SkipObjectMethod: bigint;
    /**
     * Skip function component defined on class method
     */
    readonly SkipClassMethod: bigint;
    /**
     * Skip function component defined on class property
     */
    readonly SkipClassProperty: bigint;
    readonly None: 0n;
    readonly SkipUndefined: bigint;
    readonly SkipNullLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipBigIntLiteral: bigint;
    readonly SkipEmptyArray: bigint;
    readonly SkipCreateElement: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_COMPONENT_HINT: bigint;

interface ERSemanticNode {
    id: _ | TSESTree.Identifier | TSESTree.Identifier[];
    key: string;
    kind: string;
    name: _ | string;
    node: TSESTree.Node;
    flag: bigint;
    hint: bigint;
}

type ERComponentFlag = bigint;
declare const ERComponentFlag: {
    None: bigint;
    PureComponent: bigint;
    CreateElement: bigint;
    Memo: bigint;
    ForwardRef: bigint;
    Async: bigint;
};

interface ERFunctionComponent extends ERSemanticNode {
    id: _ | TSESTree.Identifier | TSESTree.Identifier[];
    kind: "function";
    node: AST.TSESTreeFunction;
    flag: ERComponentFlag;
    hint: ERComponentHint;
    initPath: _ | AST.FunctionInitPath;
    hookCalls: TSESTree.CallExpression[];
    displayName: _ | TSESTree.Expression;
}
interface ERClassComponent extends ERSemanticNode {
    id: _ | TSESTree.Identifier;
    kind: "class";
    node: AST.TSESTreeClass;
    flag: ERComponentFlag;
    hint: ERComponentHint;
    methods: AST.TSESTreeMethodOrProperty[];
    displayName: _ | TSESTree.Expression;
}
type ERComponent = ERClassComponent | ERFunctionComponent;

type FunctionEntry = {
    key: string;
    node: AST.TSESTreeFunction;
    hookCalls: TSESTree.CallExpression[];
    isComponent: boolean;
};
declare namespace useComponentCollector {
    type Options = {
        collectDisplayName?: boolean;
        collectHookCalls?: boolean;
        hint?: ERComponentHint;
    };
    type ReturnType = {
        ctx: {
            getAllComponents: (node: TSESTree.Program) => Map<string, ERFunctionComponent>;
            getCurrentEntries: () => FunctionEntry[];
            getCurrentEntry: () => FunctionEntry | _;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
/**
 * Get a ctx and listeners for the rule to collect function components
 * @param context The ESLint rule context
 * @param options The options to use
 * @returns The component collector
 */
declare function useComponentCollector(context: RuleContext, options?: useComponentCollector.Options): useComponentCollector.ReturnType;

declare namespace useComponentCollectorLegacy {
    type ReturnType = {
        ctx: {
            getAllComponents: (node: TSESTree$1.Program) => Map<string, ERClassComponent>;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
/**
 * Get a ctx and listeners for the rule to collect class components
 * @returns The context and listeners for the rule
 */
declare function useComponentCollectorLegacy(): useComponentCollectorLegacy.ReturnType;

declare function getFunctionComponentIdentifier(context: RuleContext, node: AST.TSESTreeFunction): TSESTree.Identifier | TSESTree.Identifier[] | _;

type ERComponentKind = "classComponent" | "functionComponent";

declare function isComponentDidMount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentWillUnmount(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isComponentDidCatch(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromError(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isGetDerivedStateFromProps(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isFunctionOfComponentDidMount(node: TSESTree.Node): boolean;
declare function isFunctionOfComponentWillUnmount(node: TSESTree.Node): boolean;
declare function isRenderMethodLike(node: TSESTree.Node): node is AST.TSESTreeMethodOrProperty;
declare function isFunctionOfRenderMethod(node: AST.TSESTreeFunction): boolean;
/**
 * Check whether given node is declared inside class component's render block
 * ```jsx
 * class Component extends React.Component {
 *   render() {
 *     class NestedClassComponent extends React.Component {
 *      render() { return <div />; }
 *     }
 *     const nestedFunctionComponent = () => <div />;
 *  }
 * }
 * ```
 * @param node The AST node being checked
 * @returns `true` if node is inside class component's render block, `false` if not
 */
declare function isInsideRenderMethod(node: TSESTree.Node): boolean;

declare const RE_COMPONENT_NAME: RegExp;
declare const RE_COMPONENT_NAME_LOOSE: RegExp;
declare function isComponentName(name: string): boolean;
declare function isComponentNameLoose(name: string): boolean;
declare function getComponentNameFromIdentifier(node: TSESTree.Identifier | TSESTree.Identifier[] | _): string | undefined;
declare function hasNoneOrLooseComponentName(context: RuleContext, node: AST.TSESTreeFunction): boolean;

type EREffectPhaseKind = "cleanup" | "setup";
type ERLifecyclePhaseKind = "mount" | "unmount";
type ERPhaseKind = EREffectPhaseKind | ERLifecyclePhaseKind;
declare const ERPhaseRelevance: birecord.BiRecord<{
    readonly mount: "unmount";
    readonly setup: "cleanup";
}>;
declare const isInversePhase: {
    (a: ERPhaseKind): (b: ERPhaseKind) => boolean;
    (a: ERPhaseKind, b: ERPhaseKind): boolean;
};

/**
 * Unsafe check whether given node is a render function
 * ```jsx
 * const renderRow = () => <div />
 * `                 ^^^^^^^^^^^^`
 * _ = <Component renderRow={() => <div />} />
 * `                         ^^^^^^^^^^^^^   `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render function, `false` if not
 */
declare function isRenderFunctionLoose(context: RuleContext, node: AST.TSESTreeFunction): boolean;
/**
 * Unsafe check whether given JSXAttribute is a render prop
 * ```jsx
 * _ = <Component renderRow={() => <div />} />
 * `              ^^^^^^^^^^^^^^^^^^^^^^^^^  `
 * ```
 * @param context The rule context
 * @param node The AST node to check
 * @returns `true` if node is a render prop, `false` if not
 */
declare function isRenderPropLoose(context: RuleContext, node: TSESTree.JSXAttribute): boolean;
/**
 * Unsafe check whether given node is declared directly inside a render property
 * ```jsx
 * const rows = { render: () => <div /> }
 * `                      ^^^^^^^^^^^^^ `
 * _ = <Component rows={ [{ render: () => <div /> }] } />
 * `                                ^^^^^^^^^^^^^       `
 *  ```
 * @internal
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render property, `false` if not
 */
declare function isDirectValueOfRenderPropertyLoose(node: TSESTree.Node): boolean;
/**
 * Unsafe check whether given node is declared inside a render prop
 * ```jsx
 * _ = <Component renderRow={"node"} />
 * `                         ^^^^^^   `
 * _ = <Component rows={ [{ render: "node" }] } />
 * `                                ^^^^^^       `
 * ```
 * @param node The AST node to check
 * @returns `true` if component is declared inside a render prop, `false` if not
 */
declare function isDeclaredInRenderPropLoose(node: TSESTree.Node): boolean;

type ERStateKind = "actionState" | "state";
declare function isThisSetState(node: TSESTree.CallExpression): boolean;
declare function isAssignmentToThisState(node: TSESTree.AssignmentExpression): boolean;

/** @internal */
declare function hasValidHierarchy(context: RuleContext, node: AST.TSESTreeFunction, hint: bigint): boolean;

/**
 * Check if a node is a React class component
 * @param node The AST node to check
 * @returns `true` if the node is a class component, `false` otherwise
 */
declare function isClassComponent(node: TSESTree.Node): node is AST.TSESTreeClass;
/**
 * Check if a node is a React PureComponent
 * @param node The AST node to check
 * @returns `true` if the node is a pure component, `false` otherwise
 */
declare function isPureComponent(node: TSESTree.Node): boolean;

/**
 * The ESQuery selector for a component display name assignment expression
 */
declare const DISPLAY_NAME_ASSIGNMENT_SELECTOR: string;

type EREffectKind = "useEffect" | "useLayoutEffect" | "useInsertionEffect";

declare function isFunctionOfUseEffectSetup(node: TSESTree.Node | _): boolean | undefined;
declare function isFunctionOfUseEffectCleanup(node: TSESTree.Node | _): boolean | undefined;

interface ERHook extends ERSemanticNode {
    id: TSESTree.Identifier | _;
    node: AST.TSESTreeFunction;
    name: string;
    hookCalls: TSESTree.CallExpression[];
}

declare namespace useHookCollector {
    type ReturnType = {
        ctx: {
            getAllHooks(node: TSESTree$1.Program): Map<string, ERHook>;
        };
        listeners: ESLintUtils.RuleListener;
    };
}
declare function useHookCollector(): useHookCollector.ReturnType;

type ERHookKind = "custom" | "useActionState" | "useCallback" | "useContext" | "useDebugValue" | "useDeferredValue" | "useEffect" | "useId" | "useImperativeHandle" | "useInsertionEffect" | "useLayoutEffect" | "useMemo" | "useOptimistic" | "useReducer" | "useRef" | "useState" | "useSyncExternalStore" | "useTransition";

declare const RE_HOOK_NAME: RegExp;
declare function isReactHookName(name: string): boolean;

declare function isReactHook(node: AST.TSESTreeFunction | _): boolean | undefined;
/**
 * Check if the given node is a React Hook call by its name.
 * @param node The node to check.
 * @returns `true` if the node is a React Hook call, `false` otherwise.
 */
declare function isReactHookCall(node: TSESTree.Node | _): boolean;
declare function isReactHookCallWithName(context: RuleContext, node: TSESTree.CallExpression | _): (name: string) => boolean;
declare function isReactHookCallWithNameLoose(node: TSESTree.CallExpression | _): (name: string) => boolean;
declare function isReactHookCallWithNameAlias(context: RuleContext, name: string, alias?: _ | string[]): (node: TSESTree.CallExpression) => boolean;
declare function isUseEffectCallLoose(node: TSESTree.Node | _): boolean;
declare const isUseCallbackCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseContextCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseDebugValueCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseDeferredValueCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseEffectCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseIdCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseImperativeHandleCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseInsertionEffectCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseLayoutEffectCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseMemoCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseReducerCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseRefCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseStateCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseSyncExternalStoreCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;
declare const isUseTransitionCall: (context: Readonly<_typescript_eslint_utils_ts_eslint.RuleContext<string, readonly unknown[]>>, node: TSESTree.CallExpression | undefined) => boolean;

interface ERSemanticEntry {
    node: TSESTree.Node;
    phase: ERPhaseKind;
}

/** @internal */
declare function getInstanceId(node: TSESTree.Node, prev?: TSESTree.Node): TSESTree.Identifier | TSESTree.ArrayExpression | TSESTree.ArrayPattern | TSESTree.ArrowFunctionExpression | TSESTree.AssignmentExpression | TSESTree.AwaitExpression | TSESTree.BinaryExpression | TSESTree.CallExpression | TSESTree.ChainExpression | TSESTree.ClassExpression | TSESTree.ConditionalExpression | TSESTree.FunctionExpression | TSESTree.ImportExpression | TSESTree.JSXElement | TSESTree.JSXFragment | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral | TSESTree.LogicalExpression | TSESTree.MemberExpressionComputedName | TSESTree.MemberExpressionNonComputedName | TSESTree.MetaProperty | TSESTree.NewExpression | TSESTree.ObjectExpression | TSESTree.ObjectPattern | TSESTree.PrivateIdentifier | TSESTree.SequenceExpression | TSESTree.Super | TSESTree.TaggedTemplateExpression | TSESTree.TemplateLiteral | TSESTree.ThisExpression | TSESTree.TSAsExpression | TSESTree.TSInstantiationExpression | TSESTree.TSNonNullExpression | TSESTree.TSSatisfiesExpression | TSESTree.TSTypeAssertion | TSESTree.UnaryExpression | TSESTree.UpdateExpression | TSESTree.YieldExpression | undefined;

/** @internal */
declare function isFromReactLoose(node: TSESTree.Node | _, name: string): boolean;
/** @internal */
declare function isFromReactStrict(node: TSESTree.Node | _, name: string, importSource: string, initialScope: Scope): boolean;
/** @internal */
declare namespace isFromReact {
    type ReturnType = {
        (context: RuleContext): (node: TSESTree.Node) => node is TSESTree.Identifier | TSESTree.MemberExpression;
        (context: RuleContext, node: TSESTree.Node): node is TSESTree.Identifier | TSESTree.MemberExpression;
    };
}
/** @internal */
declare function isFromReact(name: string): isFromReact.ReturnType;
/** @internal */
declare function isFromReactObject(objectName: string, propertyName: string): isFromReact.ReturnType;
/** @internal */
declare namespace isCallFromReact {
    type ReturnType = {
        (context: RuleContext): (node: TSESTree.Node) => node is TSESTree.CallExpression;
        (context: RuleContext, node: TSESTree.Node): node is TSESTree.CallExpression;
    };
}
/** @internal */
declare function isCallFromReact(name: string): isCallFromReact.ReturnType;
/** @internal */
declare function isCallFromReactObject(objectName: string, propertyName: string): isCallFromReact.ReturnType;

/**
 * Check if an identifier is initialized from react
 * @param name The top-level identifier's name
 * @param importSource The import source to check against
 * @param initialScope Initial scope to search for the identifier
 * @returns Whether the identifier is initialized from react
 */
declare function isInitializedFromReact(name: string, importSource: string, initialScope: Scope): boolean;

/** @internal */
declare function isInstanceIdEqual(context: RuleContext, a: TSESTree.Node, b: TSESTree.Node): boolean;

declare function isReactAPI(name: string): ReturnType<typeof isFromReact>;
declare function isReactAPI(objectName: string, propertyName: string): ReturnType<typeof isFromReactObject>;
declare function isReactAPICall(name: string): ReturnType<typeof isCallFromReact>;
declare function isReactAPICall(objectName: string, propertyName: string): ReturnType<typeof isCallFromReactObject>;
declare const isChildrenCount: isFromReact.ReturnType;
declare const isChildrenForEach: isFromReact.ReturnType;
declare const isChildrenMap: isFromReact.ReturnType;
declare const isChildrenOnly: isFromReact.ReturnType;
declare const isChildrenToArray: isFromReact.ReturnType;
declare const isCloneElement: isFromReact.ReturnType;
declare const isCreateContext: isFromReact.ReturnType;
declare const isCreateElement: isFromReact.ReturnType;
declare const isCreateRef: isFromReact.ReturnType;
declare const isForwardRef: isFromReact.ReturnType;
declare const isMemo: isFromReact.ReturnType;
declare const isChildrenCountCall: isCallFromReact.ReturnType;
declare const isChildrenForEachCall: isCallFromReact.ReturnType;
declare const isChildrenMapCall: isCallFromReact.ReturnType;
declare const isChildrenOnlyCall: isCallFromReact.ReturnType;
declare const isChildrenToArrayCall: isCallFromReact.ReturnType;
declare const isCloneElementCall: isCallFromReact.ReturnType;
declare const isCreateContextCall: isCallFromReact.ReturnType;
declare const isCreateElementCall: isCallFromReact.ReturnType;
declare const isCreateRefCall: isCallFromReact.ReturnType;
declare const isForwardRefCall: isCallFromReact.ReturnType;
declare const isMemoCall: isCallFromReact.ReturnType;

export { DEFAULT_COMPONENT_HINT, DISPLAY_NAME_ASSIGNMENT_SELECTOR, type ERClassComponent, type ERComponent, ERComponentFlag, ERComponentHint, type ERComponentKind, type EREffectKind, type EREffectPhaseKind, type ERFunctionComponent, type ERHook, type ERHookKind, type ERLifecyclePhaseKind, type ERPhaseKind, ERPhaseRelevance, type ERSemanticEntry, type ERSemanticNode, type ERStateKind, RE_COMPONENT_NAME, RE_COMPONENT_NAME_LOOSE, RE_HOOK_NAME, getComponentNameFromIdentifier, getFunctionComponentIdentifier, getInstanceId, hasNoneOrLooseComponentName, hasValidHierarchy, isAssignmentToThisState, isCallFromReact, isCallFromReactObject, isChildrenCount, isChildrenCountCall, isChildrenForEach, isChildrenForEachCall, isChildrenMap, isChildrenMapCall, isChildrenOnly, isChildrenOnlyCall, isChildrenToArray, isChildrenToArrayCall, isClassComponent, isCloneElement, isCloneElementCall, isComponentDidCatch, isComponentDidMount, isComponentName, isComponentNameLoose, isComponentWillUnmount, isCreateContext, isCreateContextCall, isCreateElement, isCreateElementCall, isCreateRef, isCreateRefCall, isDeclaredInRenderPropLoose, isDirectValueOfRenderPropertyLoose, isForwardRef, isForwardRefCall, isFromReact, isFromReactLoose, isFromReactObject, isFromReactStrict, isFunctionOfComponentDidMount, isFunctionOfComponentWillUnmount, isFunctionOfRenderMethod, isFunctionOfUseEffectCleanup, isFunctionOfUseEffectSetup, isGetDerivedStateFromError, isGetDerivedStateFromProps, isInitializedFromReact, isInsideRenderMethod, isInstanceIdEqual, isInversePhase, isMemo, isMemoCall, isPureComponent, isReactAPI, isReactAPICall, isReactHook, isReactHookCall, isReactHookCallWithName, isReactHookCallWithNameAlias, isReactHookCallWithNameLoose, isReactHookName, isRenderFunctionLoose, isRenderMethodLike, isRenderPropLoose, isThisSetState, isUseCallbackCall, isUseContextCall, isUseDebugValueCall, isUseDeferredValueCall, isUseEffectCall, isUseEffectCallLoose, isUseIdCall, isUseImperativeHandleCall, isUseInsertionEffectCall, isUseLayoutEffectCall, isUseMemoCall, isUseReducerCall, isUseRefCall, isUseStateCall, isUseSyncExternalStoreCall, isUseTransitionCall, useComponentCollector, useComponentCollectorLegacy, useHookCollector };
