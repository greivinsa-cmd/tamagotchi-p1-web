import { _ } from '@eslint-react/eff';
import { TSESTree, AST_NODE_TYPES as AST_NODE_TYPES$1 } from '@typescript-eslint/types';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import { AST_NODE_TYPES } from '@typescript-eslint/typescript-estree';

/**
 * Find the parent node that satisfies the test function
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function or `_` if not found
 */
declare function findParentNode<A extends TSESTree.Node>(node: TSESTree.Node | _, test: (n: TSESTree.Node) => n is A): A | _;
/**
 * Find the parent node that satisfies the test function or `_` if not found
 * @param node The AST node
 * @param test The test function
 * @returns The parent node that satisfies the test function
 */
declare function findParentNode(node: TSESTree.Node | _, test: (node: TSESTree.Node) => boolean): TSESTree.Node | _;

type TSESTreeFunction = TSESTree$1.ArrowFunctionExpression | TSESTree$1.FunctionDeclaration | TSESTree$1.FunctionExpression;
type TSESTreeFunctionType = TSESTree$1.TSCallSignatureDeclaration | TSESTree$1.TSConstructSignatureDeclaration | TSESTree$1.TSDeclareFunction | TSESTree$1.TSEmptyBodyFunctionExpression | TSESTree$1.TSFunctionType | TSESTree$1.TSMethodSignature | TSESTreeFunction;
type TSESTreeClass = TSESTree$1.ClassDeclaration | TSESTree$1.ClassExpression;
type TSESTreeMethodOrProperty = TSESTree$1.PropertyDefinition | TSESTree$1.MethodDefinition;
type TSESTreeLoop = TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.WhileStatement;
type TSESTreeArrayTupleType = TSESTree$1.TSArrayType | TSESTree$1.TSTupleType;
type TSESTreeProperty = TSESTree$1.PropertyDefinition | TSESTree$1.TSIndexSignature | TSESTree$1.TSParameterProperty | TSESTree$1.TSPropertySignature;
type TSESTreeJSX = TSESTree$1.JSXAttribute | TSESTree$1.JSXChild | TSESTree$1.JSXClosingElement | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXElement | TSESTree$1.JSXEmptyExpression | TSESTree$1.JSXExpression | TSESTree$1.JSXExpressionContainer | TSESTree$1.JSXFragment | TSESTree$1.JSXIdentifier | TSESTree$1.JSXIdentifierToken | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXSpreadAttribute | TSESTree$1.JSXSpreadChild | TSESTree$1.JSXTagNameExpression | TSESTree$1.JSXText | TSESTree$1.JSXTextToken;
type TSESTreeDestructuringPattern = TSESTree$1.ArrayPattern | TSESTree$1.AssignmentPattern | TSESTree$1.ObjectPattern | TSESTree$1.RestElement;
type TSESTreeTypeDeclaration = TSESTree$1.TSInterfaceDeclaration | TSESTree$1.TSTypeAliasDeclaration;
type TSESTreeTypeExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion | TSESTree$1.TSInstantiationExpression;
type TSESTreeTypeAssertionExpression = TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion;

type FunctionInitPath = 
/**
 * function Comp() { return <div />; }
 */
readonly [TSESTree.FunctionDeclaration]
/**
 * const Comp = () => <div />;
 * const Comp = function () { return <div />; };
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(() => <div />);
 * const Comp = React.forwardRef(() => <div />);
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTree.CallExpression,
    TSESTreeFunction
]
/**
 * const Comp = React.memo(React.forwardRef(() => <div />));
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTree.CallExpression,
    TSESTree.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav() { return <div />; },
 *  SidPanel: () => <div />,
 * }
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTree.ObjectExpression,
    TSESTree.Property,
    TSESTreeFunction
]
/**
 * const Comps = {
 *  TopNav: React.memo(() => <div />),
 *  SidPanel: React.forwardRef(() => <div />),
 * }
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTree.ObjectExpression,
    TSESTree.Property,
    TSESTree.CallExpression,
    TSESTreeFunction
]
/**
 * const Comps = {
 * TopNav: React.memo(React.forwardRef(() => <div />)),
 * SidPanel: React.forwardRef(React.memo(() => <div />)),
 * }
 */
 | readonly [
    TSESTree.VariableDeclaration,
    TSESTree.VariableDeclarator,
    TSESTree.ObjectExpression,
    TSESTree.Property,
    TSESTree.CallExpression,
    TSESTree.CallExpression,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav() { return <div />; }
 * }
 */
 | readonly [
    TSESTree.ClassDeclaration,
    TSESTree.ClassBody,
    TSESTree.MethodDefinition,
    TSESTreeFunction
]
/**
 * class Comp {
 *   TopNav = () => <div />;
 * }
 */
 | readonly [
    TSESTree.ClassDeclaration,
    TSESTree.ClassBody,
    TSESTree.PropertyDefinition,
    TSESTreeFunction
];
declare function getFunctionInitPath(node: TSESTreeFunction): FunctionInitPath | _;
declare function hasCallInFunctionInitPath(callName: string, initPath: FunctionInitPath): boolean;

/**
 * Gets class identifier from ClassDeclaration or ClassExpression
 * @param node The AST node to check
 * @returns class identifier or null
 */
declare function getClassIdentifier(node: TSESTreeClass): TSESTree.Identifier | _;

/**
 * Recursively get the inner expression until it's not a TypeExpression
 * @param node - The node to get the expression from
 * @returns The inner expression
 */
declare function getEcmaExpression(node: TSESTree.Node): Exclude<TSESTree.Node, TSESTreeTypeExpression>;

/**
 * Gets the static name of a function AST node. For function declarations it is
 * easy. For anonymous function expressions it is much harder. If you search for
 * `IsAnonymousFunctionDefinition()` in the ECMAScript spec you'll find places
 * where JS gives anonymous function expressions names. We roughly detect the
 * same AST nodes with some exceptions to better fit our use case.
 */

declare function getFunctionIdentifier(node: TSESTree.Expression | TSESTreeFunction): TSESTree.Identifier | _;

declare function getLiteralValueType(input: bigint | boolean | null | number | string | symbol): "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function" | "null";

/**
 * Get all nested expressions of type T in an expression like node
 * @param type The type of the expression to retrieve within the node
 * @returns A partially applied function bound to a predicate of type T. The returned function can be called passing a
 * node, and it will return an array of all nested expressions of type T.
 */
declare function getNestedExpressionsOfType<TNodeType extends AST_NODE_TYPES>(type: TNodeType): (node: TSESTree.Node) => Extract<TSESTree.Node, {
    type: TNodeType;
}>[];
/**
 * Get all nested new expressions in an expression like node
 * @param node The node to get the nested new expressions from
 * @returns All nested new expressions
 */
declare const getNestedNewExpressions: (node: TSESTree.Node) => TSESTree.NewExpression[];
/**
 * Get all nested call expressions in a expression like node
 * @param node The node to get the nested call expressions from
 * @returns All nested call expressions
 */
declare const getNestedCallExpressions: (node: TSESTree.Node) => TSESTree.CallExpression[];

/**
 * Get all nested identifiers in a expression like node
 * @param node The node to get the nested identifiers from
 * @returns All nested identifiers
 */
declare function getNestedIdentifiers(node: TSESTree.Node): readonly TSESTree.Identifier[];

/**
 * Gets the nested return statements in the node that are within the same function
 * @param node The AST node
 * @returns The nested return statements in the node
 */
declare function getNestedReturnStatements(node: TSESTree.Node): readonly TSESTree.ReturnStatement[];

declare function getPropertyName(node: TSESTree.Node): string | _;

declare function getTopLevelIdentifier(node: TSESTree.Node): TSESTree.Identifier | _;

declare const is: <NodeType extends AST_NODE_TYPES$1>(nodeType: NodeType) => (node: TSESTree$1.Node | null | undefined) => node is Extract<TSESTree$1.Node, {
    type: NodeType;
}>;
declare const isOneOf: <NodeTypes extends readonly AST_NODE_TYPES$1[]>(nodeTypes: NodeTypes) => (node: TSESTree$1.Node | null | undefined) => node is Extract<TSESTree$1.Node, {
    type: NodeTypes[number];
}>;
declare const isFunction: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ArrowFunctionExpression | TSESTree$1.FunctionDeclarationWithName | TSESTree$1.FunctionDeclarationWithOptionalName | TSESTree$1.FunctionExpression;
declare const isFunctionType: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ArrowFunctionExpression | TSESTree$1.FunctionDeclarationWithName | TSESTree$1.FunctionDeclarationWithOptionalName | TSESTree$1.FunctionExpression | TSESTree$1.TSCallSignatureDeclaration | TSESTree$1.TSConstructSignatureDeclaration | TSESTree$1.TSDeclareFunctionNoDeclare | TSESTree$1.TSDeclareFunctionWithDeclare | TSESTree$1.TSEmptyBodyFunctionExpression | TSESTree$1.TSFunctionType | TSESTree$1.TSMethodSignatureComputedName | TSESTree$1.TSMethodSignatureNonComputedName;
declare const isClass: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ClassDeclarationWithName | TSESTree$1.ClassDeclarationWithOptionalName | TSESTree$1.ClassExpression;
declare const isMethodOrProperty: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.MethodDefinitionComputedName | TSESTree$1.MethodDefinitionNonComputedName | TSESTree$1.PropertyDefinitionComputedName | TSESTree$1.PropertyDefinitionNonComputedName;
declare const isLoop: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.WhileStatement;
declare const isControlFlow: (data: TSESTree$1.Node | null | undefined) => data is TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.IfStatement | TSESTree$1.SwitchStatement | TSESTree$1.WhileStatement;
declare const isConditional: (data: TSESTree$1.Node | null | undefined) => data is TSESTree$1.ConditionalExpression | TSESTree$1.DoWhileStatement | TSESTree$1.ForInStatement | TSESTree$1.ForOfStatement | TSESTree$1.ForStatement | TSESTree$1.IfStatement | TSESTree$1.LogicalExpression | TSESTree$1.SwitchStatement | TSESTree$1.WhileStatement;
declare const isArrayTupleType: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.TSArrayType | TSESTree$1.TSTupleType;
declare const isProperty: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.PropertyDefinitionComputedName | TSESTree$1.PropertyDefinitionNonComputedName | TSESTree$1.TSIndexSignature | TSESTree$1.TSParameterProperty | TSESTree$1.TSPropertySignatureComputedName | TSESTree$1.TSPropertySignatureNonComputedName;
declare const isJSXElement: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.JSXElement;
declare const isJSXFragment: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.JSXFragment;
declare const isJSX: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.JSXAttribute | TSESTree$1.JSXClosingElement | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXElement | TSESTree$1.JSXEmptyExpression | TSESTree$1.JSXExpressionContainer | TSESTree$1.JSXFragment | TSESTree$1.JSXIdentifier | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXSpreadAttribute | TSESTree$1.JSXSpreadChild | TSESTree$1.JSXText;
declare const isJSXTagNameExpression: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.JSXIdentifier | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName;
declare const isDestructuringPattern: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ArrayPattern | TSESTree$1.AssignmentPattern | TSESTree$1.ObjectPattern | TSESTree$1.RestElement;
declare const isTypeDeclaration: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.TSInterfaceDeclaration | TSESTree$1.TSTypeAliasDeclaration;
declare const isLeftHandSideExpression: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ArrayExpression | TSESTree$1.ArrayPattern | TSESTree$1.ArrowFunctionExpression | TSESTree$1.CallExpression | TSESTree$1.ClassExpression | TSESTree$1.FunctionExpression | TSESTree$1.Identifier | TSESTree$1.JSXElement | TSESTree$1.JSXFragment | TSESTree$1.BigIntLiteral | TSESTree$1.BooleanLiteral | TSESTree$1.NullLiteral | TSESTree$1.NumberLiteral | TSESTree$1.RegExpLiteral | TSESTree$1.StringLiteral | TSESTree$1.MemberExpressionComputedName | TSESTree$1.MemberExpressionNonComputedName | TSESTree$1.MetaProperty | TSESTree$1.ObjectExpression | TSESTree$1.ObjectPattern | TSESTree$1.SequenceExpression | TSESTree$1.Super | TSESTree$1.TaggedTemplateExpression | TSESTree$1.TemplateLiteral | TSESTree$1.ThisExpression;
declare const isLeftHandSideExpressionType: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.ArrayExpression | TSESTree$1.ArrayPattern | TSESTree$1.ArrowFunctionExpression | TSESTree$1.CallExpression | TSESTree$1.ClassExpression | TSESTree$1.FunctionExpression | TSESTree$1.Identifier | TSESTree$1.JSXElement | TSESTree$1.JSXFragment | TSESTree$1.BigIntLiteral | TSESTree$1.BooleanLiteral | TSESTree$1.NullLiteral | TSESTree$1.NumberLiteral | TSESTree$1.RegExpLiteral | TSESTree$1.StringLiteral | TSESTree$1.MemberExpressionComputedName | TSESTree$1.MemberExpressionNonComputedName | TSESTree$1.MetaProperty | TSESTree$1.ObjectExpression | TSESTree$1.ObjectPattern | TSESTree$1.SequenceExpression | TSESTree$1.Super | TSESTree$1.TaggedTemplateExpression | TSESTree$1.TemplateLiteral | TSESTree$1.ThisExpression | TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSTypeAssertion;
declare const isTypeExpression: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.TSAsExpression | TSESTree$1.TSInstantiationExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion;
declare const isTypeAssertionExpression: (node: TSESTree$1.Node | null | undefined) => node is TSESTree$1.TSAsExpression | TSESTree$1.TSNonNullExpression | TSESTree$1.TSSatisfiesExpression | TSESTree$1.TSTypeAssertion;

declare function isEmptyFunction(node: TSESTreeFunction): boolean;

declare function isKindOfLiteral(node: TSESTree.Node, kind: "boolean"): node is TSESTree.BooleanLiteral;
declare function isKindOfLiteral(node: TSESTree.Node, kind: "null"): node is TSESTree.NullLiteral;
declare function isKindOfLiteral(node: TSESTree.Node, kind: "number"): node is TSESTree.NumberLiteral;
declare function isKindOfLiteral(node: TSESTree.Node, kind: "regexp"): node is TSESTree.RegExpLiteral;
declare function isKindOfLiteral(node: TSESTree.Node, kind: "string"): node is TSESTree.StringLiteral;

declare function isMapCallLoose(node: TSESTree.Node): node is TSESTree.CallExpression;

/**
 * Check if a node is multiline
 * @param node The AST node to check
 * @returns  `true` if the node is multiline
 */
declare function isMultiLine(node: TSESTree.Node): boolean;

/**
 * Determines whether node equals to another node
 * @param a node to compare
 * @param b node to compare
 * @returns `true` if node equal
 * @see https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/src/util/isNodeEqual.ts
 */
declare const isNodeEqual: {
    (a: TSESTree.Node): (b: TSESTree.Node) => boolean;
    (a: TSESTree.Node, b: TSESTree.Node): boolean;
};

declare function isThisExpression(node: TSESTree.Expression): boolean;

/**
 * Returns human readable node name for given AST node
 * @param node AST node
 * @param getText A function that returns the text of the node in the source code
 * @returns Human readable node name
 */
declare function toReadableNodeName(node: TSESTree.Node, getText: (node: TSESTree.Node) => string): string;

/**
 * Returns human readable node type for given AST node
 * @param node AST node
 * @returns Human readable node type
 */
declare function toReadableNodeType(node: TSESTree.Node): "property" | "RegExp literal" | "string literal" | "number literal" | "bigint literal" | "boolean literal" | "symbol literal" | "undefined literal" | "object literal" | "function literal" | "null literal" | "identifier" | "member expression" | "JSX attribute" | "JSX element" | "JSX fragment" | "JSX identifier" | "JSX text" | "JSX closing element" | "JSX closing fragment" | "JSX empty expression" | "JSX expression container" | "JSX member expression" | "JSX namespaced name" | "JSX opening element" | "JSX opening fragment" | "JSX spread attribute" | "JSX spread child" | "decorator" | "program" | "super" | "accessor property" | "array expression" | "array pattern" | "function expression" | "arrow function expression" | "assignment expression" | "assignment pattern" | "await expression" | "binary expression" | "block statement" | "break statement" | "call expression" | "catch clause" | "chain expression" | "class body" | "class declaration" | "class expression" | "conditional expression" | "continue statement" | "debugger statement" | "while statement" | "do while statement" | "empty statement" | "export all declaration" | "export default declaration" | "export named declaration" | "export specifier" | "expression statement" | "for in statement" | "for of statement" | "for statement" | "function declaration" | "if statement" | "import attribute" | "import declaration" | "import default specifier" | "import expression" | "import namespace specifier" | "import specifier" | "labeled statement" | "logical expression" | "meta property" | "method definition" | "new expression" | "object expression" | "object pattern" | "private identifier" | "property definition" | "rest element" | "return statement" | "sequence expression" | "spread element" | "static block" | "switch case" | "switch statement" | "tagged template expression" | "template element" | "template literal" | "this expression" | "throw statement" | "try statement" | "unary expression" | "update expression" | "variable declaration" | "variable declarator" | "with statement" | "yield expression" | "ts abstract accessor property" | "ts abstract keyword" | "ts abstract method definition" | "ts abstract property definition" | "ts any keyword" | "ts array type" | "ts as expression" | "ts async keyword" | "ts big int keyword" | "ts boolean keyword" | "ts call signature declaration" | "ts class implements" | "ts conditional type" | "ts constructor type" | "ts construct signature declaration" | "ts declare function" | "ts declare keyword" | "ts empty body function expression" | "ts enum body" | "ts enum declaration" | "ts enum member" | "ts export assignment" | "ts export keyword" | "ts external module reference" | "ts function type" | "ts import equals declaration" | "ts import type" | "ts indexed access type" | "ts index signature" | "ts infer type" | "ts instantiation expression" | "ts interface body" | "ts interface declaration" | "ts interface heritage" | "ts intersection type" | "ts intrinsic keyword" | "ts literal type" | "ts mapped type" | "ts method signature" | "ts module block" | "ts module declaration" | "ts named tuple member" | "ts namespace export declaration" | "ts never keyword" | "ts non null expression" | "ts null keyword" | "ts number keyword" | "ts object keyword" | "ts optional type" | "ts parameter property" | "ts private keyword" | "ts property signature" | "ts protected keyword" | "ts public keyword" | "ts qualified name" | "ts readonly keyword" | "ts rest type" | "ts satisfies expression" | "ts static keyword" | "ts string keyword" | "ts symbol keyword" | "ts template literal type" | "ts this type" | "ts tuple type" | "ts type alias declaration" | "ts type annotation" | "ts type assertion" | "ts type literal" | "ts type operator" | "ts type parameter" | "ts type parameter declaration" | "ts type parameter instantiation" | "ts type predicate" | "ts type query" | "ts type reference" | "ts undefined keyword" | "ts union type" | "ts unknown keyword" | "ts void keyword";
type ReadableNodeType = ReturnType<typeof toReadableNodeType>;

export { type FunctionInitPath, type ReadableNodeType, type TSESTreeArrayTupleType, type TSESTreeClass, type TSESTreeDestructuringPattern, type TSESTreeFunction, type TSESTreeFunctionType, type TSESTreeJSX, type TSESTreeLoop, type TSESTreeMethodOrProperty, type TSESTreeProperty, type TSESTreeTypeAssertionExpression, type TSESTreeTypeDeclaration, type TSESTreeTypeExpression, findParentNode, getClassIdentifier, getEcmaExpression, getFunctionIdentifier, getFunctionInitPath, getLiteralValueType, getNestedCallExpressions, getNestedExpressionsOfType, getNestedIdentifiers, getNestedNewExpressions, getNestedReturnStatements, getPropertyName, getTopLevelIdentifier, hasCallInFunctionInitPath, is, isArrayTupleType, isClass, isConditional, isControlFlow, isDestructuringPattern, isEmptyFunction, isFunction, isFunctionType, isJSX, isJSXElement, isJSXFragment, isJSXTagNameExpression, isKindOfLiteral, isLeftHandSideExpression, isLeftHandSideExpressionType, isLoop, isMapCallLoose, isMethodOrProperty, isMultiLine, isNodeEqual, isOneOf, isProperty, isThisExpression, isTypeAssertionExpression, isTypeDeclaration, isTypeExpression, toReadableNodeName, toReadableNodeType };
