import { ESLintUtils } from '@typescript-eslint/utils';
import module from 'node:module';
import { identity } from '@eslint-react/eff';
import { match, P } from 'ts-pattern';
import pm from 'picomatch';

// src/constants.ts
var NPM_SCOPE = "@eslint-react";
var GITHUB_URL = "https://github.com/Rel1cx/eslint-react";
var WEBSITE_URL = "https://eslint-react.xyz";
var RE_PASCAL_CASE = /^[A-Z][\dA-Za-z]*$/u;
var RE_CAMEL_CASE = /^[a-z][\dA-Za-z]*$/u;
var RE_KEBAB_CASE = /^[a-z][\d\-a-z]*$/u;
var RE_SNAKE_CASE = /^[a-z][\d_a-z]*$/u;
var RE_CONSTANT_CASE = /^[A-Z][\d_A-Z]*$/u;
var RE_JAVASCRIPT_PROTOCOL = /^[\u0000-\u001F ]*j[\t\n\r]*a[\t\n\r]*v[\t\n\r]*a[\t\n\r]*s[\t\n\r]*c[\t\n\r]*r[\t\n\r]*i[\t\n\r]*p[\t\n\r]*t[\t\n\r]*:/iu;
var REACT_BUILD_IN_HOOKS = [
  "use",
  "useActionState",
  "useCallback",
  "useContext",
  "useDebugValue",
  "useDeferredValue",
  "useEffect",
  "useFormStatus",
  "useId",
  "useImperativeHandle",
  "useInsertionEffect",
  "useLayoutEffect",
  "useMemo",
  "useOptimistic",
  "useReducer",
  "useRef",
  "useState",
  "useSyncExternalStore",
  "useTransition"
];
var getDocsUrl = (pluginName) => (ruleName) => {
  if (pluginName === "x") {
    return `${WEBSITE_URL}/docs/rules/${ruleName}`;
  }
  return `${WEBSITE_URL}/docs/rules/${pluginName}-${ruleName}`;
};
var createRuleForPlugin = (pluginName) => ESLintUtils.RuleCreator(getDocsUrl(pluginName));

// src/env.ts
function isInEditorEnv() {
  if (process.env["CI"]) {
    return false;
  }
  if (isInGitHooksOrLintStaged()) {
    return false;
  }
  return !!(process.env["VSCODE_PID"] || process.env["VSCODE_CWD"] || process.env["JETBRAINS_IDE"] || process.env["VIM"] || process.env["NVIM"]);
}
function isInGitHooksOrLintStaged() {
  return !!(process.env["GIT_PARAMS"] || process.env["VSCODE_GIT_COMMAND"] || process.env["npm_lifecycle_script"]?.startsWith("lint-staged"));
}

// src/get-id.ts
var id = 0n;
var getId = () => (id++).toString();
var _require = module.createRequire(import.meta.url);
function getReactVersion(fallback = "19.0.0") {
  try {
    return match(_require("react")).with({ version: P.select(P.string) }, identity).otherwise(() => fallback);
  } catch {
    return fallback;
  }
}

// ../../node_modules/.pnpm/valibot@1.0.0-rc.4_typescript@5.8.2/node_modules/valibot/dist/index.js
var store;
// @__NO_SIDE_EFFECTS__
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}
var store2;
// @__NO_SIDE_EFFECTS__
function getGlobalMessage(lang) {
  return store2?.get(lang);
}
var store3;
// @__NO_SIDE_EFFECTS__
function getSchemaMessage(lang) {
  return store3?.get(lang);
}
var store4;
// @__NO_SIDE_EFFECTS__
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}
// @__NO_SIDE_EFFECTS__
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? /* @__PURE__ */ _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config2.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);
  if (message !== void 0) {
    issue.message = typeof message === "function" ? (
      // @ts-expect-error
      message(issue)
    ) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}
// @__NO_SIDE_EFFECTS__
function _getStandardProps(context) {
  return {
    version: 1,
    vendor: "valibot",
    validate(value2) {
      return context["~run"]({ value: value2 }, /* @__PURE__ */ getGlobalConfig());
    }
  };
}
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};
// @__NO_SIDE_EFFECTS__
function getFallback(schema, dataset, config2) {
  return typeof schema.fallback === "function" ? (
    // @ts-expect-error
    schema.fallback(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.fallback
  );
}
// @__NO_SIDE_EFFECTS__
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}
// @__NO_SIDE_EFFECTS__
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item["~run"]({ value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const valueSchema = this.entries[key];
          if (key in input || (valueSchema.type === "exact_optional" || valueSchema.type === "optional" || valueSchema.type === "nullish") && // @ts-expect-error
          valueSchema.default !== void 0) {
            const value2 = key in input ? (
              // @ts-expect-error
              input[key]
            ) : /* @__PURE__ */ getDefault(valueSchema);
            const valueDataset = valueSchema["~run"]({ value: value2 }, config2);
            if (valueDataset.issues) {
              const pathItem = {
                type: "object",
                origin: "value",
                input,
                key,
                value: value2
              };
              for (const issue of valueDataset.issues) {
                if (issue.path) {
                  issue.path.unshift(pathItem);
                } else {
                  issue.path = [pathItem];
                }
                dataset.issues?.push(issue);
              }
              if (!dataset.issues) {
                dataset.issues = valueDataset.issues;
              }
              if (config2.abortEarly) {
                dataset.typed = false;
                break;
              }
            }
            if (!valueDataset.typed) {
              dataset.typed = false;
            }
            dataset.value[key] = valueDataset.value;
          } else if (valueSchema.fallback !== void 0) {
            dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);
          } else if (valueSchema.type !== "exact_optional" && valueSchema.type !== "optional" && valueSchema.type !== "nullish") {
            _addIssue(this, "key", dataset, config2, {
              input: void 0,
              expected: `"${key}"`,
              path: [
                {
                  type: "object",
                  origin: "key",
                  input,
                  key,
                  // @ts-expect-error
                  value: input[key]
                }
              ]
            });
            if (config2.abortEarly) {
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
// @__NO_SIDE_EFFECTS__
function optional(wrapped, default_) {
  return {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    default: default_,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (dataset.value === void 0) {
        if (this.default !== void 0) {
          dataset.value = /* @__PURE__ */ getDefault(this, dataset, config2);
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped["~run"](dataset, config2);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    get "~standard"() {
      return /* @__PURE__ */ _getStandardProps(this);
    },
    "~run"(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}
function parse(schema, input, config2) {
  const dataset = schema["~run"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config2));
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// src/schemas.ts
var CustomComponentPropSchema = object({
  /**
   * The name of the prop in the user-defined component.
   * @example
   * "to"
   */
  name: string(),
  /**
   * The name of the prop in the built-in component.
   * @example
   * "href"
   */
  as: optional(string()),
  /**
   * Whether the prop is controlled or not in the user-defined component.
   * @internal
   * @example
   * `true`
   */
  controlled: optional(boolean()),
  /**
   * The default value of the prop in the user-defined component.
   * @example
   * `"/"`
   */
  defaultValue: optional(string())
});
var CustomComponentSchema = object({
  /**
   * The name of the user-defined component.
   * @example
   * "Link"
   */
  name: string(),
  /**
   * The name of the built-in component that the user-defined component represents.
   * @example
   * "a"
   */
  as: optional(string()),
  /**
   * Attributes mapping between the user-defined component and the built-in component.
   * @example
   * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
   */
  attributes: optional(array(CustomComponentPropSchema)),
  /**
   * The ESQuery selector to select the component precisely.
   * @internal
   * @example
   * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
   */
  selector: optional(string())
});
var CustomHooksSchema = object({
  use: optional(array(string())),
  useActionState: optional(array(string())),
  useCallback: optional(array(string())),
  useContext: optional(array(string())),
  useDebugValue: optional(array(string())),
  useDeferredValue: optional(array(string())),
  useEffect: optional(array(string())),
  useFormStatus: optional(array(string())),
  useId: optional(array(string())),
  useImperativeHandle: optional(array(string())),
  useInsertionEffect: optional(array(string())),
  useLayoutEffect: optional(array(string())),
  useMemo: optional(array(string())),
  useOptimistic: optional(array(string())),
  useReducer: optional(array(string())),
  useRef: optional(array(string())),
  useState: optional(array(string())),
  useSyncExternalStore: optional(array(string())),
  useTransition: optional(array(string()))
});
var ESLintReactSettingsSchema = object({
  /**
   * The source where React is imported from.
   * @description This allows to specify a custom import location for React when not using the official distribution.
   * @default `"react"`
   * @example `"@pika/react"`
   */
  importSource: optional(string()),
  /**
   * The identifier that's used for JSX Element creation.
   * @default `"createElement"`
   * @deprecated
   */
  jsxPragma: optional(string()),
  /**
   * The identifier that's used for JSX fragment elements.
   * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
   * @default `"Fragment"`
   * @deprecated
   */
  jsxPragmaFrag: optional(string()),
  /**
   * The name of the prop that is used for polymorphic components.
   * @description This is used to determine the type of the component.
   * @example `"as"`
   */
  polymorphicPropName: optional(string()),
  /**
   * @internal
   */
  strict: optional(boolean(), false),
  /**
   * Check both the shape and the import to determine if an API is from React.
   * @description This can prevent false positives when using a irrelevant third-party library that has similar APIs to React.
   * @default `true`
   */
  skipImportCheck: optional(boolean(), true),
  /**
   * React version to use, "detect" means auto detect React version from the project's dependencies.
   * If `importSource` is specified, an equivalent version of React should be provided here.
   * @example `"18.3.1"`
   * @default `"detect"`
   */
  version: optional(string()),
  /**
   * A object to define additional hooks that are equivalent to the built-in React Hooks.
   * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
   * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
   */
  additionalHooks: optional(CustomHooksSchema),
  /**
   * An array of user-defined components
   * @description This is used to inform the ESLint React plugins how to treat these components during checks.
   * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
   */
  additionalComponents: optional(array(CustomComponentSchema))
});
var ESLintSettingsSchema = optional(
  object({
    "react-x": optional(ESLintReactSettingsSchema),
    /** @deprecated Use `react-x` instead */
    reactOptions: optional(ESLintReactSettingsSchema)
  }),
  {}
);
var DEFAULT_ESLINT_REACT_SETTINGS = {
  ...parse(ESLintReactSettingsSchema, {}),
  importSource: "react",
  polymorphicPropName: "as",
  skipImportCheck: true,
  version: "detect",
  additionalHooks: {
    useEffect: ["useIsomorphicLayoutEffect"],
    useLayoutEffect: ["useIsomorphicLayoutEffect"]
  }
};

// ../../node_modules/.pnpm/fast-equals@5.2.2/node_modules/fast-equals/dist/esm/index.mjs
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    var cache = state.cache;
    var cachedA = cache.get(a);
    var cachedB = cache.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache.set(a, b);
    cache.set(b, a);
    var result = areItemsEqual(a, b, state);
    cache.delete(a);
    cache.delete(b);
    return result;
  };
}
function getStrictProperties(object2) {
  return getOwnPropertyNames(object2).concat(getOwnPropertySymbols(object2));
}
var hasOwn = Object.hasOwn || function(object2, property) {
  return hasOwnProperty.call(object2, property);
};
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var keys = Object.keys;
function areArraysEqual(a, b, state) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.entries();
  var aResult;
  var bResult;
  var index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.entries();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      var aEntry = aResult.value;
      var bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  var properties = keys(a);
  var index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  var properties = getStrictProperties(a);
  var index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  var property;
  var descriptorA;
  var descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  var size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  var matchedIndices = new Array(size);
  var aIterable = a.values();
  var aResult;
  var bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    var bIterable = b.values();
    var hasMatch = false;
    var matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var URL_TAG = "[object URL]";
var isArray = Array.isArray;
var isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null;
var assign = Object.assign;
var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areErrorsEqual2 = _a.areErrorsEqual, areFunctionsEqual2 = _a.areFunctionsEqual, areMapsEqual2 = _a.areMapsEqual, areNumbersEqual2 = _a.areNumbersEqual, areObjectsEqual2 = _a.areObjectsEqual, arePrimitiveWrappersEqual2 = _a.arePrimitiveWrappersEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, areTypedArraysEqual2 = _a.areTypedArraysEqual, areUrlsEqual2 = _a.areUrlsEqual;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    var type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    var constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (isTypedArray != null && isTypedArray(a)) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    var tag = getTag(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig(_a) {
  var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;
  var config = {
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,
    areUrlsEqual
  };
  if (createCustomConfig) {
    config = assign({}, config, createCustomConfig(config));
  }
  if (circular) {
    var areArraysEqual$1 = createIsCircular(config.areArraysEqual);
    var areMapsEqual$1 = createIsCircular(config.areMapsEqual);
    var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);
    var areSetsEqual$1 = createIsCircular(config.areSetsEqual);
    config = assign({}, config, {
      areArraysEqual: areArraysEqual$1,
      areMapsEqual: areMapsEqual$1,
      areObjectsEqual: areObjectsEqual$1,
      areSetsEqual: areSetsEqual$1
    });
  }
  return config;
}
function createInternalEqualityComparator(compare) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a, b, state);
  };
}
function createIsEqual(_a) {
  var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;
  if (createState) {
    return function isEqual(a, b) {
      var _a2 = createState(), _b = _a2.cache, cache = _b === void 0 ? circular ? /* @__PURE__ */ new WeakMap() : void 0 : _b, meta = _a2.meta;
      return comparator(a, b, {
        cache,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  var state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
createCustomEqual();
createCustomEqual({ strict: true });
createCustomEqual({ circular: true });
createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: true,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: true
});
function createCustomEqual(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;
  var config = createEqualityComparatorConfig(options);
  var comparator = createEqualityComparator(config);
  var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// ../../node_modules/.pnpm/micro-memoize@4.1.3/node_modules/micro-memoize/dist/micro-memoize.esm.js
var DEFAULT_OPTIONS_KEYS = {
  isEqual: true,
  isMatchingKey: true,
  isPromise: true,
  maxSize: true,
  onCacheAdd: true,
  onCacheChange: true,
  onCacheHit: true,
  transformKey: true
};
var slice = Array.prototype.slice;
function cloneArray(arrayLike) {
  var length = arrayLike.length;
  if (!length) {
    return [];
  }
  if (length === 1) {
    return [arrayLike[0]];
  }
  if (length === 2) {
    return [arrayLike[0], arrayLike[1]];
  }
  if (length === 3) {
    return [arrayLike[0], arrayLike[1], arrayLike[2]];
  }
  return slice.call(arrayLike, 0);
}
function getCustomOptions(options) {
  var customOptions = {};
  for (var key in options) {
    if (!DEFAULT_OPTIONS_KEYS[key]) {
      customOptions[key] = options[key];
    }
  }
  return customOptions;
}
function isMemoized(fn) {
  return typeof fn === "function" && fn.isMemoized;
}
function isSameValueZero(object1, object2) {
  return object1 === object2 || object1 !== object1 && object2 !== object2;
}
function mergeOptions(existingOptions, newOptions) {
  var target = {};
  for (var key in existingOptions) {
    target[key] = existingOptions[key];
  }
  for (var key in newOptions) {
    target[key] = newOptions[key];
  }
  return target;
}
var Cache = (
  /** @class */
  function() {
    function Cache2(options) {
      this.keys = [];
      this.values = [];
      this.options = options;
      var isMatchingKeyFunction = typeof options.isMatchingKey === "function";
      if (isMatchingKeyFunction) {
        this.getKeyIndex = this._getKeyIndexFromMatchingKey;
      } else if (options.maxSize > 1) {
        this.getKeyIndex = this._getKeyIndexForMany;
      } else {
        this.getKeyIndex = this._getKeyIndexForSingle;
      }
      this.canTransformKey = typeof options.transformKey === "function";
      this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
      this.shouldUpdateOnAdd = typeof options.onCacheAdd === "function";
      this.shouldUpdateOnChange = typeof options.onCacheChange === "function";
      this.shouldUpdateOnHit = typeof options.onCacheHit === "function";
    }
    Object.defineProperty(Cache2.prototype, "size", {
      /**
       * The number of cached [key,value] results.
       */
      get: function() {
        return this.keys.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Cache2.prototype, "snapshot", {
      /**
       * A copy of the cache at a moment in time. This is useful
       * to compare changes over time, since the cache mutates
       * internally for performance reasons.
       */
      get: function() {
        return {
          keys: cloneArray(this.keys),
          size: this.size,
          values: cloneArray(this.values)
        };
      },
      enumerable: false,
      configurable: true
    });
    Cache2.prototype._getKeyIndexFromMatchingKey = function(keyToMatch) {
      var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
      var keys2 = this.keys;
      var keysLength = keys2.length;
      if (!keysLength) {
        return -1;
      }
      if (isMatchingKey(keys2[0], keyToMatch)) {
        return 0;
      }
      if (maxSize > 1) {
        for (var index = 1; index < keysLength; index++) {
          if (isMatchingKey(keys2[index], keyToMatch)) {
            return index;
          }
        }
      }
      return -1;
    };
    Cache2.prototype._getKeyIndexForMany = function(keyToMatch) {
      var isEqual = this.options.isEqual;
      var keys2 = this.keys;
      var keysLength = keys2.length;
      if (!keysLength) {
        return -1;
      }
      if (keysLength === 1) {
        return this._getKeyIndexForSingle(keyToMatch);
      }
      var keyLength = keyToMatch.length;
      var existingKey;
      var argIndex;
      if (keyLength > 1) {
        for (var index = 0; index < keysLength; index++) {
          existingKey = keys2[index];
          if (existingKey.length === keyLength) {
            argIndex = 0;
            for (; argIndex < keyLength; argIndex++) {
              if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                break;
              }
            }
            if (argIndex === keyLength) {
              return index;
            }
          }
        }
      } else {
        for (var index = 0; index < keysLength; index++) {
          existingKey = keys2[index];
          if (existingKey.length === keyLength && isEqual(existingKey[0], keyToMatch[0])) {
            return index;
          }
        }
      }
      return -1;
    };
    Cache2.prototype._getKeyIndexForSingle = function(keyToMatch) {
      var keys2 = this.keys;
      if (!keys2.length) {
        return -1;
      }
      var existingKey = keys2[0];
      var length = existingKey.length;
      if (keyToMatch.length !== length) {
        return -1;
      }
      var isEqual = this.options.isEqual;
      if (length > 1) {
        for (var index = 0; index < length; index++) {
          if (!isEqual(existingKey[index], keyToMatch[index])) {
            return -1;
          }
        }
        return 0;
      }
      return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
    };
    Cache2.prototype.orderByLru = function(key, value, startingIndex) {
      var keys2 = this.keys;
      var values = this.values;
      var currentLength = keys2.length;
      var index = startingIndex;
      while (index--) {
        keys2[index + 1] = keys2[index];
        values[index + 1] = values[index];
      }
      keys2[0] = key;
      values[0] = value;
      var maxSize = this.options.maxSize;
      if (currentLength === maxSize && startingIndex === currentLength) {
        keys2.pop();
        values.pop();
      } else if (startingIndex >= maxSize) {
        keys2.length = values.length = maxSize;
      }
    };
    Cache2.prototype.updateAsyncCache = function(memoized) {
      var _this = this;
      var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
      var firstKey = this.keys[0];
      var firstValue = this.values[0];
      this.values[0] = firstValue.then(function(value) {
        if (_this.shouldUpdateOnHit) {
          onCacheHit(_this, _this.options, memoized);
        }
        if (_this.shouldUpdateOnChange) {
          onCacheChange(_this, _this.options, memoized);
        }
        return value;
      }, function(error) {
        var keyIndex = _this.getKeyIndex(firstKey);
        if (keyIndex !== -1) {
          _this.keys.splice(keyIndex, 1);
          _this.values.splice(keyIndex, 1);
        }
        throw error;
      });
    };
    return Cache2;
  }()
);
function createMemoizedFunction(fn, options) {
  if (options === void 0) {
    options = {};
  }
  if (isMemoized(fn)) {
    return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));
  }
  if (typeof fn !== "function") {
    throw new TypeError("You must pass a function to `memoize`.");
  }
  var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
  var normalizedOptions = mergeOptions({
    isEqual,
    isMatchingKey,
    isPromise,
    maxSize,
    onCacheAdd,
    onCacheChange,
    onCacheHit,
    transformKey
  }, getCustomOptions(options));
  var cache = new Cache(normalizedOptions);
  var keys2 = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
  var memoized = function() {
    var key = shouldCloneArguments ? cloneArray(arguments) : arguments;
    if (canTransformKey) {
      key = transformKey(key);
    }
    var keyIndex = keys2.length ? cache.getKeyIndex(key) : -1;
    if (keyIndex !== -1) {
      if (shouldUpdateOnHit) {
        onCacheHit(cache, normalizedOptions, memoized);
      }
      if (keyIndex) {
        cache.orderByLru(keys2[keyIndex], values[keyIndex], keyIndex);
        if (shouldUpdateOnChange) {
          onCacheChange(cache, normalizedOptions, memoized);
        }
      }
    } else {
      var newValue = fn.apply(this, arguments);
      var newKey = shouldCloneArguments ? key : cloneArray(arguments);
      cache.orderByLru(newKey, newValue, keys2.length);
      if (isPromise) {
        cache.updateAsyncCache(memoized);
      }
      if (shouldUpdateOnAdd) {
        onCacheAdd(cache, normalizedOptions, memoized);
      }
      if (shouldUpdateOnChange) {
        onCacheChange(cache, normalizedOptions, memoized);
      }
    }
    return values[0];
  };
  memoized.cache = cache;
  memoized.fn = fn;
  memoized.isMemoized = true;
  memoized.options = normalizedOptions;
  return memoized;
}
function unsafeDecodeSettings(data) {
  return data?.["react-x"] ?? {};
}
var decodeSettings = createMemoizedFunction((data) => {
  return {
    ...DEFAULT_ESLINT_REACT_SETTINGS,
    ...parse(ESLintSettingsSchema, data)["react-x"] ?? {}
  };
}, { isEqual: (a, b) => a === b });
var toNormalizedSettings = createMemoizedFunction(
  ({
    additionalComponents = [],
    additionalHooks = {},
    importSource = "react",
    polymorphicPropName = "as",
    skipImportCheck = true,
    version,
    ...rest
  }) => {
    return {
      ...rest,
      additionalComponents: additionalComponents.map(({
        name,
        as = name,
        attributes = [],
        ...rest2
      }) => ({
        ...rest2,
        name,
        as,
        attributes: attributes.map(({ name: name2, as: as2 = name2, ...rest3 }) => ({
          ...rest3,
          name: name2,
          as: as2
        })),
        re: pm.makeRe(name, { fastpaths: true })
      })),
      additionalHooks,
      importSource,
      polymorphicPropName,
      skipImportCheck,
      version: match(version).with(P.union(P.nullish, "", "detect"), () => getReactVersion("19.0.0")).otherwise(identity)
    };
  },
  { isEqual: shallowEqual }
);
function getSettingsFromContext(context) {
  return toNormalizedSettings(decodeSettings(context.settings));
}
var defineSettings = identity;

export { CustomComponentPropSchema, CustomComponentSchema, CustomHooksSchema, DEFAULT_ESLINT_REACT_SETTINGS, ESLintReactSettingsSchema, ESLintSettingsSchema, GITHUB_URL, NPM_SCOPE, REACT_BUILD_IN_HOOKS, RE_CAMEL_CASE, RE_CONSTANT_CASE, RE_JAVASCRIPT_PROTOCOL, RE_KEBAB_CASE, RE_PASCAL_CASE, RE_SNAKE_CASE, WEBSITE_URL, createRuleForPlugin, decodeSettings, defineSettings, getId, getReactVersion, getSettingsFromContext, isInEditorEnv, isInGitHooksOrLintStaged, toNormalizedSettings, unsafeDecodeSettings };
