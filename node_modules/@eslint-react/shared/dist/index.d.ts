import { ESLintUtils } from '@typescript-eslint/utils';
import { _ } from '@eslint-react/eff';

/**
 * The NPM scope for this project.
 */
declare const NPM_SCOPE = "@eslint-react";
/**
 * The GitHub repository for this project.
 */
declare const GITHUB_URL = "https://github.com/Rel1cx/eslint-react";
/**
 * The URL to the project's website.
 */
declare const WEBSITE_URL = "https://eslint-react.xyz";
/**
 * Regular expression for matching a PascalCase string.
 */
declare const RE_PASCAL_CASE: RegExp;
/**
 * Regular expression for matching a camelCase string.
 */
declare const RE_CAMEL_CASE: RegExp;
/**
 * Regular expression for matching a kebab-case string.
 */
declare const RE_KEBAB_CASE: RegExp;
/**
 * Regular expression for matching a snake_case string.
 */
declare const RE_SNAKE_CASE: RegExp;
/**
 * Regular expression for matching a CONSTANT_CASE string.
 */
declare const RE_CONSTANT_CASE: RegExp;
declare const RE_JAVASCRIPT_PROTOCOL: RegExp;
declare const REACT_BUILD_IN_HOOKS: readonly ["use", "useActionState", "useCallback", "useContext", "useDebugValue", "useDeferredValue", "useEffect", "useFormStatus", "useId", "useImperativeHandle", "useInsertionEffect", "useLayoutEffect", "useMemo", "useOptimistic", "useReducer", "useRef", "useState", "useSyncExternalStore", "useTransition"];

/**
 * Get the ESLint rule creator for a plugin.
 * @internal
 * @param pluginName The name of the plugin.
 * @returns The ESLint rule creator.
 */
declare const createRuleForPlugin: (pluginName: string) => <Options extends readonly unknown[], MessageIds extends string>({ meta, name, ...rule }: Readonly<ESLintUtils.RuleWithMetaAndName<Options, MessageIds, unknown>>) => ESLintUtils.RuleModule<MessageIds, Options, unknown, ESLintUtils.RuleListener>;

declare function isInEditorEnv(): boolean;
declare function isInGitHooksOrLintStaged(): boolean;

declare const getId: () => string;

declare function getReactVersion(fallback?: string): string;

/**
 * Fallback type.
 */
type Fallback<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>> = MaybeReadonly<InferOutput<TSchema>> | ((dataset?: OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>, config?: Config<InferIssue<TSchema>>) => MaybeReadonly<InferOutput<TSchema>>);
/**
 * Schema with fallback type.
 */
type SchemaWithFallback<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TFallback extends Fallback<TSchema>> = TSchema & {
    /**
     * The fallback value.
     */
    readonly fallback: TFallback;
};

/**
 * Fallback async type.
 */
type FallbackAsync<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>> = MaybeReadonly<InferOutput<TSchema>> | ((dataset?: OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>, config?: Config<InferIssue<TSchema>>) => MaybePromise<MaybeReadonly<InferOutput<TSchema>>>);
/**
 * Schema with fallback async type.
 */
type SchemaWithFallbackAsync<TSchema extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TFallback extends FallbackAsync<TSchema>> = Omit<TSchema, 'async' | '~standard' | '~run'> & {
    /**
     * The fallback value.
     */
    readonly fallback: TFallback;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<TSchema>, InferOutput<TSchema>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<InferOutput<TSchema>, InferIssue<TSchema>>>;
};

/**
 * Schema with pipe type.
 */
type SchemaWithPipe<TPipe extends readonly [
    BaseSchema<unknown, unknown, BaseIssue<unknown>>,
    ...PipeItem<any, unknown, BaseIssue<unknown>>[]
]> = Omit<FirstTupleItem<TPipe>, '~standard' | '~run' | '~types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<FirstTupleItem<TPipe>>, InferOutput<LastTupleItem<TPipe>>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => OutputDataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    } | undefined;
};

/**
 * Schema with pipe async type.
 */
type SchemaWithPipeAsync<TPipe extends readonly [
    (BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>),
    ...(PipeItem<any, unknown, BaseIssue<unknown>> | PipeItemAsync<any, unknown, BaseIssue<unknown>>)[]
]> = Omit<FirstTupleItem<TPipe>, 'async' | '~standard' | '~run' | '~types'> & {
    /**
     * The pipe items.
     */
    readonly pipe: TPipe;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<InferInput<FirstTupleItem<TPipe>>, InferOutput<LastTupleItem<TPipe>>>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<InferOutput<LastTupleItem<TPipe>>, InferIssue<TPipe[number]>>>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: InferInput<FirstTupleItem<TPipe>>;
        readonly output: InferOutput<LastTupleItem<TPipe>>;
        readonly issue: InferIssue<TPipe[number]>;
    } | undefined;
};

/**
 * Base metadata interface.
 */
interface BaseMetadata<TInput> {
    /**
     * The object kind.
     */
    readonly kind: 'metadata';
    /**
     * The metadata type.
     */
    readonly type: string;
    /**
     * The metadata reference.
     */
    readonly reference: (...args: any[]) => BaseMetadata<any>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TInput;
        readonly issue: never;
    } | undefined;
}

/**
 * Unknown dataset interface.
 */
interface UnknownDataset {
    /**
     * Whether is's typed.
     */
    typed?: false;
    /**
     * The dataset value.
     */
    value: unknown;
    /**
     * The dataset issues.
     */
    issues?: undefined;
}
/**
 * Success dataset interface.
 */
interface SuccessDataset<TValue> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The dataset value.
     */
    value: TValue;
    /**
     * The dataset issues.
     */
    issues?: undefined;
}
/**
 * Partial dataset interface.
 */
interface PartialDataset<TValue, TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: true;
    /**
     * The dataset value.
     */
    value: TValue;
    /**
     * The dataset issues.
     */
    issues: [TIssue, ...TIssue[]];
}
/**
 * Failure dataset interface.
 */
interface FailureDataset<TIssue extends BaseIssue<unknown>> {
    /**
     * Whether is's typed.
     */
    typed: false;
    /**
     * The dataset value.
     */
    value: unknown;
    /**
     * The dataset issues.
     */
    issues: [TIssue, ...TIssue[]];
}
/**
 * Output dataset type.
 */
type OutputDataset<TValue, TIssue extends BaseIssue<unknown>> = SuccessDataset<TValue> | PartialDataset<TValue, TIssue> | FailureDataset<TIssue>;

/**
 * The Standard Schema properties interface.
 */
interface StandardProps<TInput, TOutput> {
    /**
     * The version number of the standard.
     */
    readonly version: 1;
    /**
     * The vendor name of the schema library.
     */
    readonly vendor: 'valibot';
    /**
     * Validates unknown input values.
     */
    readonly validate: (value: unknown) => StandardResult<TOutput> | Promise<StandardResult<TOutput>>;
    /**
     * Inferred types associated with the schema.
     */
    readonly types?: StandardTypes<TInput, TOutput> | undefined;
}
/**
 * The result interface of the validate function.
 */
type StandardResult<TOutput> = StandardSuccessResult<TOutput> | StandardFailureResult;
/**
 * The result interface if validation succeeds.
 */
interface StandardSuccessResult<TOutput> {
    /**
     * The typed output value.
     */
    readonly value: TOutput;
    /**
     * The non-existent issues.
     */
    readonly issues?: undefined;
}
/**
 * The result interface if validation fails.
 */
interface StandardFailureResult {
    /**
     * The issues of failed validation.
     */
    readonly issues: readonly StandardIssue[];
}
/**
 * The issue interface of the failure output.
 */
interface StandardIssue {
    /**
     * The error message of the issue.
     */
    readonly message: string;
    /**
     * The path of the issue, if any.
     */
    readonly path?: readonly (PropertyKey | StandardPathItem)[] | undefined;
}
/**
 * The path item interface of the issue.
 */
interface StandardPathItem {
    /**
     * The key of the path item.
     */
    readonly key: PropertyKey;
}
/**
 * The Standard Schema types interface.
 */
interface StandardTypes<TInput, TOutput> {
    /**
     * The input type of the schema.
     */
    readonly input: TInput;
    /**
     * The output type of the schema.
     */
    readonly output: TOutput;
}

/**
 * Base schema interface.
 */
interface BaseSchema<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'schema';
    /**
     * The schema type.
     */
    readonly type: string;
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * The Standard Schema properties.
     *
     * @internal
     */
    readonly '~standard': StandardProps<TInput, TOutput>;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base schema async interface.
 */
interface BaseSchemaAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseSchema<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The schema reference.
     */
    readonly reference: (...args: any[]) => BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Parses unknown input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: UnknownDataset, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, TIssue>>;
}

/**
 * Base transformation interface.
 */
interface BaseTransformation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'transformation';
    /**
     * The transformation type.
     */
    readonly type: string;
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Transforms known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: SuccessDataset<TInput>, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, BaseIssue<unknown> | TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base transformation async interface.
 */
interface BaseTransformationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseTransformation<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The transformation reference.
     */
    readonly reference: (...args: any[]) => BaseTransformation<any, any, BaseIssue<unknown>> | BaseTransformationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Transforms known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: SuccessDataset<TInput>, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, BaseIssue<unknown> | TIssue>>;
}

/**
 * Base validation interface.
 */
interface BaseValidation<TInput, TOutput, TIssue extends BaseIssue<unknown>> {
    /**
     * The object kind.
     */
    readonly kind: 'validation';
    /**
     * The validation type.
     */
    readonly type: string;
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>>;
    /**
     * The expected property.
     */
    readonly expects: string | null;
    /**
     * Whether it's async.
     */
    readonly async: false;
    /**
     * Validates known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: OutputDataset<TInput, BaseIssue<unknown>>, config: Config<BaseIssue<unknown>>) => OutputDataset<TOutput, BaseIssue<unknown> | TIssue>;
    /**
     * The input, output and issue type.
     *
     * @internal
     */
    readonly '~types'?: {
        readonly input: TInput;
        readonly output: TOutput;
        readonly issue: TIssue;
    } | undefined;
}
/**
 * Base validation async interface.
 */
interface BaseValidationAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> extends Omit<BaseValidation<TInput, TOutput, TIssue>, 'reference' | 'async' | '~run'> {
    /**
     * The validation reference.
     */
    readonly reference: (...args: any[]) => BaseValidation<any, any, BaseIssue<unknown>> | BaseValidationAsync<any, any, BaseIssue<unknown>>;
    /**
     * Whether it's async.
     */
    readonly async: true;
    /**
     * Validates known input values.
     *
     * @param dataset The input dataset.
     * @param config The configuration.
     *
     * @returns The output dataset.
     *
     * @internal
     */
    readonly '~run': (dataset: OutputDataset<TInput, BaseIssue<unknown>>, config: Config<BaseIssue<unknown>>) => Promise<OutputDataset<TOutput, BaseIssue<unknown> | TIssue>>;
}

/**
 * Infer input type.
 */
type InferInput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['input'];
/**
 * Infer output type.
 */
type InferOutput<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['output'];
/**
 * Infer issue type.
 */
type InferIssue<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | BaseValidation<any, unknown, BaseIssue<unknown>> | BaseValidationAsync<any, unknown, BaseIssue<unknown>> | BaseTransformation<any, unknown, BaseIssue<unknown>> | BaseTransformationAsync<any, unknown, BaseIssue<unknown>> | BaseMetadata<any>> = NonNullable<TItem['~types']>['issue'];
/**
 * Constructs a type that is maybe readonly.
 */
type MaybeReadonly<TValue> = TValue | Readonly<TValue>;
/**
 * Constructs a type that is maybe a promise.
 */
type MaybePromise<TValue> = TValue | Promise<TValue>;
/**
 * Prettifies a type for better readability.
 *
 * Hint: This type has no effect and is only used so that TypeScript displays
 * the final type in the preview instead of the utility types used.
 */
type Prettify<TObject> = {
    [TKey in keyof TObject]: TObject[TKey];
} & {};
/**
 * Marks specific keys as optional.
 */
type MarkOptional<TObject, TKeys extends keyof TObject> = Partial<TObject> & Required<Omit<TObject, TKeys>>;
/**
 * Extracts first tuple item.
 *
 */
type FirstTupleItem<TTuple extends readonly [unknown, ...unknown[]]> = TTuple[0];
/**
 * Extracts last tuple item.
 *
 */
type LastTupleItem<TTuple extends readonly [unknown, ...unknown[]]> = TTuple[TTuple extends readonly [unknown, ...infer TRest] ? TRest['length'] : never];

/**
 * Error message type.
 */
type ErrorMessage<TIssue extends BaseIssue<unknown>> = ((issue: TIssue) => string) | string;
/**
 * Default type.
 */
type Default<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybeReadonly<InferInput<TWrapped> | TInput>) | undefined;
/**
 * Default async type.
 */
type DefaultAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TInput extends null | undefined> = MaybeReadonly<InferInput<TWrapped> | TInput> | ((dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybePromise<MaybeReadonly<InferInput<TWrapped> | TInput>>) | undefined;
/**
 * Default value type.
 */
type DefaultValue<TDefault extends Default<BaseSchema<unknown, unknown, BaseIssue<unknown>>, null | undefined> | DefaultAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, null | undefined>> = TDefault extends DefaultAsync<infer TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, infer TInput> ? TDefault extends (dataset?: UnknownDataset, config?: Config<InferIssue<TWrapped>>) => MaybePromise<InferInput<TWrapped> | TInput> ? Awaited<ReturnType<TDefault>> : TDefault : never;

/**
 * Optional entry schema type.
 */
type OptionalEntrySchema = ExactOptionalSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | NullishSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchema<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown>;
/**
 * Optional entry schema async type.
 */
type OptionalEntrySchemaAsync = ExactOptionalSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | NullishSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalSchemaAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown>;
/**
 * Object entries interface.
 */
interface ObjectEntries {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>> | SchemaWithFallback<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalEntrySchema;
}
/**
 * Object entries async interface.
 */
interface ObjectEntriesAsync {
    [key: string]: BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>> | SchemaWithFallback<BaseSchema<unknown, unknown, BaseIssue<unknown>>, unknown> | SchemaWithFallbackAsync<BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, unknown> | OptionalEntrySchema | OptionalEntrySchemaAsync;
}
/**
 * Infer entries input type.
 */
type InferEntriesInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: InferInput<TEntries[TKey]>;
};
/**
 * Infer entries output type.
 */
type InferEntriesOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    -readonly [TKey in keyof TEntries]: InferOutput<TEntries[TKey]>;
};
/**
 * Optional input keys type.
 */
type OptionalInputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalEntrySchema | OptionalEntrySchemaAsync ? TKey : never;
}[keyof TEntries];
/**
 * Optional output keys type.
 */
type OptionalOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends OptionalEntrySchema | OptionalEntrySchemaAsync ? undefined extends TEntries[TKey]['default'] ? TKey : never : never;
}[keyof TEntries];
/**
 * Input with question marks type.
 */
type InputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesInput<TEntries>> = MarkOptional<TObject, OptionalInputKeys<TEntries>>;
/**
 * Output with question marks type.
 */
type OutputWithQuestionMarks<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends InferEntriesOutput<TEntries>> = MarkOptional<TObject, OptionalOutputKeys<TEntries>>;
/**
 * Readonly output keys type.
 */
type ReadonlyOutputKeys<TEntries extends ObjectEntries | ObjectEntriesAsync> = {
    [TKey in keyof TEntries]: TEntries[TKey] extends SchemaWithPipe<infer TPipe> | SchemaWithPipeAsync<infer TPipe> ? ReadonlyAction<any> extends TPipe[number] ? TKey : never : never;
}[keyof TEntries];
/**
 * Output with readonly type.
 */
type OutputWithReadonly<TEntries extends ObjectEntries | ObjectEntriesAsync, TObject extends OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>> = Readonly<TObject> & Pick<TObject, Exclude<keyof TObject, ReadonlyOutputKeys<TEntries>>>;
/**
 * Infer object input type.
 */
type InferObjectInput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<InputWithQuestionMarks<TEntries, InferEntriesInput<TEntries>>>;
/**
 * Infer object output type.
 */
type InferObjectOutput<TEntries extends ObjectEntries | ObjectEntriesAsync> = Prettify<OutputWithReadonly<TEntries, OutputWithQuestionMarks<TEntries, InferEntriesOutput<TEntries>>>>;
/**
 * Infer object issue type.
 */
type InferObjectIssue<TEntries extends ObjectEntries | ObjectEntriesAsync> = InferIssue<TEntries[keyof TEntries]>;

/**
 * Array path item interface.
 */
interface ArrayPathItem {
    /**
     * The path item type.
     */
    readonly type: 'array';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: MaybeReadonly<unknown[]>;
    /**
     * The path item key.
     */
    readonly key: number;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Map path item interface.
 */
interface MapPathItem {
    /**
     * The path item type.
     */
    readonly type: 'map';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Map<unknown, unknown>;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Object path item interface.
 */
interface ObjectPathItem {
    /**
     * The path item type.
     */
    readonly type: 'object';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: Record<string, unknown>;
    /**
     * The path item key.
     */
    readonly key: string;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Set path item interface.
 */
interface SetPathItem {
    /**
     * The path item type.
     */
    readonly type: 'set';
    /**
     * The path item origin.
     */
    readonly origin: 'value';
    /**
     * The path item input.
     */
    readonly input: Set<unknown>;
    /**
     * The path item key.
     */
    readonly key: null;
    /**
     * The path item key.
     */
    readonly value: unknown;
}
/**
 * Unknown path item interface.
 */
interface UnknownPathItem {
    /**
     * The path item type.
     */
    readonly type: 'unknown';
    /**
     * The path item origin.
     */
    readonly origin: 'key' | 'value';
    /**
     * The path item input.
     */
    readonly input: unknown;
    /**
     * The path item key.
     */
    readonly key: unknown;
    /**
     * The path item value.
     */
    readonly value: unknown;
}
/**
 * Issue path item type.
 */
type IssuePathItem = ArrayPathItem | MapPathItem | ObjectPathItem | SetPathItem | UnknownPathItem;
/**
 * Base issue interface.
 */
interface BaseIssue<TInput> extends Config<BaseIssue<TInput>> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema' | 'validation' | 'transformation';
    /**
     * The issue type.
     */
    readonly type: string;
    /**
     * The raw input data.
     */
    readonly input: TInput;
    /**
     * The expected property.
     */
    readonly expected: string | null;
    /**
     * The received property.
     */
    readonly received: string;
    /**
     * The error message.
     */
    readonly message: string;
    /**
     * The input requirement.
     */
    readonly requirement?: unknown | undefined;
    /**
     * The issue path.
     */
    readonly path?: [IssuePathItem, ...IssuePathItem[]] | undefined;
    /**
     * The sub issues.
     */
    readonly issues?: [BaseIssue<TInput>, ...BaseIssue<TInput>[]] | undefined;
}

/**
 * Config interface.
 */
interface Config<TIssue extends BaseIssue<unknown>> {
    /**
     * The selected language.
     */
    readonly lang?: string | undefined;
    /**
     * The error message.
     */
    readonly message?: ErrorMessage<TIssue> | undefined;
    /**
     * Whether it should be aborted early.
     */
    readonly abortEarly?: boolean | undefined;
    /**
     * Whether a pipe should be aborted early.
     */
    readonly abortPipeEarly?: boolean | undefined;
}

/**
 * Pipe action type.
 */
type PipeAction<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidation<TInput, TOutput, TIssue> | BaseTransformation<TInput, TOutput, TIssue> | BaseMetadata<TInput>;
/**
 * Pipe action async type.
 */
type PipeActionAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseValidationAsync<TInput, TOutput, TIssue> | BaseTransformationAsync<TInput, TOutput, TIssue>;
/**
 * Pipe item type.
 */
type PipeItem<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchema<TInput, TOutput, TIssue> | PipeAction<TInput, TOutput, TIssue>;
/**
 * Pipe item async type.
 */
type PipeItemAsync<TInput, TOutput, TIssue extends BaseIssue<unknown>> = BaseSchemaAsync<TInput, TOutput, TIssue> | PipeActionAsync<TInput, TOutput, TIssue>;

/**
 * Array issue interface.
 */
interface ArrayIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'array';
    /**
     * The expected property.
     */
    readonly expected: 'Array';
}

/**
 * Array schema interface.
 */
interface ArraySchema<TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TMessage extends ErrorMessage<ArrayIssue> | undefined> extends BaseSchema<InferInput<TItem>[], InferOutput<TItem>[], ArrayIssue | InferIssue<TItem>> {
    /**
     * The schema type.
     */
    readonly type: 'array';
    /**
     * The schema reference.
     */
    readonly reference: typeof array;
    /**
     * The expected property.
     */
    readonly expects: 'Array';
    /**
     * The array item schema.
     */
    readonly item: TItem;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(item: TItem): ArraySchema<TItem, undefined>;
/**
 * Creates an array schema.
 *
 * @param item The item schema.
 * @param message The error message.
 *
 * @returns An array schema.
 */
declare function array<const TItem extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TMessage extends ErrorMessage<ArrayIssue> | undefined>(item: TItem, message: TMessage): ArraySchema<TItem, TMessage>;

/**
 * Boolean issue interface.
 */
interface BooleanIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'boolean';
    /**
     * The expected property.
     */
    readonly expected: 'boolean';
}
/**
 * Boolean schema interface.
 */
interface BooleanSchema<TMessage extends ErrorMessage<BooleanIssue> | undefined> extends BaseSchema<boolean, boolean, BooleanIssue> {
    /**
     * The schema type.
     */
    readonly type: 'boolean';
    /**
     * The schema reference.
     */
    readonly reference: typeof boolean;
    /**
     * The expected property.
     */
    readonly expects: 'boolean';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a boolean schema.
 *
 * @returns A boolean schema.
 */
declare function boolean(): BooleanSchema<undefined>;
/**
 * Creates a boolean schema.
 *
 * @param message The error message.
 *
 * @returns A boolean schema.
 */
declare function boolean<const TMessage extends ErrorMessage<BooleanIssue> | undefined>(message: TMessage): BooleanSchema<TMessage>;

/**
 * Exact optional schema interface.
 */
interface ExactOptionalSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, never>> extends BaseSchema<InferInput<TWrapped>, InferOutput<TWrapped>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'exact_optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof exactOptional;
    /**
     * The expected property.
     */
    readonly expects: TWrapped['expects'];
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An exact optional schema.
 */
declare function exactOptional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): ExactOptionalSchema<TWrapped, undefined>;
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An exact optional schema.
 */
declare function exactOptional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, never>>(wrapped: TWrapped, default_: TDefault): ExactOptionalSchema<TWrapped, TDefault>;

/**
 * Exact optional schema async interface.
 */
interface ExactOptionalSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, never>> extends BaseSchemaAsync<InferInput<TWrapped>, InferOutput<TWrapped>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'exact_optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof exactOptional | typeof exactOptionalAsync;
    /**
     * The expected property.
     */
    readonly expects: TWrapped['expects'];
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An exact optional schema.
 */
declare function exactOptionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): ExactOptionalSchemaAsync<TWrapped, undefined>;
/**
 * Creates an exact optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An exact optional schema.
 */
declare function exactOptionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, never>>(wrapped: TWrapped, default_: TDefault): ExactOptionalSchemaAsync<TWrapped, TDefault>;

/**
 * Infer nullish output type.
 */
type InferNullishOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> = undefined extends TDefault ? InferOutput<TWrapped> | null | undefined : InferOutput<TWrapped> | Extract<DefaultValue<TDefault>, null | undefined>;

/**
 * Nullish schema interface.
 */
interface NullishSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, null | undefined>> extends BaseSchema<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullish;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchema<TWrapped, undefined>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullish<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchema<TWrapped, TDefault>;

/**
 * Nullish schema async interface.
 */
interface NullishSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, null | undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | null | undefined, InferNullishOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'nullish';
    /**
     * The schema reference.
     */
    readonly reference: typeof nullish | typeof nullishAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | null | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): NullishSchemaAsync<TWrapped, undefined>;
/**
 * Creates a nullish schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns A nullish schema.
 */
declare function nullishAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, null | undefined>>(wrapped: TWrapped, default_: TDefault): NullishSchemaAsync<TWrapped, TDefault>;

/**
 * Object issue interface.
 */
interface ObjectIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'object';
    /**
     * The expected property.
     */
    readonly expected: 'Object' | `"${string}"`;
}

/**
 * Object schema interface.
 */
interface ObjectSchema<TEntries extends ObjectEntries, TMessage extends ErrorMessage<ObjectIssue> | undefined> extends BaseSchema<InferObjectInput<TEntries>, InferObjectOutput<TEntries>, ObjectIssue | InferObjectIssue<TEntries>> {
    /**
     * The schema type.
     */
    readonly type: 'object';
    /**
     * The schema reference.
     */
    readonly reference: typeof object;
    /**
     * The expected property.
     */
    readonly expects: 'Object';
    /**
     * The entries schema.
     */
    readonly entries: TEntries;
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries>(entries: TEntries): ObjectSchema<TEntries, undefined>;
/**
 * Creates an object schema.
 *
 * Hint: This schema removes unknown entries. The output will only include the
 * entries you specify. To include unknown entries, use `looseObject`. To
 * return an issue for unknown entries, use `strictObject`. To include and
 * validate unknown entries, use `objectWithRest`.
 *
 * @param entries The entries schema.
 * @param message The error message.
 *
 * @returns An object schema.
 */
declare function object<const TEntries extends ObjectEntries, const TMessage extends ErrorMessage<ObjectIssue> | undefined>(entries: TEntries, message: TMessage): ObjectSchema<TEntries, TMessage>;

/**
 * Infer optional output type.
 */
type InferOptionalOutput<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> = undefined extends TDefault ? InferOutput<TWrapped> | undefined : InferOutput<TWrapped> | Extract<DefaultValue<TDefault>, undefined>;

/**
 * Optional schema interface.
 */
interface OptionalSchema<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, TDefault extends Default<TWrapped, undefined>> extends BaseSchema<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optional;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchema<TWrapped, undefined>;
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An optional schema.
 */
declare function optional<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>>, const TDefault extends Default<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchema<TWrapped, TDefault>;

/**
 * Optional schema async interface.
 */
interface OptionalSchemaAsync<TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, TDefault extends DefaultAsync<TWrapped, undefined>> extends BaseSchemaAsync<InferInput<TWrapped> | undefined, InferOptionalOutput<TWrapped, TDefault>, InferIssue<TWrapped>> {
    /**
     * The schema type.
     */
    readonly type: 'optional';
    /**
     * The schema reference.
     */
    readonly reference: typeof optional | typeof optionalAsync;
    /**
     * The expected property.
     */
    readonly expects: `(${TWrapped['expects']} | undefined)`;
    /**
     * The wrapped schema.
     */
    readonly wrapped: TWrapped;
    /**
     * The default value.
     */
    readonly default: TDefault;
}
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>>(wrapped: TWrapped): OptionalSchemaAsync<TWrapped, undefined>;
/**
 * Creates an optional schema.
 *
 * @param wrapped The wrapped schema.
 * @param default_ The default value.
 *
 * @returns An optional schema.
 */
declare function optionalAsync<const TWrapped extends BaseSchema<unknown, unknown, BaseIssue<unknown>> | BaseSchemaAsync<unknown, unknown, BaseIssue<unknown>>, const TDefault extends DefaultAsync<TWrapped, undefined>>(wrapped: TWrapped, default_: TDefault): OptionalSchemaAsync<TWrapped, TDefault>;

/**
 * String issue interface.
 */
interface StringIssue extends BaseIssue<unknown> {
    /**
     * The issue kind.
     */
    readonly kind: 'schema';
    /**
     * The issue type.
     */
    readonly type: 'string';
    /**
     * The expected property.
     */
    readonly expected: 'string';
}
/**
 * String schema interface.
 */
interface StringSchema<TMessage extends ErrorMessage<StringIssue> | undefined> extends BaseSchema<string, string, StringIssue> {
    /**
     * The schema type.
     */
    readonly type: 'string';
    /**
     * The schema reference.
     */
    readonly reference: typeof string;
    /**
     * The expected property.
     */
    readonly expects: 'string';
    /**
     * The error message.
     */
    readonly message: TMessage;
}
/**
 * Creates a string schema.
 *
 * @returns A string schema.
 */
declare function string(): StringSchema<undefined>;
/**
 * Creates a string schema.
 *
 * @param message The error message.
 *
 * @returns A string schema.
 */
declare function string<const TMessage extends ErrorMessage<StringIssue> | undefined>(message: TMessage): StringSchema<TMessage>;

/**
 * Readonly output type.
 */
type ReadonlyOutput<TInput> = TInput extends Map<infer TKey, infer TValue> ? ReadonlyMap<TKey, TValue> : TInput extends Set<infer TValue> ? ReadonlySet<TValue> : Readonly<TInput>;
/**
 * Readonly action interface.
 */
interface ReadonlyAction<TInput> extends BaseTransformation<TInput, ReadonlyOutput<TInput>, never> {
    /**
     * The action type.
     */
    readonly type: 'readonly';
    /**
     * The action reference.
     */
    readonly reference: typeof readonly;
}
/**
 * Creates a readonly transformation action.
 *
 * @returns A readonly action.
 */
declare function readonly<TInput>(): ReadonlyAction<TInput>;

declare const CustomComponentPropSchema: ObjectSchema<{
    /**
     * The name of the prop in the user-defined component.
     * @example
     * "to"
     */
    readonly name: StringSchema<undefined>;
    /**
     * The name of the prop in the built-in component.
     * @example
     * "href"
     */
    readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * Whether the prop is controlled or not in the user-defined component.
     * @internal
     * @example
     * `true`
     */
    readonly controlled: OptionalSchema<BooleanSchema<undefined>, undefined>;
    /**
     * The default value of the prop in the user-defined component.
     * @example
     * `"/"`
     */
    readonly defaultValue: OptionalSchema<StringSchema<undefined>, undefined>;
}, undefined>;
/**
 * @description
 * This will provide some key information to the rule before checking for user-defined components.
 * For example:
 * Which prop is used as the `href` prop for the user-defined `Link` component that represents the built-in `a` element.
 */
declare const CustomComponentSchema: ObjectSchema<{
    /**
     * The name of the user-defined component.
     * @example
     * "Link"
     */
    readonly name: StringSchema<undefined>;
    /**
     * The name of the built-in component that the user-defined component represents.
     * @example
     * "a"
     */
    readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * Attributes mapping between the user-defined component and the built-in component.
     * @example
     * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
     */
    readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
        /**
         * The name of the prop in the user-defined component.
         * @example
         * "to"
         */
        readonly name: StringSchema<undefined>;
        /**
         * The name of the prop in the built-in component.
         * @example
         * "href"
         */
        readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * Whether the prop is controlled or not in the user-defined component.
         * @internal
         * @example
         * `true`
         */
        readonly controlled: OptionalSchema<BooleanSchema<undefined>, undefined>;
        /**
         * The default value of the prop in the user-defined component.
         * @example
         * `"/"`
         */
        readonly defaultValue: OptionalSchema<StringSchema<undefined>, undefined>;
    }, undefined>, undefined>, undefined>;
    /**
     * The ESQuery selector to select the component precisely.
     * @internal
     * @example
     * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
     */
    readonly selector: OptionalSchema<StringSchema<undefined>, undefined>;
}, undefined>;
declare const CustomHooksSchema: ObjectSchema<{
    readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useFormStatus: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintReactSettingsSchema: ObjectSchema<{
    /**
     * The source where React is imported from.
     * @description This allows to specify a custom import location for React when not using the official distribution.
     * @default `"react"`
     * @example `"@pika/react"`
     */
    readonly importSource: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * The identifier that's used for JSX Element creation.
     * @default `"createElement"`
     * @deprecated
     */
    readonly jsxPragma: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * The identifier that's used for JSX fragment elements.
     * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
     * @default `"Fragment"`
     * @deprecated
     */
    readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * The name of the prop that is used for polymorphic components.
     * @description This is used to determine the type of the component.
     * @example `"as"`
     */
    readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * @internal
     */
    readonly strict: OptionalSchema<BooleanSchema<undefined>, false>;
    /**
     * Check both the shape and the import to determine if an API is from React.
     * @description This can prevent false positives when using a irrelevant third-party library that has similar APIs to React.
     * @default `true`
     */
    readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
    /**
     * React version to use, "detect" means auto detect React version from the project's dependencies.
     * If `importSource` is specified, an equivalent version of React should be provided here.
     * @example `"18.3.1"`
     * @default `"detect"`
     */
    readonly version: OptionalSchema<StringSchema<undefined>, undefined>;
    /**
     * A object to define additional hooks that are equivalent to the built-in React Hooks.
     * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
     * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
     */
    readonly additionalHooks: OptionalSchema<ObjectSchema<{
        readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useFormStatus: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
    }, undefined>, undefined>;
    /**
     * An array of user-defined components
     * @description This is used to inform the ESLint React plugins how to treat these components during checks.
     * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
     */
    readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
        /**
         * The name of the user-defined component.
         * @example
         * "Link"
         */
        readonly name: StringSchema<undefined>;
        /**
         * The name of the built-in component that the user-defined component represents.
         * @example
         * "a"
         */
        readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * Attributes mapping between the user-defined component and the built-in component.
         * @example
         * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
         */
        readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the prop in the user-defined component.
             * @example
             * "to"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The name of the prop in the built-in component.
             * @example
             * "href"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
            /**
             * Whether the prop is controlled or not in the user-defined component.
             * @internal
             * @example
             * `true`
             */
            readonly controlled: OptionalSchema<BooleanSchema<undefined>, undefined>;
            /**
             * The default value of the prop in the user-defined component.
             * @example
             * `"/"`
             */
            readonly defaultValue: OptionalSchema<StringSchema<undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
        /**
         * The ESQuery selector to select the component precisely.
         * @internal
         * @example
         * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
         */
        readonly selector: OptionalSchema<StringSchema<undefined>, undefined>;
    }, undefined>, undefined>, undefined>;
}, undefined>;
/**
 * @internal
 */
declare const ESLintSettingsSchema: OptionalSchema<ObjectSchema<{
    readonly "react-x": OptionalSchema<ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The identifier that's used for JSX Element creation.
         * @default `"createElement"`
         * @deprecated
         */
        readonly jsxPragma: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The identifier that's used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         * @deprecated
         */
        readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strict: OptionalSchema<BooleanSchema<undefined>, false>;
        /**
         * Check both the shape and the import to determine if an API is from React.
         * @description This can prevent false positives when using a irrelevant third-party library that has similar APIs to React.
         * @default `true`
         */
        readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
        /**
         * React version to use, "detect" means auto detect React version from the project's dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * A object to define additional hooks that are equivalent to the built-in React Hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: OptionalSchema<ObjectSchema<{
            readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useFormStatus: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        }, undefined>, undefined>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
            /**
             * Attributes mapping between the user-defined component and the built-in component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
                /**
                 * The name of the prop in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: StringSchema<undefined>;
                /**
                 * The name of the prop in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
                /**
                 * Whether the prop is controlled or not in the user-defined component.
                 * @internal
                 * @example
                 * `true`
                 */
                readonly controlled: OptionalSchema<BooleanSchema<undefined>, undefined>;
                /**
                 * The default value of the prop in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: OptionalSchema<StringSchema<undefined>, undefined>;
            }, undefined>, undefined>, undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @internal
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: OptionalSchema<StringSchema<undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
    }, undefined>, undefined>;
    /** @deprecated Use `react-x` instead */
    readonly reactOptions: OptionalSchema<ObjectSchema<{
        /**
         * The source where React is imported from.
         * @description This allows to specify a custom import location for React when not using the official distribution.
         * @default `"react"`
         * @example `"@pika/react"`
         */
        readonly importSource: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The identifier that's used for JSX Element creation.
         * @default `"createElement"`
         * @deprecated
         */
        readonly jsxPragma: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The identifier that's used for JSX fragment elements.
         * @description This should not be a member expression (i.e. use "Fragment" instead of "React.Fragment").
         * @default `"Fragment"`
         * @deprecated
         */
        readonly jsxPragmaFrag: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * The name of the prop that is used for polymorphic components.
         * @description This is used to determine the type of the component.
         * @example `"as"`
         */
        readonly polymorphicPropName: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * @internal
         */
        readonly strict: OptionalSchema<BooleanSchema<undefined>, false>;
        /**
         * Check both the shape and the import to determine if an API is from React.
         * @description This can prevent false positives when using a irrelevant third-party library that has similar APIs to React.
         * @default `true`
         */
        readonly skipImportCheck: OptionalSchema<BooleanSchema<undefined>, true>;
        /**
         * React version to use, "detect" means auto detect React version from the project's dependencies.
         * If `importSource` is specified, an equivalent version of React should be provided here.
         * @example `"18.3.1"`
         * @default `"detect"`
         */
        readonly version: OptionalSchema<StringSchema<undefined>, undefined>;
        /**
         * A object to define additional hooks that are equivalent to the built-in React Hooks.
         * @description ESLint React will recognize these aliases as equivalent to the built-in hooks in all its rules.
         * @example `{ useEffect: ["useIsomorphicLayoutEffect"] }`
         */
        readonly additionalHooks: OptionalSchema<ObjectSchema<{
            readonly use: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useActionState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useCallback: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useContext: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useDebugValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useDeferredValue: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useFormStatus: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useId: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useImperativeHandle: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useInsertionEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useLayoutEffect: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useMemo: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useOptimistic: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useReducer: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useRef: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useState: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useSyncExternalStore: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
            readonly useTransition: OptionalSchema<ArraySchema<StringSchema<undefined>, undefined>, undefined>;
        }, undefined>, undefined>;
        /**
         * An array of user-defined components
         * @description This is used to inform the ESLint React plugins how to treat these components during checks.
         * @example `[{ name: "Link", as: "a", attributes: [{ name: "to", as: "href" }, { name: "rel", defaultValue: "noopener noreferrer" }] }]`
         */
        readonly additionalComponents: OptionalSchema<ArraySchema<ObjectSchema<{
            /**
             * The name of the user-defined component.
             * @example
             * "Link"
             */
            readonly name: StringSchema<undefined>;
            /**
             * The name of the built-in component that the user-defined component represents.
             * @example
             * "a"
             */
            readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
            /**
             * Attributes mapping between the user-defined component and the built-in component.
             * @example
             * `Link` component has a `to` attribute that represents the `href` attribute in the built-in `a` element with a default value of `"/"`.
             */
            readonly attributes: OptionalSchema<ArraySchema<ObjectSchema<{
                /**
                 * The name of the prop in the user-defined component.
                 * @example
                 * "to"
                 */
                readonly name: StringSchema<undefined>;
                /**
                 * The name of the prop in the built-in component.
                 * @example
                 * "href"
                 */
                readonly as: OptionalSchema<StringSchema<undefined>, undefined>;
                /**
                 * Whether the prop is controlled or not in the user-defined component.
                 * @internal
                 * @example
                 * `true`
                 */
                readonly controlled: OptionalSchema<BooleanSchema<undefined>, undefined>;
                /**
                 * The default value of the prop in the user-defined component.
                 * @example
                 * `"/"`
                 */
                readonly defaultValue: OptionalSchema<StringSchema<undefined>, undefined>;
            }, undefined>, undefined>, undefined>;
            /**
             * The ESQuery selector to select the component precisely.
             * @internal
             * @example
             * `JSXElement:has(JSXAttribute[name.name='component'][value.value='a'])`
             */
            readonly selector: OptionalSchema<StringSchema<undefined>, undefined>;
        }, undefined>, undefined>, undefined>;
    }, undefined>, undefined>;
}, undefined>, {}>;
type CustomComponent = InferOutput<typeof CustomComponentSchema>;
type CustomComponentProp = InferOutput<typeof CustomComponentPropSchema>;
type CustomHooks = InferOutput<typeof CustomHooksSchema>;
type ESLintReactSettings = InferOutput<typeof ESLintReactSettingsSchema>;
type ESLintSettings = InferOutput<typeof ESLintSettingsSchema>;
/**
 * The default ESLint settings for "react-x".
 */
declare const DEFAULT_ESLINT_REACT_SETTINGS: {
    readonly importSource: "react";
    readonly polymorphicPropName: "as";
    readonly skipImportCheck: true;
    readonly version: "detect";
    readonly additionalHooks: {
        readonly useEffect: ["useIsomorphicLayoutEffect"];
        readonly useLayoutEffect: ["useIsomorphicLayoutEffect"];
    };
    readonly jsxPragma?: string | undefined;
    readonly jsxPragmaFrag?: string | undefined;
    readonly strict: boolean;
    readonly additionalComponents?: {
        name: string;
        as?: string | undefined;
        attributes?: {
            name: string;
            as?: string | undefined;
            controlled?: boolean | undefined;
            defaultValue?: string | undefined;
        }[] | undefined;
        selector?: string | undefined;
    }[] | undefined;
};

interface Dictionary<Type> {
  [key: string]: Type;
  [index: number]: Type;
}

type AnyFn = (...args: any[]) => any;

type Key = any[];
type RawKey = Key | IArguments;
type Value = any;

interface CacheSnapshot {
  keys: Key[];
  size: number;
  values: Value[];
}

declare class Cache<Fn extends AnyFn> {
  readonly canTransformKey: boolean;
  readonly getKeyIndex: KeyIndexGetter;
  readonly options: NormalizedOptions<Fn>;
  readonly shouldCloneArguments: boolean;
  readonly shouldUpdateOnAdd: boolean;
  readonly shouldUpdateOnChange: boolean;
  readonly shouldUpdateOnHit: boolean;

  /**
   * The prevents call arguments which have cached results.
   */
  keys: Key[];
  /**
   * The results of previous cached calls.
   */
  values: Value[];

  constructor(options: NormalizedOptions<Fn>);

  /**
   * The number of cached [key,value] results.
   */
  get size(): number;

  /**
   * A copy of the cache at a moment in time. This is useful
   * to compare changes over time, since the cache mutates
   * internally for performance reasons.
   */
  get snapshot(): CacheSnapshot;

  /**
   * Order the array based on a Least-Recently-Used basis.
   */
  orderByLru(key: Key, value: Value, startingIndex: number): void;

  /**
   * Update the promise method to auto-remove from cache if rejected, and
   * if resolved then fire cache hit / changed.
   */
  updateAsyncCache(memoized: Memoized<Fn>): void;
}

type EqualityComparator = (object1: any, object2: any) => boolean;

type MatchingKeyComparator = (key1: Key, key2: RawKey) => boolean;

type CacheModifiedHandler<Fn extends AnyFn> = (
  cache: Cache<Fn>,
  options: NormalizedOptions<Fn>,
  memoized: Memoized<Fn>,
) => void;

type KeyTransformer = (args: Key) => Key;

type KeyIndexGetter = (keyToMatch: RawKey) => number;

interface StandardOptions<Fn extends AnyFn> {
  isEqual?: EqualityComparator;
  isMatchingKey?: MatchingKeyComparator;
  isPromise?: boolean;
  maxSize?: number;
  onCacheAdd?: CacheModifiedHandler<Fn>;
  onCacheChange?: CacheModifiedHandler<Fn>;
  onCacheHit?: CacheModifiedHandler<Fn>;
  transformKey?: KeyTransformer;
}

interface Options<Fn extends AnyFn>
  extends StandardOptions<Fn>,
    Dictionary<any> {}

interface NormalizedOptions<Fn extends AnyFn> extends Options<Fn> {
  isEqual: EqualityComparator;
  isPromise: boolean;
  maxSize: number;
}

type Memoized<Fn extends AnyFn> = Fn &
  Dictionary<any> & {
    cache: Cache<Fn>;
    fn: Fn;
    isMemoized: true;
    options: NormalizedOptions<Fn>;
  };

/**
Matches any [primitive value](https://developer.mozilla.org/en-US/docs/Glossary/Primitive).

@category Type
*/
type Primitive =
	| null
	| undefined
	| string
	| number
	| boolean
	| symbol
	| bigint;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

/**
Matches any primitive, `void`, `Date`, or `RegExp` value.
*/
type BuiltIns = Primitive | void | Date | RegExp;

/**
@see {@link PartialDeep}
*/
type PartialDeepOptions = {
	/**
	Whether to affect the individual elements of arrays and tuples.

	@default false
	*/
	readonly recurseIntoArrays?: boolean;

	/**
	Allows `undefined` values in non-tuple arrays.

	- When set to `true`, elements of non-tuple arrays can be `undefined`.
	- When set to `false`, only explicitly defined elements are allowed in non-tuple arrays, ensuring stricter type checking.

	@default true

	@example
	You can prevent `undefined` values in non-tuple arrays by passing `{recurseIntoArrays: true; allowUndefinedInNonTupleArrays: false}` as the second type argument:

	```
	import type {PartialDeep} from 'type-fest';

	type Settings = {
		languages: string[];
	};

	declare const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true; allowUndefinedInNonTupleArrays: false}>;

	partialSettings.languages = [undefined]; // Error
	partialSettings.languages = []; // Ok
	```
	*/
	readonly allowUndefinedInNonTupleArrays?: boolean;
};

/**
Create a type from another type with all keys and nested keys set to optional.

Use-cases:
- Merging a default settings/config object with another object, the second object would be a deep partial of the default object.
- Mocking and testing complex entities, where populating an entire object with its keys would be redundant in terms of the mock or test.

@example
```
import type {PartialDeep} from 'type-fest';

const settings: Settings = {
	textEditor: {
		fontSize: 14,
		fontColor: '#000000',
		fontWeight: 400
	},
	autocomplete: false,
	autosave: true
};

const applySavedSettings = (savedSettings: PartialDeep<Settings>) => {
	return {...settings, ...savedSettings};
}

settings = applySavedSettings({textEditor: {fontWeight: 500}});
```

By default, this does not affect elements in array and tuple types. You can change this by passing `{recurseIntoArrays: true}` as the second type argument:

```
import type {PartialDeep} from 'type-fest';

type Settings = {
	languages: string[];
}

const partialSettings: PartialDeep<Settings, {recurseIntoArrays: true}> = {
	languages: [undefined]
};
```

@see {@link PartialDeepOptions}

@category Object
@category Array
@category Set
@category Map
*/
type PartialDeep<T, Options extends PartialDeepOptions = {}> = T extends BuiltIns | (((...arguments_: any[]) => unknown)) | (new (...arguments_: any[]) => unknown)
	? T
	: T extends Map<infer KeyType, infer ValueType>
		? PartialMapDeep<KeyType, ValueType, Options>
		: T extends Set<infer ItemType>
			? PartialSetDeep<ItemType, Options>
			: T extends ReadonlyMap<infer KeyType, infer ValueType>
				? PartialReadonlyMapDeep<KeyType, ValueType, Options>
				: T extends ReadonlySet<infer ItemType>
					? PartialReadonlySetDeep<ItemType, Options>
					: T extends object
						? T extends ReadonlyArray<infer ItemType> // Test for arrays/tuples, per https://github.com/microsoft/TypeScript/issues/35156
							? Options['recurseIntoArrays'] extends true
								? ItemType[] extends T // Test for arrays (non-tuples) specifically
									? readonly ItemType[] extends T // Differentiate readonly and mutable arrays
										? ReadonlyArray<PartialDeep<Options['allowUndefinedInNonTupleArrays'] extends false ? ItemType : ItemType | undefined, Options>>
										: Array<PartialDeep<Options['allowUndefinedInNonTupleArrays'] extends false ? ItemType : ItemType | undefined, Options>>
									: PartialObjectDeep<T, Options> // Tuples behave properly
								: T // If they don't opt into array testing, just use the original type
							: PartialObjectDeep<T, Options>
						: unknown;

/**
Same as `PartialDeep`, but accepts only `Map`s and as inputs. Internal helper for `PartialDeep`.
*/
type PartialMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & Map<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `Set`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialSetDeep<T, Options extends PartialDeepOptions> = {} & Set<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlyMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> = {} & ReadonlyMap<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;

/**
Same as `PartialDeep`, but accepts only `ReadonlySet`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialReadonlySetDeep<T, Options extends PartialDeepOptions> = {} & ReadonlySet<PartialDeep<T, Options>>;

/**
Same as `PartialDeep`, but accepts only `object`s as inputs. Internal helper for `PartialDeep`.
*/
type PartialObjectDeep<ObjectType extends object, Options extends PartialDeepOptions> = {
	[KeyType in keyof ObjectType]?: PartialDeep<ObjectType[KeyType], Options>
};

interface CustomComponentNormalized {
    name: string;
    as: string;
    attributes: CustomComponentPropNormalized[];
    re: RegExp;
}
interface CustomComponentPropNormalized {
    name: string;
    as: string;
    defaultValue?: string | _;
}
/**
 * The normalized version of the `ESLintReactSettings`.
 * @internal
 */
interface ESLintReactSettingsNormalized {
    additionalComponents: CustomComponentNormalized[];
    additionalHooks: CustomHooks;
    importSource: string;
    polymorphicPropName: string | _;
    skipImportCheck: boolean;
    version: string;
}
/**
 * Unsafely casts settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare function unsafeDecodeSettings(data: unknown): PartialDeep<ESLintReactSettings>;
/**
 * Decodes settings from a data object from `context.settings`.
 * @internal
 * @param data The data object.
 * @returns settings The settings.
 */
declare const decodeSettings: Memoized<(data: unknown) => ESLintReactSettings>;
/**
 * The memoized version of `ESLintReactSettings`.
 * @param settings The settings.
 * @returns The normalized settings.
 * @internal
 */
declare const toNormalizedSettings: Memoized<({ additionalComponents, additionalHooks, importSource, polymorphicPropName, skipImportCheck, version, ...rest }: ESLintReactSettings) => ESLintReactSettingsNormalized>;
declare function getSettingsFromContext(context: {
    settings: unknown;
}): ESLintReactSettingsNormalized;
/**
 * A helper function to define settings for "react-x" with type checking in JavaScript files.
 * @param settings The settings.
 * @returns The settings.
 */
declare const defineSettings: (settings: ESLintReactSettings) => ESLintReactSettings;
declare module "@typescript-eslint/utils/ts-eslint" {
    interface SharedConfigurationSettings {
        "react-x"?: Partial<ESLintReactSettings>;
    }
}

/**
 * Rule severity.
 * @since 0.0.1
 */
type RuleSeverity = "error" | "off" | "warn";
/**
 * Rule declaration.
 * @internal
 * @since 0.0.1
 */
type RuleDeclaration = [RuleSeverity, Record<string, unknown>?] | RuleSeverity;
/**
 * Rule config preset.
 * @since 0.0.1
 */
type RulePreset = Record<string, RuleDeclaration>;
/**
 * Rule creator function.
 * @since 0.0.1
 * @internal
 */
type RuleCreator = Parameters<ReturnType<typeof ESLintUtils.RuleCreator>>[0]["create"];
/**
 * Rule context.
 * @since 0.0.1
 */
type RuleContext = Parameters<RuleCreator>[0];
/**
 * Rule options.
 * @since 0.0.1
 */
type RuleOptions = Parameters<RuleCreator>[1];
/**
 * Rule namespace.
 * @since 0.0.1
 */
type RuleNamespace = "x" | "dom" | "web-api" | "hooks-extra" | "naming-convention" | "debug";
/**
 * Rule feature.
 * @since 1.20.0
 */
type RuleFeature = "CFG" | "CHK" | "DBG" | "FIX" | "MOD" | "TSC";

export { type CustomComponent, type CustomComponentNormalized, type CustomComponentProp, type CustomComponentPropNormalized, CustomComponentPropSchema, CustomComponentSchema, type CustomHooks, CustomHooksSchema, DEFAULT_ESLINT_REACT_SETTINGS, type ESLintReactSettings, type ESLintReactSettingsNormalized, ESLintReactSettingsSchema, type ESLintSettings, ESLintSettingsSchema, GITHUB_URL, NPM_SCOPE, REACT_BUILD_IN_HOOKS, RE_CAMEL_CASE, RE_CONSTANT_CASE, RE_JAVASCRIPT_PROTOCOL, RE_KEBAB_CASE, RE_PASCAL_CASE, RE_SNAKE_CASE, type RuleContext, type RuleDeclaration, type RuleFeature, type RuleNamespace, type RuleOptions, type RulePreset, type RuleSeverity, WEBSITE_URL, createRuleForPlugin, decodeSettings, defineSettings, getId, getReactVersion, getSettingsFromContext, isInEditorEnv, isInGitHooksOrLintStaged, toNormalizedSettings, unsafeDecodeSettings };
