import * as AST3 from '@eslint-react/ast';
import { constTrue } from '@eslint-react/eff';
import { AST_NODE_TYPES } from '@typescript-eslint/types';
import * as VAR from '@eslint-react/var';
import { match, P } from 'ts-pattern';

// src/find-parent-attribute.ts
function findParentAttribute(node, test = constTrue) {
  const guard = (node2) => {
    return node2.type === AST_NODE_TYPES.JSXAttribute && test(node2);
  };
  return AST3.findParentNode(node, guard);
}
function toString(node) {
  switch (node.type) {
    case AST_NODE_TYPES.JSXIdentifier:
      return node.name;
    case AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case AST_NODE_TYPES.JSXMemberExpression:
      return `${toString(node.object)}.${toString(node.property)}`;
    case AST_NODE_TYPES.JSXText:
      return node.value;
    case AST_NODE_TYPES.JSXOpeningElement:
      return `<${toString(node.name)}>`;
    case AST_NODE_TYPES.JSXClosingElement:
      return `</${toString(node.name)}>`;
    case AST_NODE_TYPES.JSXOpeningFragment:
      return "<>";
    case AST_NODE_TYPES.JSXClosingFragment:
      return "</>";
  }
}

// src/get-attribute-name.ts
function getAttributeName(node) {
  return toString(node.name);
}

// src/get-attribute.ts
function getAttribute(name, attributes, initialScope) {
  return attributes.findLast((attr) => {
    if (attr.type === AST_NODE_TYPES.JSXAttribute) {
      return getAttributeName(attr) === name;
    }
    if (initialScope == null) return false;
    switch (attr.argument.type) {
      case AST_NODE_TYPES.Identifier: {
        const variable = VAR.findVariable(attr.argument.name, initialScope);
        const variableNode = VAR.getVariableInitNode(variable, 0);
        if (variableNode?.type === AST_NODE_TYPES.ObjectExpression) {
          return VAR.findPropertyInProperties(name, variableNode.properties, initialScope) != null;
        }
        return false;
      }
      case AST_NODE_TYPES.ObjectExpression:
        return VAR.findPropertyInProperties(name, attr.argument.properties, initialScope) != null;
    }
    return false;
  });
}
function getAttributeValue(node, name, initialScope) {
  switch (node.type) {
    case AST_NODE_TYPES.JSXAttribute:
      if (node.value?.type === AST_NODE_TYPES.Literal) {
        return {
          kind: "some",
          node: node.value,
          initialScope,
          value: node.value.value
        };
      }
      if (node.value?.type === AST_NODE_TYPES.JSXExpressionContainer) {
        return VAR.toStaticValue({
          kind: "lazy",
          node: node.value.expression,
          initialScope
        });
      }
      return { kind: "none", node, initialScope };
    case AST_NODE_TYPES.JSXSpreadAttribute: {
      const staticValue = VAR.toStaticValue({
        kind: "lazy",
        node: node.argument,
        initialScope
      });
      if (staticValue.kind === "none") {
        return staticValue;
      }
      return match(staticValue.value).with({ [name]: P.select(P.any) }, (value) => ({
        kind: "some",
        node: node.argument,
        initialScope,
        value
      })).otherwise(() => ({ kind: "none", node, initialScope }));
    }
    default:
      return { kind: "none", node, initialScope };
  }
}
function getElementType(node) {
  if (node.type === AST_NODE_TYPES.JSXFragment) {
    return "";
  }
  return toString(node.openingElement.name);
}

// src/has-attribute.ts
function hasAttribute(name, attributes, initialScope) {
  return getAttribute(name, attributes, initialScope) != null;
}
function hasAnyAttribute(names, attributes, initialScope) {
  return names.some((n) => hasAttribute(n, attributes, initialScope));
}
function hasEveryAttribute(names, attributes, initialScope) {
  return names.every((n) => hasAttribute(n, attributes, initialScope));
}
var JSXValueHint = {
  None: 0n,
  SkipUndefined: 1n << 0n,
  SkipNullLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipBigIntLiteral: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  SkipCreateElement: 1n << 7n,
  StrictArray: 1n << 8n,
  StrictLogical: 1n << 9n,
  StrictConditional: 1n << 10n
};
var DEFAULT_JSX_VALUE_HINT = 0n | JSXValueHint.SkipUndefined | JSXValueHint.SkipBooleanLiteral;
function isJSXValue(node, jsxCtx, hint = DEFAULT_JSX_VALUE_HINT) {
  switch (node?.type) {
    case AST_NODE_TYPES.JSXElement:
    case AST_NODE_TYPES.JSXFragment:
    case AST_NODE_TYPES.JSXMemberExpression:
    case AST_NODE_TYPES.JSXNamespacedName: {
      return true;
    }
    case AST_NODE_TYPES.Literal: {
      switch (typeof node.value) {
        case "boolean":
          return !(hint & JSXValueHint.SkipBooleanLiteral);
        case "string":
          return !(hint & JSXValueHint.SkipStringLiteral);
        case "number":
          return !(hint & JSXValueHint.SkipNumberLiteral);
        case "bigint":
          return !(hint & JSXValueHint.SkipBigIntLiteral);
      }
      if (node.value == null) {
        return !(hint & JSXValueHint.SkipNullLiteral);
      }
      return false;
    }
    case AST_NODE_TYPES.TemplateLiteral: {
      return !(hint & JSXValueHint.SkipStringLiteral);
    }
    case AST_NODE_TYPES.ArrayExpression: {
      if (hint & JSXValueHint.StrictArray) {
        return node.elements.every((n) => isJSXValue(n, jsxCtx, hint));
      }
      return node.elements.some((n) => isJSXValue(n, jsxCtx, hint));
    }
    case AST_NODE_TYPES.LogicalExpression: {
      if (hint & JSXValueHint.StrictLogical) {
        return isJSXValue(node.left, jsxCtx, hint) && isJSXValue(node.right, jsxCtx, hint);
      }
      return isJSXValue(node.left, jsxCtx, hint) || isJSXValue(node.right, jsxCtx, hint);
    }
    case AST_NODE_TYPES.ConditionalExpression: {
      let leftHasJSX2 = function(node2) {
        if (Array.isArray(node2.consequent)) {
          if (node2.consequent.length === 0) {
            return !(hint & JSXValueHint.SkipEmptyArray);
          }
          if (hint & JSXValueHint.StrictArray) {
            return node2.consequent.every((n) => isJSXValue(n, jsxCtx, hint));
          }
          return node2.consequent.some((n) => isJSXValue(n, jsxCtx, hint));
        }
        return isJSXValue(node2.consequent, jsxCtx, hint);
      }, rightHasJSX2 = function(node2) {
        return isJSXValue(node2.alternate, jsxCtx, hint);
      };
      if (hint & JSXValueHint.StrictConditional) {
        return leftHasJSX2(node) && rightHasJSX2(node);
      }
      return leftHasJSX2(node) || rightHasJSX2(node);
    }
    case AST_NODE_TYPES.SequenceExpression: {
      const exp = node.expressions.at(-1);
      return isJSXValue(exp, jsxCtx, hint);
    }
    case AST_NODE_TYPES.CallExpression: {
      if (hint & JSXValueHint.SkipCreateElement) {
        return false;
      }
      switch (node.callee.type) {
        case AST_NODE_TYPES.Identifier:
          return node.callee.name === "createElement";
        case AST_NODE_TYPES.MemberExpression:
          return node.callee.property.type === AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
      }
      return false;
    }
    case AST_NODE_TYPES.Identifier: {
      const { name } = node;
      if (name === "undefined") {
        return !(hint & JSXValueHint.SkipUndefined);
      }
      if (AST3.isJSXTagNameExpression(node)) {
        return true;
      }
      const variable = VAR.findVariable(name, jsxCtx.getScope(node));
      const variableNode = variable && VAR.getVariableInitNode(variable, 0);
      return !!variableNode && isJSXValue(variableNode, jsxCtx, hint);
    }
  }
  return false;
}
function isFragmentElement(node) {
  if (node.type !== AST_NODE_TYPES.JSXElement) return false;
  return getElementType(node).split(".").at(-1) === "Fragment";
}
function isKeyedElement(node, initialScope) {
  return node.type === AST_NODE_TYPES.JSXElement && hasAttribute("key", node.openingElement.attributes, initialScope);
}
function isBuiltInElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && node.openingElement.name.name.toLowerCase() === node.openingElement.name.name && /^[a-z]/u.test(node.openingElement.name.name);
}
function isUserDefinedElement(node) {
  return node.type === AST_NODE_TYPES.JSXElement && node.openingElement.name.type === AST_NODE_TYPES.JSXIdentifier && /^[A-Z]/u.test(node.openingElement.name.name);
}
var isLiteral = AST3.isOneOf([AST_NODE_TYPES.Literal, AST_NODE_TYPES.JSXText]);
function isWhiteSpace(node) {
  return typeof node.value === "string" && node.value.trim() === "";
}
function isLineBreak(node) {
  return isLiteral(node) && isWhiteSpace(node) && AST3.isMultiLine(node);
}
function isPaddingSpaces(node) {
  return isLiteral(node) && isWhiteSpace(node) && node.raw.includes("\n");
}

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findParentAttribute, getAttribute, getAttributeName, getAttributeValue, getElementType, hasAnyAttribute, hasAttribute, hasEveryAttribute, isBuiltInElement, isFragmentElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, toString };
