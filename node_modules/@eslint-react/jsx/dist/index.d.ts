import { _ } from '@eslint-react/eff';
import { TSESTree } from '@typescript-eslint/types';
import { Scope } from '@typescript-eslint/scope-manager';
import { TSESTree as TSESTree$1 } from '@typescript-eslint/utils';
import * as VAR from '@eslint-react/var';

/**
 * Find the parent JSX attribute node of a node
 * @param node The node to find the parent attribute of
 * @param test The test to apply to the parent attribute
 * @returns The parent attribute node or undefined
 */
declare function findParentAttribute(node: TSESTree.Node, test?: (node: TSESTree.JSXAttribute) => boolean): TSESTree.JSXAttribute | _;

/**
 * Get the JSX attribute node with the given name
 * @param name The name of the attribute
 * @param attributes The attributes to search
 * @param initialScope The initial scope to use for variable resolution
 * @returns The JSX attribute node or undefined
 */
declare function getAttribute(name: string, attributes: (TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute)[], initialScope?: Scope): TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute | _;

/**
 * Get the stringified name of a JSX attribute
 * @param node The JSX attribute node
 * @returns The name of the attribute
 */
declare function getAttributeName(node: TSESTree$1.JSXAttribute): string;

/**
 * Get a StaticValue of the attribute value
 * @param node The JSX attribute node
 * @param name The name of the attribute
 * @param initialScope The initial scope to use
 * @returns The StaticValue of the attribute value
 */
declare function getAttributeValue(node: TSESTree$1.JSXAttribute | TSESTree$1.JSXSpreadAttribute, name: string, initialScope: Scope): Exclude<VAR.LazyValue, {
    kind: "lazy";
}>;

/**
 * Get the stringified name of a JSX element
 * @param node The JSX element node
 * @returns The name of the element
 */
declare function getElementType(node: TSESTree.JSXElement | TSESTree.JSXFragment): string;

declare function hasAttribute(name: string, attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasAnyAttribute(names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;
declare function hasEveryAttribute(names: string[], attributes: TSESTree.JSXOpeningElement["attributes"], initialScope?: Scope): boolean;

declare const JSXValueHint: {
    readonly None: 0n;
    readonly SkipUndefined: bigint;
    readonly SkipNullLiteral: bigint;
    readonly SkipBooleanLiteral: bigint;
    readonly SkipStringLiteral: bigint;
    readonly SkipNumberLiteral: bigint;
    readonly SkipBigIntLiteral: bigint;
    readonly SkipEmptyArray: bigint;
    readonly SkipCreateElement: bigint;
    readonly StrictArray: bigint;
    readonly StrictLogical: bigint;
    readonly StrictConditional: bigint;
};
declare const DEFAULT_JSX_VALUE_HINT: bigint;
/**
 * Heuristic decision to determine if a node is a JSX value
 * @param node The AST node to check
 * @param jsxCtx The requirements for the check
 * @param jsxCtx.getScope The function to get the scope of a node
 * @param hint The `JSXValueHint` to use
 * @returns boolean
 */
declare function isJSXValue(node: TSESTree$1.Node | _ | null, jsxCtx: {
    getScope: (node: TSESTree$1.Node) => Scope;
}, hint?: bigint): boolean;

/**
 * Check if a node is a Fragment element
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXElement` of `Fragment` type
 */
declare function isFragmentElement(node: TSESTree.Node): boolean;
/**
 * Check if a node has a `key` prop
 * @param node The AST node to check
 * @param initialScope The initial scope to start searching for the `key` attribute
 * @returns `true` if the node is a `JSXElement` of `Keyed Component` type
 */
declare function isKeyedElement(node: TSESTree.Node, initialScope?: Scope): boolean;
/**
 * Check if a node is a `JSXFragment` of `Built-in Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXFragment` of `Built-in Component` type
 */
declare function isBuiltInElement(node: TSESTree.Node): boolean;
/**
 * Check if a node is a `JSXElement` of `User-Defined Component` type
 * @param node The AST node to check
 * @returns `true` if the node is a `JSXElement` of `User-Defined Component` type
 */
declare function isUserDefinedElement(node: TSESTree.Node): boolean;

/**
 * Check if a node is a Literal or JSXText
 * @param node The AST node to check
 * @returns boolean `true` if the node is a Literal or JSXText
 */
declare const isLiteral: (node: TSESTree.Node | null | undefined) => node is TSESTree.JSXText | TSESTree.BigIntLiteral | TSESTree.BooleanLiteral | TSESTree.NullLiteral | TSESTree.NumberLiteral | TSESTree.RegExpLiteral | TSESTree.StringLiteral;
/**
 * Check if a Literal or JSXText node is whitespace
 * @param node The AST node to check
 * @returns boolean `true` if the node is whitespace
 */
declare function isWhiteSpace(node: TSESTree.JSXText | TSESTree.Literal): boolean;
/**
 * Check if a Literal or JSXText node is a line break
 * @param node The AST node to check
 * @returns boolean
 */
declare function isLineBreak(node: TSESTree.Node): boolean;
/**
 * Check if a Literal or JSXText node is padding spaces
 * @param node The AST node to check
 * @returns boolean
 */
declare function isPaddingSpaces(node: TSESTree.Node): boolean;

/**
 * Get the stringified representation of a JSX node
 * @param node The JSX node
 * @returns The stringified representation
 */
declare function toString(node: TSESTree$1.JSXIdentifier | TSESTree$1.JSXMemberExpression | TSESTree$1.JSXNamespacedName | TSESTree$1.JSXOpeningElement | TSESTree$1.JSXClosingElement | TSESTree$1.JSXOpeningFragment | TSESTree$1.JSXClosingFragment | TSESTree$1.JSXText): string;

export { DEFAULT_JSX_VALUE_HINT, JSXValueHint, findParentAttribute, getAttribute, getAttributeName, getAttributeValue, getElementType, hasAnyAttribute, hasAttribute, hasEveryAttribute, isBuiltInElement, isFragmentElement, isJSXValue, isKeyedElement, isLineBreak, isLiteral, isPaddingSpaces, isUserDefinedElement, isWhiteSpace, toString };
