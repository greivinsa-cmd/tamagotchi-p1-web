'use strict';

var AST3 = require('@eslint-react/ast');
var eff = require('@eslint-react/eff');
var types = require('@typescript-eslint/types');
var VAR = require('@eslint-react/var');
var tsPattern = require('ts-pattern');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var AST3__namespace = /*#__PURE__*/_interopNamespace(AST3);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);

// src/find-parent-attribute.ts
function findParentAttribute(node, test = eff.constTrue) {
  const guard = (node2) => {
    return node2.type === types.AST_NODE_TYPES.JSXAttribute && test(node2);
  };
  return AST3__namespace.findParentNode(node, guard);
}
function toString(node) {
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXIdentifier:
      return node.name;
    case types.AST_NODE_TYPES.JSXNamespacedName:
      return `${node.namespace.name}:${node.name.name}`;
    case types.AST_NODE_TYPES.JSXMemberExpression:
      return `${toString(node.object)}.${toString(node.property)}`;
    case types.AST_NODE_TYPES.JSXText:
      return node.value;
    case types.AST_NODE_TYPES.JSXOpeningElement:
      return `<${toString(node.name)}>`;
    case types.AST_NODE_TYPES.JSXClosingElement:
      return `</${toString(node.name)}>`;
    case types.AST_NODE_TYPES.JSXOpeningFragment:
      return "<>";
    case types.AST_NODE_TYPES.JSXClosingFragment:
      return "</>";
  }
}

// src/get-attribute-name.ts
function getAttributeName(node) {
  return toString(node.name);
}

// src/get-attribute.ts
function getAttribute(name, attributes, initialScope) {
  return attributes.findLast((attr) => {
    if (attr.type === types.AST_NODE_TYPES.JSXAttribute) {
      return getAttributeName(attr) === name;
    }
    if (initialScope == null) return false;
    switch (attr.argument.type) {
      case types.AST_NODE_TYPES.Identifier: {
        const variable = VAR__namespace.findVariable(attr.argument.name, initialScope);
        const variableNode = VAR__namespace.getVariableInitNode(variable, 0);
        if (variableNode?.type === types.AST_NODE_TYPES.ObjectExpression) {
          return VAR__namespace.findPropertyInProperties(name, variableNode.properties, initialScope) != null;
        }
        return false;
      }
      case types.AST_NODE_TYPES.ObjectExpression:
        return VAR__namespace.findPropertyInProperties(name, attr.argument.properties, initialScope) != null;
    }
    return false;
  });
}
function getAttributeValue(node, name, initialScope) {
  switch (node.type) {
    case types.AST_NODE_TYPES.JSXAttribute:
      if (node.value?.type === types.AST_NODE_TYPES.Literal) {
        return {
          kind: "some",
          node: node.value,
          initialScope,
          value: node.value.value
        };
      }
      if (node.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer) {
        return VAR__namespace.toStaticValue({
          kind: "lazy",
          node: node.value.expression,
          initialScope
        });
      }
      return { kind: "none", node, initialScope };
    case types.AST_NODE_TYPES.JSXSpreadAttribute: {
      const staticValue = VAR__namespace.toStaticValue({
        kind: "lazy",
        node: node.argument,
        initialScope
      });
      if (staticValue.kind === "none") {
        return staticValue;
      }
      return tsPattern.match(staticValue.value).with({ [name]: tsPattern.P.select(tsPattern.P.any) }, (value) => ({
        kind: "some",
        node: node.argument,
        initialScope,
        value
      })).otherwise(() => ({ kind: "none", node, initialScope }));
    }
    default:
      return { kind: "none", node, initialScope };
  }
}
function getElementType(node) {
  if (node.type === types.AST_NODE_TYPES.JSXFragment) {
    return "";
  }
  return toString(node.openingElement.name);
}

// src/has-attribute.ts
function hasAttribute(name, attributes, initialScope) {
  return getAttribute(name, attributes, initialScope) != null;
}
function hasAnyAttribute(names, attributes, initialScope) {
  return names.some((n) => hasAttribute(n, attributes, initialScope));
}
function hasEveryAttribute(names, attributes, initialScope) {
  return names.every((n) => hasAttribute(n, attributes, initialScope));
}
var JSXValueHint = {
  None: 0n,
  SkipUndefined: 1n << 0n,
  SkipNullLiteral: 1n << 1n,
  SkipBooleanLiteral: 1n << 2n,
  SkipStringLiteral: 1n << 3n,
  SkipNumberLiteral: 1n << 4n,
  SkipBigIntLiteral: 1n << 5n,
  SkipEmptyArray: 1n << 6n,
  SkipCreateElement: 1n << 7n,
  StrictArray: 1n << 8n,
  StrictLogical: 1n << 9n,
  StrictConditional: 1n << 10n
};
var DEFAULT_JSX_VALUE_HINT = 0n | JSXValueHint.SkipUndefined | JSXValueHint.SkipBooleanLiteral;
function isJSXValue(node, jsxCtx, hint = DEFAULT_JSX_VALUE_HINT) {
  switch (node?.type) {
    case types.AST_NODE_TYPES.JSXElement:
    case types.AST_NODE_TYPES.JSXFragment:
    case types.AST_NODE_TYPES.JSXMemberExpression:
    case types.AST_NODE_TYPES.JSXNamespacedName: {
      return true;
    }
    case types.AST_NODE_TYPES.Literal: {
      switch (typeof node.value) {
        case "boolean":
          return !(hint & JSXValueHint.SkipBooleanLiteral);
        case "string":
          return !(hint & JSXValueHint.SkipStringLiteral);
        case "number":
          return !(hint & JSXValueHint.SkipNumberLiteral);
        case "bigint":
          return !(hint & JSXValueHint.SkipBigIntLiteral);
      }
      if (node.value == null) {
        return !(hint & JSXValueHint.SkipNullLiteral);
      }
      return false;
    }
    case types.AST_NODE_TYPES.TemplateLiteral: {
      return !(hint & JSXValueHint.SkipStringLiteral);
    }
    case types.AST_NODE_TYPES.ArrayExpression: {
      if (hint & JSXValueHint.StrictArray) {
        return node.elements.every((n) => isJSXValue(n, jsxCtx, hint));
      }
      return node.elements.some((n) => isJSXValue(n, jsxCtx, hint));
    }
    case types.AST_NODE_TYPES.LogicalExpression: {
      if (hint & JSXValueHint.StrictLogical) {
        return isJSXValue(node.left, jsxCtx, hint) && isJSXValue(node.right, jsxCtx, hint);
      }
      return isJSXValue(node.left, jsxCtx, hint) || isJSXValue(node.right, jsxCtx, hint);
    }
    case types.AST_NODE_TYPES.ConditionalExpression: {
      let leftHasJSX2 = function(node2) {
        if (Array.isArray(node2.consequent)) {
          if (node2.consequent.length === 0) {
            return !(hint & JSXValueHint.SkipEmptyArray);
          }
          if (hint & JSXValueHint.StrictArray) {
            return node2.consequent.every((n) => isJSXValue(n, jsxCtx, hint));
          }
          return node2.consequent.some((n) => isJSXValue(n, jsxCtx, hint));
        }
        return isJSXValue(node2.consequent, jsxCtx, hint);
      }, rightHasJSX2 = function(node2) {
        return isJSXValue(node2.alternate, jsxCtx, hint);
      };
      if (hint & JSXValueHint.StrictConditional) {
        return leftHasJSX2(node) && rightHasJSX2(node);
      }
      return leftHasJSX2(node) || rightHasJSX2(node);
    }
    case types.AST_NODE_TYPES.SequenceExpression: {
      const exp = node.expressions.at(-1);
      return isJSXValue(exp, jsxCtx, hint);
    }
    case types.AST_NODE_TYPES.CallExpression: {
      if (hint & JSXValueHint.SkipCreateElement) {
        return false;
      }
      switch (node.callee.type) {
        case types.AST_NODE_TYPES.Identifier:
          return node.callee.name === "createElement";
        case types.AST_NODE_TYPES.MemberExpression:
          return node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === "createElement";
      }
      return false;
    }
    case types.AST_NODE_TYPES.Identifier: {
      const { name } = node;
      if (name === "undefined") {
        return !(hint & JSXValueHint.SkipUndefined);
      }
      if (AST3__namespace.isJSXTagNameExpression(node)) {
        return true;
      }
      const variable = VAR__namespace.findVariable(name, jsxCtx.getScope(node));
      const variableNode = variable && VAR__namespace.getVariableInitNode(variable, 0);
      return !!variableNode && isJSXValue(variableNode, jsxCtx, hint);
    }
  }
  return false;
}
function isFragmentElement(node) {
  if (node.type !== types.AST_NODE_TYPES.JSXElement) return false;
  return getElementType(node).split(".").at(-1) === "Fragment";
}
function isKeyedElement(node, initialScope) {
  return node.type === types.AST_NODE_TYPES.JSXElement && hasAttribute("key", node.openingElement.attributes, initialScope);
}
function isBuiltInElement(node) {
  return node.type === types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === types.AST_NODE_TYPES.JSXIdentifier && node.openingElement.name.name.toLowerCase() === node.openingElement.name.name && /^[a-z]/u.test(node.openingElement.name.name);
}
function isUserDefinedElement(node) {
  return node.type === types.AST_NODE_TYPES.JSXElement && node.openingElement.name.type === types.AST_NODE_TYPES.JSXIdentifier && /^[A-Z]/u.test(node.openingElement.name.name);
}
var isLiteral = AST3__namespace.isOneOf([types.AST_NODE_TYPES.Literal, types.AST_NODE_TYPES.JSXText]);
function isWhiteSpace(node) {
  return typeof node.value === "string" && node.value.trim() === "";
}
function isLineBreak(node) {
  return isLiteral(node) && isWhiteSpace(node) && AST3__namespace.isMultiLine(node);
}
function isPaddingSpaces(node) {
  return isLiteral(node) && isWhiteSpace(node) && node.raw.includes("\n");
}

exports.DEFAULT_JSX_VALUE_HINT = DEFAULT_JSX_VALUE_HINT;
exports.JSXValueHint = JSXValueHint;
exports.findParentAttribute = findParentAttribute;
exports.getAttribute = getAttribute;
exports.getAttributeName = getAttributeName;
exports.getAttributeValue = getAttributeValue;
exports.getElementType = getElementType;
exports.hasAnyAttribute = hasAnyAttribute;
exports.hasAttribute = hasAttribute;
exports.hasEveryAttribute = hasEveryAttribute;
exports.isBuiltInElement = isBuiltInElement;
exports.isFragmentElement = isFragmentElement;
exports.isJSXValue = isJSXValue;
exports.isKeyedElement = isKeyedElement;
exports.isLineBreak = isLineBreak;
exports.isLiteral = isLiteral;
exports.isPaddingSpaces = isPaddingSpaces;
exports.isUserDefinedElement = isUserDefinedElement;
exports.isWhiteSpace = isWhiteSpace;
exports.toString = toString;
