'use strict';

// src/index.ts
var _ = void 0;
function identity(x) {
  return x;
}
var constVoid = () => {
};
var constTrue = () => true;
var constFalse = () => false;
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self) {
          return body(self, ...args);
        };
      };
  }
};
var flip = (f) => (...b) => (...a) => f(...a)(...b);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function not(predicate) {
  return (data) => !predicate(data);
}
function or(a, b) {
  return (data) => a(data) || b(data);
}
function isArray(data) {
  return Array.isArray(data);
}
function isObject(data) {
  return typeof data === "object" && data !== null;
}
function isTruthy(data) {
  return Boolean(data);
}
function zipWith(arrayA, arrayB, callback) {
  const result = [];
  for (let i = 0; i < arrayA.length; i++) {
    result.push(callback(arrayA[i], arrayB[i], i));
  }
  return result;
}
function intersperse(input, element) {
  if (input.length <= 1) {
    return input;
  }
  const result = [];
  for (let i = 0, n = input.length; i < n; i++) {
    if (i !== 0) result.push(element);
    result.push(input[i]);
  }
  return result;
}
function concatenate(array1, array2) {
  if (array2 === void 0 || array2.length === 0) return array1;
  if (array1 === void 0 || array1.length === 0) return array2;
  return [...array1, ...array2];
}
function getOrUpdate(map, key, callback) {
  if (map.has(key)) {
    return map.get(key);
  }
  const value = callback();
  map.set(key, value);
  return value;
}
function tryAddToSet(set, value) {
  if (!set.has(value)) {
    set.add(value);
    return true;
  }
  return false;
}

exports._ = _;
exports.concatenate = concatenate;
exports.constFalse = constFalse;
exports.constTrue = constTrue;
exports.constVoid = constVoid;
exports.dual = dual;
exports.flip = flip;
exports.flow = flow;
exports.getOrUpdate = getOrUpdate;
exports.identity = identity;
exports.intersperse = intersperse;
exports.isArray = isArray;
exports.isObject = isObject;
exports.isTruthy = isTruthy;
exports.not = not;
exports.or = or;
exports.pipe = pipe;
exports.tryAddToSet = tryAddToSet;
exports.zipWith = zipWith;
