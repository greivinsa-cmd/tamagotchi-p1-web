Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

const core = require('@sentry/core');
const helpers = require('../helpers.js');
require('@sentry-internal/browser-utils');
require('../stack-parsers.js');
const debugBuild = require('../debug-build.js');
require('../integrations/breadcrumbs.js');
require('../integrations/browserapierrors.js');
require('../integrations/browsersession.js');
require('../integrations/globalhandlers.js');
require('../integrations/httpcontext.js');
require('../integrations/linkederrors.js');

// 1h in seconds
const PREVIOUS_TRACE_MAX_DURATION = 3600;

// session storage key
const PREVIOUS_TRACE_KEY = 'sentry_previous_trace';

/**
 * Adds a previous_trace span link to the passed span if the passed
 * previousTraceInfo is still valid.
 *
 * @returns the updated previous trace info (based on the current span/trace) to
 * be used on the next call
 */
function addPreviousTraceSpanLink(
  previousTraceInfo,
  span,
) {
  const spanJson = core.spanToJSON(span);

  if (!previousTraceInfo) {
    return {
      spanContext: span.spanContext(),
      startTimestamp: spanJson.start_timestamp,
    };
  }

  if (previousTraceInfo.spanContext.traceId === spanJson.trace_id) {
    // This means, we're still in the same trace so let's not update the previous trace info
    // or add a link to the current span.
    // Once we move away from the long-lived, route-based trace model, we can remove this cases
    return previousTraceInfo;
  }

  // Only add the link if the startTimeStamp of the previous trace's root span is within
  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp
  // This is done to
  // - avoid adding links to "stale" traces
  // - enable more efficient querying for previous/next traces in Sentry
  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {
    if (debugBuild.DEBUG_BUILD) {
      core.logger.info(
        `Adding previous_trace ${previousTraceInfo.spanContext} link to span ${{
          op: spanJson.op,
          ...span.spanContext(),
        }}`,
      );
    }

    span.addLink({
      context: previousTraceInfo.spanContext,
      attributes: {
        [core.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace',
      },
    });
  }

  return {
    spanContext: span.spanContext(),
    startTimestamp: core.spanToJSON(span).start_timestamp,
  };
}

/**
 * Stores @param previousTraceInfo in sessionStorage.
 */
function storePreviousTraceInSessionStorage(previousTraceInfo) {
  try {
    helpers.WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));
  } catch (e) {
    // Ignore potential errors (e.g. if sessionStorage is not available)
    debugBuild.DEBUG_BUILD && core.logger.warn('Could not store previous trace in sessionStorage', e);
  }
}

/**
 * Retrieves the previous trace from sessionStorage if available.
 */
function getPreviousTraceFromSessionStorage() {
  try {
    const previousTraceInfo = helpers.WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);
    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size
    return JSON.parse(previousTraceInfo);
  } catch (e) {
    return undefined;
  }
}

exports.PREVIOUS_TRACE_KEY = PREVIOUS_TRACE_KEY;
exports.PREVIOUS_TRACE_MAX_DURATION = PREVIOUS_TRACE_MAX_DURATION;
exports.addPreviousTraceSpanLink = addPreviousTraceSpanLink;
exports.getPreviousTraceFromSessionStorage = getPreviousTraceFromSessionStorage;
exports.storePreviousTraceInSessionStorage = storePreviousTraceInSessionStorage;
//# sourceMappingURL=previousTrace.js.map
