'use strict';

var shared = require('@eslint-react/shared');
var JSX8 = require('@eslint-react/jsx');
var AST11 = require('@eslint-react/ast');
var core = require('@eslint-react/core');
var eff = require('@eslint-react/eff');
var types = require('@typescript-eslint/types');
var tsPattern = require('ts-pattern');
var compareVersions = require('compare-versions');
var VAR = require('@eslint-react/var');
var typeUtils = require('@typescript-eslint/type-utils');
var utils = require('@typescript-eslint/utils');
var tsApiUtils = require('ts-api-utils');
var ts = require('typescript');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var JSX8__namespace = /*#__PURE__*/_interopNamespace(JSX8);
var AST11__namespace = /*#__PURE__*/_interopNamespace(AST11);
var VAR__namespace = /*#__PURE__*/_interopNamespace(VAR);
var ts__default = /*#__PURE__*/_interopDefault(ts);

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name5 in all)
    __defProp(target, name5, { get: all[name5], enumerable: true });
};

// src/configs/recommended.ts
var recommended_exports = {};
__export(recommended_exports, {
  name: () => name,
  rules: () => rules,
  settings: () => settings
});
var name = "react-x/recommended";
var rules = {
  "react-x/no-access-state-in-setstate": "error",
  "react-x/no-array-index-key": "warn",
  "react-x/no-children-count": "warn",
  "react-x/no-children-for-each": "warn",
  "react-x/no-children-map": "warn",
  "react-x/no-children-only": "warn",
  "react-x/no-children-to-array": "warn",
  "react-x/no-clone-element": "warn",
  "react-x/no-comment-textnodes": "warn",
  "react-x/no-component-will-mount": "error",
  "react-x/no-component-will-receive-props": "error",
  "react-x/no-component-will-update": "error",
  "react-x/no-context-provider": "warn",
  "react-x/no-create-ref": "error",
  "react-x/no-default-props": "error",
  "react-x/no-direct-mutation-state": "error",
  "react-x/no-duplicate-jsx-props": "warn",
  "react-x/no-duplicate-key": "warn",
  "react-x/no-forward-ref": "warn",
  "react-x/no-implicit-key": "warn",
  "react-x/no-missing-key": "error",
  "react-x/no-nested-components": "error",
  "react-x/no-prop-types": "error",
  "react-x/no-redundant-should-component-update": "error",
  "react-x/no-set-state-in-component-did-mount": "warn",
  "react-x/no-set-state-in-component-did-update": "warn",
  "react-x/no-set-state-in-component-will-update": "warn",
  "react-x/no-string-refs": "error",
  "react-x/no-unsafe-component-will-mount": "warn",
  "react-x/no-unsafe-component-will-receive-props": "warn",
  "react-x/no-unsafe-component-will-update": "warn",
  "react-x/no-unstable-context-value": "warn",
  "react-x/no-unstable-default-props": "warn",
  "react-x/no-unused-class-component-members": "warn",
  "react-x/no-unused-state": "warn",
  "react-x/no-use-context": "warn",
  "react-x/no-useless-forward-ref": "warn",
  "react-x/use-jsx-vars": "warn"
};
var settings = {
  "react-x": shared.DEFAULT_ESLINT_REACT_SETTINGS
};

// src/configs/recommended-type-checked.ts
var recommended_type_checked_exports = {};
__export(recommended_type_checked_exports, {
  name: () => name3,
  rules: () => rules3,
  settings: () => settings3
});

// src/configs/recommended-typescript.ts
var recommended_typescript_exports = {};
__export(recommended_typescript_exports, {
  name: () => name2,
  rules: () => rules2,
  settings: () => settings2
});
var name2 = "react-x/recommended-typescript";
var rules2 = {
  ...rules,
  "react-x/dom/no-unknown-property": "off",
  "react-x/no-duplicate-jsx-props": "off",
  "react-x/use-jsx-vars": "off"
};
var settings2 = {
  ...settings
};

// src/configs/recommended-type-checked.ts
var name3 = "react-x/recommended-type-checked";
var rules3 = {
  ...rules2,
  "react-x/no-leaked-conditional-rendering": "warn"
  // "react-x/prefer-read-only-props": "warn",
};
var settings3 = {
  ...settings2
};

// package.json
var name4 = "eslint-plugin-react-x";
var version = "1.33.0";
var createRule = shared.createRuleForPlugin("x");

// src/rules/avoid-shorthand-boolean.ts
var RULE_NAME = "avoid-shorthand-boolean";
var RULE_FEATURES = [
  "CHK"
];
var avoid_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand boolean attributes",
      [Symbol.for("rule_features")]: RULE_FEATURES
    },
    fixable: "code",
    messages: {
      avoidShorthandBoolean: "Avoid using shorthand boolean attribute '{{propName}}'. Use '{{propName}}={true}' instead."
    },
    schema: []
  },
  name: RULE_NAME,
  create(context) {
    return {
      JSXAttribute(node) {
        if (node.value === null) {
          context.report({
            messageId: "avoidShorthandBoolean",
            node,
            data: {
              propName: JSX8__namespace.getAttributeName(node)
            },
            fix: (fixer) => fixer.insertTextAfter(node.name, `={true}`)
          });
        }
      }
    };
  },
  defaultOptions: []
});

// src/rules/avoid-shorthand-fragment.ts
var RULE_NAME2 = "avoid-shorthand-fragment";
var RULE_FEATURES2 = [
  "CHK"
];
var avoid_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using shorthand fragment syntax",
      [Symbol.for("rule_features")]: RULE_FEATURES2
    },
    messages: {
      avoidShorthandFragment: "Avoid using shorthand fragment syntax. Use 'Fragment' component instead."
    },
    schema: []
  },
  name: RULE_NAME2,
  create(context) {
    return {
      JSXFragment(node) {
        context.report({
          messageId: "avoidShorthandFragment",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME3 = "no-access-state-in-setstate";
var RULE_FEATURES3 = [
  "CHK"
];
function isKeyLiteral(node, key) {
  return tsPattern.match(key).with({ type: types.AST_NODE_TYPES.Literal }, eff.constTrue).with({ type: types.AST_NODE_TYPES.TemplateLiteral, expressions: [] }, eff.constTrue).with({ type: types.AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(eff.constFalse);
}
var no_access_state_in_setstate_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow accessing 'this.state' within 'setState'",
      [Symbol.for("rule_features")]: RULE_FEATURES3
    },
    messages: {
      noAccessStateInSetstate: "Do not access 'this.state' within 'setState'. Use the update function instead."
    },
    schema: []
  },
  name: RULE_NAME3,
  create(context) {
    if (!context.sourceCode.text.includes("setState")) {
      return {};
    }
    const classEntries = [];
    const methodEntries = [];
    const setStateEntries = [];
    return {
      CallExpression(node) {
        if (!core.isThisSetState(node)) {
          return;
        }
        setStateEntries.push([node, false]);
      },
      "CallExpression:exit"(node) {
        if (!core.isThisSetState(node)) {
          return;
        }
        setStateEntries.pop();
      },
      ClassDeclaration(node) {
        classEntries.push([node, core.isClassComponent(node)]);
      },
      "ClassDeclaration:exit"() {
        classEntries.pop();
      },
      ClassExpression(node) {
        classEntries.push([node, core.isClassComponent(node)]);
      },
      "ClassExpression:exit"() {
        classEntries.pop();
      },
      MemberExpression(node) {
        if (!AST11__namespace.isThisExpression(node.object)) {
          return;
        }
        const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
        if (currClass == null || !isComponent) {
          return;
        }
        const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
        if (currMethod == null || isStatic) {
          return;
        }
        const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
        if (setState == null || hasThisState) {
          return;
        }
        if (AST11__namespace.getPropertyName(node.property) !== "state") {
          return;
        }
        context.report({ messageId: "noAccessStateInSetstate", node });
      },
      MethodDefinition(node) {
        methodEntries.push([node, node.static]);
      },
      "MethodDefinition:exit"() {
        methodEntries.pop();
      },
      PropertyDefinition(node) {
        methodEntries.push([node, node.static]);
      },
      "PropertyDefinition:exit"() {
        methodEntries.pop();
      },
      VariableDeclarator(node) {
        const [currClass, isComponent = false] = classEntries.at(-1) ?? [];
        if (currClass == null || !isComponent) {
          return;
        }
        const [currMethod, isStatic = false] = methodEntries.at(-1) ?? [];
        if (currMethod == null || isStatic) {
          return;
        }
        const [setState, hasThisState = false] = setStateEntries.at(-1) ?? [];
        if (setState == null || hasThisState) {
          return;
        }
        if (node.init == null || !AST11__namespace.isThisExpression(node.init) || node.id.type !== types.AST_NODE_TYPES.ObjectPattern) {
          return;
        }
        const hasState = node.id.properties.some(
          (prop) => prop.type === types.AST_NODE_TYPES.Property && isKeyLiteral(prop, prop.key) && AST11__namespace.getPropertyName(prop.key) === "state"
        );
        if (!hasState) {
          return;
        }
        context.report({ messageId: "noAccessStateInSetstate", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME4 = "no-array-index-key";
var RULE_FEATURES4 = [
  "CHK"
];
var reactChildrenMethod = ["forEach", "map"];
var iteratorFunctionIndexParamPosition = /* @__PURE__ */ new Map([
  ["every", 1],
  ["filter", 1],
  ["find", 1],
  ["findIndex", 1],
  ["findLast", 1],
  ["findLastIndex", 1],
  ["flatMap", 1],
  ["forEach", 1],
  ["map", 1],
  ["reduce", 2],
  ["reduceRight", 2],
  ["some", 1]
]);
function isReactChildrenMethod(name5) {
  return reactChildrenMethod.some((method) => method === name5);
}
function isUsingReactChildren(context, node) {
  const { importSource = "react" } = shared.unsafeDecodeSettings(context.settings);
  const { callee } = node;
  if (!("property" in callee) || !("object" in callee) || !("name" in callee.property)) {
    return false;
  }
  if (!isReactChildrenMethod(callee.property.name)) {
    return false;
  }
  const initialScope = context.sourceCode.getScope(node);
  if (callee.object.type === types.AST_NODE_TYPES.Identifier && callee.object.name === "Children") {
    return true;
  }
  if (callee.object.type === types.AST_NODE_TYPES.MemberExpression && "name" in callee.object.object) {
    return core.isInitializedFromReact(callee.object.object.name, importSource, initialScope);
  }
  return false;
}
function getMapIndexParamName(context, node) {
  const { callee } = node;
  if (callee.type !== types.AST_NODE_TYPES.MemberExpression) {
    return eff._;
  }
  if (callee.property.type !== types.AST_NODE_TYPES.Identifier) {
    return eff._;
  }
  const { name: name5 } = callee.property;
  if (!iteratorFunctionIndexParamPosition.has(name5)) {
    return eff._;
  }
  const callbackArg = node.arguments[isUsingReactChildren(context, node) ? 1 : 0];
  if (callbackArg == null) {
    return eff._;
  }
  if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.ArrowFunctionExpression, types.AST_NODE_TYPES.FunctionExpression])(callbackArg)) {
    return eff._;
  }
  const { params } = callbackArg;
  const indexParamPosition = iteratorFunctionIndexParamPosition.get(name5);
  if (indexParamPosition == null) {
    return eff._;
  }
  if (params.length < indexParamPosition + 1) {
    return eff._;
  }
  const param = params.at(indexParamPosition);
  return param != null && "name" in param ? param.name : eff._;
}
var no_array_index_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using an item's index in the array as its key",
      [Symbol.for("rule_features")]: RULE_FEATURES4
    },
    messages: {
      noArrayIndexKey: "Do not use item index in the array as its key."
    },
    schema: []
  },
  name: RULE_NAME4,
  create(context) {
    const indexParamNames = [];
    function isArrayIndex(node) {
      return node.type === types.AST_NODE_TYPES.Identifier && indexParamNames.some((name5) => name5 != null && name5 === node.name);
    }
    function isCreateOrCloneElementCall(node) {
      return core.isCreateElementCall(context, node) || core.isCloneElementCall(context, node);
    }
    function getReportDescriptors(node) {
      switch (node.type) {
        // key={bar}
        case types.AST_NODE_TYPES.Identifier: {
          if (indexParamNames.some((name5) => name5 != null && name5 === node.name)) {
            return [{
              messageId: "noArrayIndexKey",
              node
            }];
          }
          return [];
        }
        // key={`foo-${bar}`} or key={'foo' + bar}
        case types.AST_NODE_TYPES.TemplateLiteral:
        case types.AST_NODE_TYPES.BinaryExpression: {
          const descriptors = [];
          const expressions = node.type === types.AST_NODE_TYPES.TemplateLiteral ? node.expressions : getIdentifiersFromBinaryExpression(node);
          for (const expression of expressions) {
            if (isArrayIndex(expression)) {
              descriptors.push({
                messageId: "noArrayIndexKey",
                node: expression
              });
            }
          }
          return descriptors;
        }
        // key={bar.toString()} or key={String(bar)}
        case types.AST_NODE_TYPES.CallExpression: {
          switch (true) {
            // key={bar.toString()}
            case (node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === "toString" && isArrayIndex(node.callee.object)): {
              return [{
                messageId: "noArrayIndexKey",
                node: node.callee.object
              }];
            }
            // key={String(bar)}
            case (node.callee.type === types.AST_NODE_TYPES.Identifier && node.callee.name === "String" && node.arguments[0] != null && isArrayIndex(node.arguments[0])): {
              return [{
                messageId: "noArrayIndexKey",
                node: node.arguments[0]
              }];
            }
          }
        }
      }
      return [];
    }
    return {
      CallExpression(node) {
        indexParamNames.push(getMapIndexParamName(context, node));
        if (node.arguments.length === 0) {
          return;
        }
        if (!isCreateOrCloneElementCall(node)) {
          return;
        }
        const [, props] = node.arguments;
        if (props?.type !== types.AST_NODE_TYPES.ObjectExpression) {
          return;
        }
        for (const prop of props.properties) {
          if (!tsPattern.isMatching({ key: { name: "key" } })(prop)) {
            continue;
          }
          if (!("value" in prop)) {
            continue;
          }
          const descriptors = getReportDescriptors(prop.value);
          for (const descriptor of descriptors) {
            context.report(descriptor);
          }
        }
      },
      "CallExpression:exit"() {
        indexParamNames.pop();
      },
      JSXAttribute(node) {
        if (node.name.name !== "key") {
          return;
        }
        if (indexParamNames.length === 0) {
          return;
        }
        if (node.value?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) {
          return;
        }
        const descriptors = getReportDescriptors(node.value.expression);
        for (const descriptor of descriptors) {
          context.report(descriptor);
        }
      }
    };
  },
  defaultOptions: []
});
function getIdentifiersFromBinaryExpression(side) {
  if (side.type === types.AST_NODE_TYPES.Identifier) {
    return [side];
  }
  if (side.type === types.AST_NODE_TYPES.BinaryExpression) {
    return [
      ...getIdentifiersFromBinaryExpression(side.left),
      ...getIdentifiersFromBinaryExpression(side.right)
    ];
  }
  return [];
}
var RULE_NAME5 = "no-children-count";
var RULE_FEATURES5 = [
  "CHK"
];
var no_children_count_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.count'",
      [Symbol.for("rule_features")]: RULE_FEATURES5
    },
    messages: {
      noChildrenCount: "Using 'Children.count' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME5,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenCount(context, node)) {
          context.report({
            messageId: "noChildrenCount",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME6 = "no-children-for-each";
var RULE_FEATURES6 = [
  "CHK"
];
var no_children_for_each_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.forEach'",
      [Symbol.for("rule_features")]: RULE_FEATURES6
    },
    messages: {
      noChildrenForEach: "Using 'Children.forEach' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME6,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenForEach(context, node)) {
          context.report({
            messageId: "noChildrenForEach",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME7 = "no-children-map";
var RULE_FEATURES7 = [
  "CHK"
];
var no_children_map_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.map'",
      [Symbol.for("rule_features")]: RULE_FEATURES7
    },
    messages: {
      noChildrenMap: "Using 'Children.map' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME7,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenMap(context, node)) {
          context.report({
            messageId: "noChildrenMap",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME8 = "no-children-only";
var RULE_FEATURES8 = [
  "CHK"
];
var no_children_only_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.only'",
      [Symbol.for("rule_features")]: RULE_FEATURES8
    },
    messages: {
      noChildrenOnly: "Using 'Children.only' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME8,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenOnly(context, node)) {
          context.report({
            messageId: "noChildrenOnly",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME9 = "no-children-prop";
var RULE_FEATURES9 = [
  "CHK"
];
var no_children_prop_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing 'children' as props",
      [Symbol.for("rule_features")]: RULE_FEATURES9
    },
    messages: {
      noChildrenProp: "Do not pass 'children' as props."
    },
    schema: []
  },
  name: RULE_NAME9,
  create(context) {
    return {
      JSXElement(node) {
        const attribute = JSX8__namespace.getAttribute(
          "children",
          node.openingElement.attributes,
          context.sourceCode.getScope(node)
        );
        if (attribute != null) {
          context.report({
            messageId: "noChildrenProp",
            node: attribute
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME10 = "no-children-to-array";
var RULE_FEATURES10 = [
  "CHK"
];
var no_children_to_array_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'Children.toArray'",
      [Symbol.for("rule_features")]: RULE_FEATURES10
    },
    messages: {
      noChildrenToArray: "Using 'Children.toArray' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME10,
  create(context) {
    return {
      MemberExpression(node) {
        if (core.isChildrenToArray(context, node)) {
          context.report({
            messageId: "noChildrenToArray",
            node: node.property
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME11 = "no-class-component";
var RULE_FEATURES11 = [
  "CHK"
];
var no_class_component_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using class components",
      [Symbol.for("rule_features")]: RULE_FEATURES11
    },
    messages: {
      noClassComponent: "Do not use class components. Use function components instead."
    },
    schema: []
  },
  name: RULE_NAME11,
  create(context) {
    if (!context.sourceCode.text.includes("Component")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name5 = "anonymous", node: component } of components.values()) {
          if (component.body.body.some((m) => core.isComponentDidCatch(m) || core.isGetDerivedStateFromError(m))) {
            continue;
          }
          context.report({
            messageId: "noClassComponent",
            node: component,
            data: {
              name: name5
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME12 = "no-clone-element";
var RULE_FEATURES12 = [
  "CHK"
];
var no_clone_element_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'cloneElement'",
      [Symbol.for("rule_features")]: RULE_FEATURES12
    },
    messages: {
      noCloneElement: "Using 'cloneElement' is uncommon and can lead to fragile code. Use alternatives instead."
    },
    schema: []
  },
  name: RULE_NAME12,
  create(context) {
    return {
      CallExpression(node) {
        if (!core.isCloneElementCall(context, node)) {
          return;
        }
        context.report({
          messageId: "noCloneElement",
          node
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME13 = "no-comment-textnodes";
var RULE_FEATURES13 = [
  "CHK"
];
var no_comment_textnodes_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow comments from being inserted as text nodes",
      [Symbol.for("rule_features")]: RULE_FEATURES13
    },
    messages: {
      noCommentTextnodes: "Possible misused comment in text node. Comments inside children section of tag should be placed inside braces."
    },
    schema: []
  },
  name: RULE_NAME13,
  create(context) {
    function hasCommentLike(node) {
      if (AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXAttribute, types.AST_NODE_TYPES.JSXExpressionContainer])(node.parent)) {
        return false;
      }
      const rawValue = context.sourceCode.getText(node);
      return /^\s*\/(?:\/|\*)/mu.test(rawValue);
    }
    const visitorFunction = (node) => {
      if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(node.parent)) {
        return;
      }
      if (!hasCommentLike(node)) {
        return;
      }
      if (!node.parent.type.includes("JSX")) {
        return;
      }
      context.report({
        messageId: "noCommentTextnodes",
        node
      });
    };
    return {
      JSXText: visitorFunction,
      Literal: visitorFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME14 = "no-complex-conditional-rendering";
var RULE_FEATURES14 = [
  "CHK"
];
var no_complex_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow complex conditional rendering",
      [Symbol.for("rule_features")]: RULE_FEATURES14
    },
    messages: {
      noComplexConditionalRendering: "Avoid complex conditional rendering. Extract the logic into separate elements or components."
    },
    schema: []
  },
  name: RULE_NAME14,
  create(context) {
    const visitorFunction = (node) => {
      const jsxExpContainer = node.parent?.parent;
      if (!AST11__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer)(jsxExpContainer)) {
        return;
      }
      if (!AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(jsxExpContainer.parent)) {
        return;
      }
      if (!jsxExpContainer.parent.children.includes(jsxExpContainer)) {
        return;
      }
      context.report({
        messageId: "noComplexConditionalRendering",
        node: jsxExpContainer
      });
    };
    return {
      "JSXExpressionContainer > ConditionalExpression > ConditionalExpression": visitorFunction,
      "JSXExpressionContainer > ConditionalExpression > LogicalExpression": visitorFunction,
      "JSXExpressionContainer > LogicalExpression > ConditionalExpression": visitorFunction,
      "JSXExpressionContainer > LogicalExpression[operator='&&'] > LogicalExpression[operator='||']": visitorFunction,
      "JSXExpressionContainer > LogicalExpression[operator='||'] > LogicalExpression[operator='&&']": visitorFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME15 = "no-component-will-mount";
var RULE_FEATURES15 = [
  "CHK",
  "MOD"
];
function isComponentWillMount(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillMount";
}
var no_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of 'componentWillMount' with 'UNSAFE_componentWillMount'",
      [Symbol.for("rule_features")]: RULE_FEATURES15
    },
    fixable: "code",
    messages: {
      noComponentWillMount: "[Deprecated] Use 'UNSAFE_componentWillMount' instead."
    },
    schema: []
  },
  name: RULE_NAME15,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillMount")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillMount(member)) {
              context.report({
                messageId: "noComponentWillMount",
                node: member,
                fix(fixer) {
                  if (!("key" in member)) {
                    return null;
                  }
                  return fixer.replaceText(member.key, "UNSAFE_componentWillMount");
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME16 = "no-component-will-receive-props";
var RULE_FEATURES16 = [
  "CHK",
  "MOD"
];
function isComponentWillUpdate(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillReceiveProps";
}
var no_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of 'componentWillReceiveProps' with 'UNSAFE_componentWillReceiveProps'",
      [Symbol.for("rule_features")]: RULE_FEATURES16
    },
    fixable: "code",
    messages: {
      noComponentWillReceiveProps: "[Deprecated] Use 'UNSAFE_componentWillReceiveProps' instead."
    },
    schema: []
  },
  name: RULE_NAME16,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillReceiveProps")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate(member)) {
              context.report({
                messageId: "noComponentWillReceiveProps",
                node: member,
                fix(fixer) {
                  if (!("key" in member)) {
                    return null;
                  }
                  return fixer.replaceText(member.key, "UNSAFE_componentWillReceiveProps");
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME17 = "no-component-will-update";
var RULE_FEATURES17 = [
  "CHK",
  "MOD"
];
function isComponentWillUpdate2(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of 'componentWillUpdate' with 'UNSAFE_componentWillUpdate'",
      [Symbol.for("rule_features")]: RULE_FEATURES17
    },
    fixable: "code",
    messages: {
      noComponentWillUpdate: "[Deprecated] Use 'UNSAFE_componentWillUpdate' instead."
    },
    schema: []
  },
  name: RULE_NAME17,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isComponentWillUpdate2(member)) {
              context.report({
                messageId: "noComponentWillUpdate",
                node: member,
                fix(fixer) {
                  if (!("key" in member)) {
                    return null;
                  }
                  return fixer.replaceText(member.key, "UNSAFE_componentWillUpdate");
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME18 = "no-context-provider";
var RULE_FEATURES18 = [
  "CHK",
  "MOD"
];
var no_context_provider_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of '<Context.Provider>' with '<Context>'",
      [Symbol.for("rule_features")]: RULE_FEATURES18
    },
    fixable: "code",
    messages: {
      noContextProvider: "In React 19, you can render '<Context>' as a provider instead of '<Context.Provider>'."
    },
    schema: []
  },
  name: RULE_NAME18,
  create(context) {
    if (!context.sourceCode.text.includes("Provider")) return {};
    const { version: version2 } = shared.getSettingsFromContext(context);
    if (compareVersions.compare(version2, "19.0.0", "<")) return {};
    return {
      JSXElement(node) {
        const fullName = JSX8__namespace.getElementType(node);
        const parts = fullName.split(".");
        const selfName = parts.pop();
        const contextFullName = parts.join(".");
        const contextSelfName = parts.pop();
        if (selfName !== "Provider") return;
        context.report({
          messageId: "noContextProvider",
          node,
          fix(fixer) {
            if (contextSelfName == null) return null;
            if (!core.isComponentNameLoose(contextSelfName)) return null;
            const openingElement = node.openingElement;
            const closingElement = node.closingElement;
            if (closingElement == null) {
              return fixer.replaceText(openingElement.name, contextFullName);
            }
            return [
              fixer.replaceText(openingElement.name, contextFullName),
              fixer.replaceText(closingElement.name, contextFullName)
            ];
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME19 = "no-create-ref";
var RULE_FEATURES19 = [
  "CHK"
];
var no_create_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'createRef' in function components",
      [Symbol.for("rule_features")]: RULE_FEATURES19
    },
    messages: {
      noCreateRef: "[Deprecated] Use 'useRef' instead."
    },
    schema: []
  },
  name: RULE_NAME19,
  create(context) {
    return {
      CallExpression(node) {
        if (core.isCreateRefCall(context, node) && AST11__namespace.findParentNode(node, core.isClassComponent) == null) {
          context.report({ messageId: "noCreateRef", node });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME20 = "no-default-props";
var RULE_FEATURES20 = [
  "CHK"
];
var no_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'defaultProps' property in components",
      [Symbol.for("rule_features")]: RULE_FEATURES20
    },
    messages: {
      noDefaultProps: "[Deprecated] Use ES6 default parameters instead."
    },
    schema: []
  },
  name: RULE_NAME20,
  create(context) {
    if (!context.sourceCode.text.includes("defaultProps")) {
      return {};
    }
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== types.AST_NODE_TYPES.MemberExpression) {
          return;
        }
        const { object, property } = node.left;
        if (object.type !== types.AST_NODE_TYPES.Identifier) {
          return;
        }
        if (property.type !== types.AST_NODE_TYPES.Identifier || property.name !== "defaultProps") {
          return;
        }
        if (!core.isComponentNameLoose(object.name)) {
          return;
        }
        const variable = VAR__namespace.findVariable(object.name, context.sourceCode.getScope(node));
        const variableNode = VAR__namespace.getVariableInitNode(variable, 0);
        if (variableNode == null) return;
        if (!AST11__namespace.isFunction(variableNode) && !core.isClassComponent(variableNode)) return;
        context.report({ messageId: "noDefaultProps", node: property });
      },
      PropertyDefinition(node) {
        if (!core.isClassComponent(node.parent.parent)) {
          return;
        }
        if (!node.static || node.key.type !== types.AST_NODE_TYPES.Identifier || node.key.name !== "defaultProps") {
          return;
        }
        context.report({ messageId: "noDefaultProps", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME21 = "no-direct-mutation-state";
var RULE_FEATURES21 = [
  "CHK"
];
function isConstructorFunction(node) {
  return AST11__namespace.isOneOf([types.AST_NODE_TYPES.FunctionDeclaration, types.AST_NODE_TYPES.FunctionExpression])(node) && AST11__namespace.isMethodOrProperty(node.parent) && node.parent.key.type === types.AST_NODE_TYPES.Identifier && node.parent.key.name === "constructor";
}
var no_direct_mutation_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow direct mutation of state",
      [Symbol.for("rule_features")]: RULE_FEATURES21
    },
    messages: {
      noDirectMutationState: "Do not mutate state directly. Use 'setState()' instead."
    },
    schema: []
  },
  name: RULE_NAME21,
  create(context) {
    return {
      AssignmentExpression(node) {
        if (!core.isAssignmentToThisState(node)) {
          return;
        }
        const parentClass = AST11__namespace.findParentNode(
          node,
          AST11__namespace.isOneOf([
            types.AST_NODE_TYPES.ClassDeclaration,
            types.AST_NODE_TYPES.ClassExpression
          ])
        );
        if (parentClass == null) return;
        if (core.isClassComponent(parentClass) && context.sourceCode.getScope(node).block !== AST11__namespace.findParentNode(node, isConstructorFunction)) {
          context.report({
            messageId: "noDirectMutationState",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME22 = "no-duplicate-jsx-props";
var RULE_FEATURES22 = [
  "CHK"
];
var no_duplicate_jsx_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate props",
      [Symbol.for("rule_features")]: RULE_FEATURES22
    },
    messages: {
      noDuplicateJsxProps: "This JSX property is assigned multiple times."
    },
    schema: []
  },
  name: RULE_NAME22,
  create(context) {
    return {
      JSXOpeningElement(node) {
        const props = [];
        for (const attr of node.attributes) {
          if (attr.type === types.AST_NODE_TYPES.JSXSpreadAttribute) {
            continue;
          }
          const name5 = attr.name.name;
          if (typeof name5 !== "string") {
            continue;
          }
          if (!props.includes(name5)) {
            props.push(name5);
            continue;
          }
          context.report({
            messageId: "noDuplicateJsxProps",
            node: attr
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME23 = "no-duplicate-key";
var RULE_FEATURES23 = [
  "CHK"
];
var no_duplicate_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys when rendering list",
      [Symbol.for("rule_features")]: RULE_FEATURES23
    },
    messages: {
      noDuplicateKey: "A key must be unique. '{{value}}' is duplicated."
    },
    schema: []
  },
  name: RULE_NAME23,
  create(context) {
    if (!context.sourceCode.getText().includes("key=")) {
      return {};
    }
    const keyedEntries = /* @__PURE__ */ new Map();
    function isKeyValueEqual(a, b) {
      const aValue = a.value;
      const bValue = b.value;
      if (aValue == null || bValue == null) {
        return false;
      }
      return AST11__namespace.isNodeEqual(aValue, bValue);
    }
    return {
      "JSXAttribute[name.name='key']"(node) {
        const jsxElement = node.parent.parent;
        switch (jsxElement.parent.type) {
          case types.AST_NODE_TYPES.ArrayExpression:
          case types.AST_NODE_TYPES.JSXElement:
          case types.AST_NODE_TYPES.JSXFragment: {
            const root = jsxElement.parent;
            const prevKeys = keyedEntries.get(root)?.keys ?? [];
            keyedEntries.set(root, {
              hasDuplicate: prevKeys.some((prevKey) => isKeyValueEqual(prevKey, node)),
              keys: [...prevKeys, node],
              root: jsxElement.parent
            });
            break;
          }
          default: {
            const call = AST11__namespace.findParentNode(jsxElement, AST11__namespace.isMapCallLoose);
            const iter = AST11__namespace.findParentNode(jsxElement, (n) => n === call || AST11__namespace.isFunction(n));
            if (!AST11__namespace.isFunction(iter)) return;
            const arg0 = call?.arguments[0];
            if (call == null || arg0 == null) return;
            if (AST11__namespace.getEcmaExpression(arg0) !== iter) {
              return;
            }
            keyedEntries.set(call, {
              hasDuplicate: node.value?.type === types.AST_NODE_TYPES.Literal,
              keys: [node],
              root: call
            });
          }
        }
      },
      "Program:exit"() {
        for (const { hasDuplicate, keys } of keyedEntries.values()) {
          if (!hasDuplicate) {
            continue;
          }
          for (const key of keys) {
            context.report({
              messageId: "noDuplicateKey",
              node: key,
              data: {
                value: context.sourceCode.getText(key)
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME24 = "no-forward-ref";
var RULE_FEATURES24 = [
  "CHK",
  "MOD"
];
var no_forward_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of 'forwardRef' with passing 'ref' as a prop",
      [Symbol.for("rule_features")]: RULE_FEATURES24
    },
    fixable: "code",
    messages: {
      noForwardRef: "In React 19, 'forwardRef' is no longer necessary. Pass 'ref' as a prop instead."
    },
    schema: []
  },
  name: RULE_NAME24,
  create(context) {
    if (!context.sourceCode.text.includes("forwardRef")) {
      return {};
    }
    const { version: version2 } = shared.getSettingsFromContext(context);
    if (compareVersions.compare(version2, "19.0.0", "<")) {
      return {};
    }
    return {
      CallExpression(node) {
        if (!core.isForwardRefCall(context, node)) {
          return;
        }
        context.report({
          messageId: "noForwardRef",
          node,
          fix: getFix(context, node)
        });
      }
    };
  },
  defaultOptions: []
});
function getFix(context, node) {
  return (fixer) => {
    const [componentNode] = node.arguments;
    if (componentNode == null || !AST11__namespace.isFunction(componentNode)) {
      return [];
    }
    return [
      // unwrap component from forwardRef call
      fixer.removeRange([node.range[0], componentNode.range[0]]),
      fixer.removeRange([componentNode.range[1], node.range[1]]),
      // update component props and ref arguments to match the new signature
      ...getComponentPropsFixes(
        context,
        fixer,
        componentNode,
        node.typeArguments?.params ?? []
      )
    ];
  };
}
function getComponentPropsFixes(context, fixer, node, typeArguments) {
  const getText = (node2) => context.sourceCode.getText(node2);
  const [arg0, arg1] = node.params;
  const [typeArg0, typeArg1] = typeArguments;
  if (arg0 == null) {
    return [];
  }
  const fixedArg0Text = tsPattern.match(arg0).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => `...${n.name}`).with({ type: types.AST_NODE_TYPES.ObjectPattern }, (n) => n.properties.map(getText).join(", ")).otherwise(() => eff._);
  const fixedArg1Text = tsPattern.match(arg1).with(tsPattern.P.nullish, () => "ref").with({ type: types.AST_NODE_TYPES.Identifier, name: "ref" }, () => "ref").with({ type: types.AST_NODE_TYPES.Identifier, name: tsPattern.P.string }, (n) => `ref: ${n.name}`).otherwise(() => eff._);
  if (fixedArg0Text == null || fixedArg1Text == null) {
    return [];
  }
  if (typeArg0 == null || typeArg1 == null) {
    return [
      fixer.replaceText(
        arg0,
        [
          "{",
          fixedArg1Text + ",",
          fixedArg0Text,
          "}"
        ].join(" ")
      ),
      ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]
    ];
  }
  const typeArg0Text = getText(typeArg0);
  const typeArg1Text = getText(typeArg1);
  return [
    fixer.replaceText(
      arg0,
      [
        "{",
        fixedArg1Text + ",",
        fixedArg0Text,
        "}:",
        typeArg1Text,
        "&",
        "{",
        `ref?:`,
        `React.RefObject<${typeArg0Text} | null>`,
        "}"
      ].join(" ")
    ),
    ...arg1 == null ? [] : [fixer.remove(arg1), fixer.removeRange([arg0.range[1], arg1.range[0]])]
  ];
}
var RULE_NAME25 = "no-implicit-key";
var RULE_FEATURES25 = [
  "CHK"
];
var no_implicit_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow implicit 'key' props",
      [Symbol.for("rule_features")]: RULE_FEATURES25
    },
    messages: {
      noImplicitKey: "Do not use implicit 'key' props."
    },
    schema: []
  },
  name: RULE_NAME25,
  create(context) {
    return {
      JSXOpeningElement(node) {
        const initialScope = context.sourceCode.getScope(node);
        const keyPropFound = JSX8__namespace.getAttribute("key", node.attributes, initialScope);
        const keyPropOnElement = node.attributes.some(
          (n) => n.type === types.AST_NODE_TYPES.JSXAttribute && n.name.type === types.AST_NODE_TYPES.JSXIdentifier && n.name.name === "key"
        );
        if (keyPropFound != null && !keyPropOnElement) {
          context.report({ messageId: "noImplicitKey", node: keyPropFound });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME26 = "no-leaked-conditional-rendering";
var RULE_FEATURES26 = [
  "CHK",
  "TSC"
];
var tsHelpers = {
  isAnyType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.TypeParameter | ts__default.default.TypeFlags.Any),
  isBigIntType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.BigIntLike),
  isBooleanType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.BooleanLike),
  isEnumType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.EnumLike),
  isFalsyBigIntType: (type) => type.isLiteral() && tsPattern.isMatching({ value: { base10Value: "0" } }, type),
  isFalsyNumberType: (type) => type.isNumberLiteral() && type.value === 0,
  isFalsyStringType: (type) => type.isStringLiteral() && type.value === "",
  isNeverType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.Never),
  isNullishType: (type) => tsApiUtils.isTypeFlagSet(
    type,
    ts__default.default.TypeFlags.Null | ts__default.default.TypeFlags.Undefined | ts__default.default.TypeFlags.VoidLike
  ),
  isNumberType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.NumberLike),
  isObjectType: (type) => !tsApiUtils.isTypeFlagSet(
    type,
    ts__default.default.TypeFlags.Null | ts__default.default.TypeFlags.Undefined | ts__default.default.TypeFlags.VoidLike | ts__default.default.TypeFlags.BooleanLike | ts__default.default.TypeFlags.StringLike | ts__default.default.TypeFlags.NumberLike | ts__default.default.TypeFlags.BigIntLike | ts__default.default.TypeFlags.TypeParameter | ts__default.default.TypeFlags.Any | ts__default.default.TypeFlags.Unknown | ts__default.default.TypeFlags.Never
  ),
  isStringType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.StringLike),
  isTruthyBigIntType: (type) => type.isLiteral() && tsPattern.isMatching({ value: { base10Value: tsPattern.P.not("0") } }, type),
  isTruthyNumberType: (type) => type.isNumberLiteral() && type.value !== 0,
  isTruthyStringType: (type) => type.isStringLiteral() && type.value !== "",
  isUnknownType: (type) => tsApiUtils.isTypeFlagSet(type, ts__default.default.TypeFlags.Unknown)
};
function inspectVariantTypes(types) {
  const variantTypes = /* @__PURE__ */ new Set();
  if (types.some(tsHelpers.isUnknownType)) {
    variantTypes.add("unknown");
    return variantTypes;
  }
  if (types.some(tsHelpers.isNullishType)) {
    variantTypes.add("nullish");
  }
  const booleans = types.filter(tsHelpers.isBooleanType);
  switch (true) {
    case (booleans.length === 1 && booleans[0] != null): {
      const first = booleans[0];
      if (tsApiUtils.isTrueLiteralType(first)) {
        variantTypes.add("truthy boolean");
      } else if (tsApiUtils.isFalseLiteralType(first)) {
        variantTypes.add("falsy boolean");
      }
      break;
    }
    case booleans.length === 2: {
      variantTypes.add("boolean");
      break;
    }
  }
  const strings = types.filter(tsHelpers.isStringType);
  if (strings.length > 0) {
    const evaluated = tsPattern.match(strings).when((types2) => types2.every(tsHelpers.isTruthyStringType), () => "truthy string").when((types2) => types2.every(tsHelpers.isFalsyStringType), () => "falsy string").otherwise(() => "string");
    variantTypes.add(evaluated);
  }
  const bigints = types.filter(tsHelpers.isBigIntType);
  if (bigints.length > 0) {
    const evaluated = tsPattern.match(bigints).when((types2) => types2.every(tsHelpers.isTruthyBigIntType), () => "truthy bigint").when((types2) => types2.every(tsHelpers.isFalsyBigIntType), () => "falsy bigint").otherwise(() => "bigint");
    variantTypes.add(evaluated);
  }
  const numbers = types.filter(tsHelpers.isNumberType);
  if (numbers.length > 0) {
    const evaluated = tsPattern.match(numbers).when((types2) => types2.every(tsHelpers.isTruthyNumberType), () => "truthy number").when((types2) => types2.every(tsHelpers.isFalsyNumberType), () => "falsy number").otherwise(() => "number");
    variantTypes.add(evaluated);
  }
  if (types.some(tsHelpers.isEnumType)) {
    variantTypes.add("enum");
  }
  if (types.some(tsHelpers.isObjectType)) {
    variantTypes.add("object");
  }
  if (types.some(tsHelpers.isAnyType)) {
    variantTypes.add("any");
  }
  if (types.some(tsHelpers.isNeverType)) {
    variantTypes.add("never");
  }
  return variantTypes;
}
var no_leaked_conditional_rendering_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow problematic leaked values from being rendered",
      [Symbol.for("rule_features")]: RULE_FEATURES26
    },
    messages: {
      noLeakedConditionalRendering: "Potential leaked value {{value}} that might cause unintentionally rendered values or rendering crashes."
    },
    schema: []
  },
  name: RULE_NAME26,
  create(context) {
    if (!context.sourceCode.text.includes("&&") && !context.sourceCode.text.includes("?")) {
      return {};
    }
    const { version: version2 } = shared.getSettingsFromContext(context);
    const allowedVariants = [
      "any",
      "boolean",
      "nullish",
      "object",
      "falsy boolean",
      "truthy bigint",
      "truthy boolean",
      "truthy number",
      "truthy string",
      ...compareVersions.compare(version2, "18.0.0", "<") ? [] : ["string", "falsy string"]
    ];
    const services = utils.ESLintUtils.getParserServices(context, false);
    function getReportDescriptor(node) {
      if (node == null) return eff._;
      return tsPattern.match(node).when(AST11__namespace.isJSX, () => eff._).with({ type: types.AST_NODE_TYPES.LogicalExpression, operator: "&&" }, ({ left, right }) => {
        const isLeftUnaryNot = left.type === types.AST_NODE_TYPES.UnaryExpression && left.operator === "!";
        if (isLeftUnaryNot) {
          return getReportDescriptor(right);
        }
        const initialScope = context.sourceCode.getScope(left);
        const isLeftNan = left.type === types.AST_NODE_TYPES.Identifier && left.name === "NaN" || VAR__namespace.toStaticValue({ kind: "lazy", node: left, initialScope }).value === "NaN";
        if (isLeftNan) {
          return {
            messageId: "noLeakedConditionalRendering",
            node: left,
            data: { value: context.sourceCode.getText(left) }
          };
        }
        const leftType = typeUtils.getConstrainedTypeAtLocation(services, left);
        const leftTypeVariants = inspectVariantTypes(tsApiUtils.unionTypeParts(leftType));
        const isLeftValid = Array.from(leftTypeVariants.values()).every((type) => allowedVariants.some((allowed) => allowed === type));
        if (isLeftValid) {
          return getReportDescriptor(right);
        }
        return {
          messageId: "noLeakedConditionalRendering",
          node: left,
          data: { value: context.sourceCode.getText(left) }
        };
      }).with({ type: types.AST_NODE_TYPES.ConditionalExpression }, ({ alternate, consequent }) => {
        return getReportDescriptor(consequent) ?? getReportDescriptor(alternate);
      }).with({ type: types.AST_NODE_TYPES.Identifier }, (n) => {
        const variable = VAR__namespace.findVariable(n.name, context.sourceCode.getScope(n));
        const initExpression = tsPattern.match(variable?.defs.at(0)?.node).with({ init: tsPattern.P.select({ type: tsPattern.P.not(types.AST_NODE_TYPES.VariableDeclaration) }) }, eff.identity).otherwise(() => eff._);
        return getReportDescriptor(initExpression);
      }).otherwise(() => eff._);
    }
    const visitorFunction = (node) => {
      const descriptor = getReportDescriptor(node);
      if (descriptor == null) return;
      context.report(descriptor);
    };
    return {
      "JSXExpressionContainer > ConditionalExpression": visitorFunction,
      "JSXExpressionContainer > LogicalExpression": visitorFunction
    };
  },
  defaultOptions: []
});
var RULE_NAME27 = "no-missing-component-display-name";
var RULE_FEATURES27 = [
  "CHK"
];
var no_missing_component_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'displayName' for 'memo' and 'forwardRef' components",
      [Symbol.for("rule_features")]: RULE_FEATURES27
    },
    messages: {
      noMissingComponentDisplayName: "Add missing 'displayName' for component."
    },
    schema: []
  },
  name: RULE_NAME27,
  create(context) {
    if (!context.sourceCode.text.includes("memo") && !context.sourceCode.text.includes("forwardRef")) {
      return {};
    }
    const {
      ctx,
      listeners
    } = core.useComponentCollector(
      context,
      {
        collectDisplayName: true,
        collectHookCalls: false,
        hint: core.DEFAULT_COMPONENT_HINT
      }
    );
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: node2, displayName, flag } of components.values()) {
          const isMemoOrForwardRef = (flag & (core.ERComponentFlag.ForwardRef | core.ERComponentFlag.Memo)) > 0n;
          if (AST11__namespace.getFunctionIdentifier(node2) != null) {
            continue;
          }
          if (!isMemoOrForwardRef) {
            continue;
          }
          if (displayName == null) {
            context.report({
              messageId: "noMissingComponentDisplayName",
              node: node2
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME28 = "no-missing-context-display-name";
var RULE_FEATURES28 = [
  "CHK"
];
var no_missing_context_display_name_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'displayName' for contexts.",
      [Symbol.for("rule_features")]: RULE_FEATURES28
    },
    messages: {
      noMissingContextDisplayName: "Add missing 'displayName' for context."
    },
    schema: []
  },
  name: RULE_NAME28,
  create(context) {
    if (!context.sourceCode.text.includes("createContext")) return {};
    const createCalls = [];
    const displayNameAssignments = [];
    return {
      CallExpression(node) {
        if (!core.isCreateContextCall(context, node)) return;
        createCalls.push(node);
      },
      [core.DISPLAY_NAME_ASSIGNMENT_SELECTOR](node) {
        displayNameAssignments.push(node);
      },
      "Program:exit"() {
        for (const call of createCalls) {
          const id = core.getInstanceId(call);
          if (id == null) {
            context.report({
              messageId: "noMissingContextDisplayName",
              node: call
            });
            continue;
          }
          const hasDisplayNameAssignment = displayNameAssignments.some((node) => {
            const left = node.left;
            if (left.type !== types.AST_NODE_TYPES.MemberExpression) return false;
            const object = left.object;
            return core.isInstanceIdEqual(context, id, object);
          });
          if (!hasDisplayNameAssignment) {
            context.report({
              messageId: "noMissingContextDisplayName",
              node: call
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME29 = "no-missing-key";
var RULE_FEATURES29 = [
  "CHK"
];
var no_missing_key_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require 'key' when rendering list",
      [Symbol.for("rule_features")]: RULE_FEATURES29
    },
    messages: {
      missingKey: "Missing 'key' for element when rendering list.",
      unexpectedFragmentSyntax: "Use fragment component instead of '<>' because it does not support `key`."
    },
    schema: []
  },
  name: RULE_NAME29,
  create(context) {
    const state = { isWithinChildrenToArray: false };
    function checkIteratorElement(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.JSXElement: {
          const initialScope = context.sourceCode.getScope(node);
          if (!JSX8__namespace.hasAttribute("key", node.openingElement.attributes, initialScope)) {
            return {
              messageId: "missingKey",
              node
            };
          }
          return null;
        }
        case types.AST_NODE_TYPES.JSXFragment: {
          return {
            messageId: "unexpectedFragmentSyntax",
            node
          };
        }
        default:
          return null;
      }
    }
    function checkExpression(node) {
      switch (node.type) {
        case types.AST_NODE_TYPES.ConditionalExpression:
          if ("consequent" in node) {
            return checkIteratorElement(node.consequent) ?? checkIteratorElement(node.alternate);
          }
          return null;
        case types.AST_NODE_TYPES.JSXElement:
        case types.AST_NODE_TYPES.JSXFragment:
          return checkIteratorElement(node);
        case types.AST_NODE_TYPES.LogicalExpression:
          if ("left" in node) {
            return checkIteratorElement(node.left) ?? checkIteratorElement(node.right);
          }
          return null;
        default:
          return null;
      }
    }
    function checkBlockStatement(node) {
      const descriptors = [];
      for (const statement of AST11__namespace.getNestedReturnStatements(node)) {
        if (statement.argument == null) {
          continue;
        }
        const descriptor = checkIteratorElement(statement.argument);
        if (descriptor != null) {
          descriptors.push(descriptor);
        }
      }
      return descriptors;
    }
    return {
      ArrayExpression(node) {
        if (state.isWithinChildrenToArray) {
          return;
        }
        const elements = node.elements.filter(AST11__namespace.is(types.AST_NODE_TYPES.JSXElement));
        if (elements.length === 0) {
          return;
        }
        const initialScope = context.sourceCode.getScope(node);
        for (const element of elements) {
          if (!JSX8__namespace.hasAttribute("key", element.openingElement.attributes, initialScope)) {
            context.report({
              messageId: "missingKey",
              node: element
            });
          }
        }
      },
      CallExpression(node) {
        state.isWithinChildrenToArray ||= core.isChildrenToArrayCall(context, node);
        if (state.isWithinChildrenToArray) {
          return;
        }
        const isMapCallLike = AST11__namespace.isMapCallLoose(node);
        if (!isMapCallLike && !isArrayFromCall(node)) {
          return;
        }
        const fn = node.arguments[isMapCallLike ? 0 : 1];
        if (fn?.type !== types.AST_NODE_TYPES.ArrowFunctionExpression && fn?.type !== types.AST_NODE_TYPES.FunctionExpression) {
          return;
        }
        if (fn.body.type === types.AST_NODE_TYPES.BlockStatement) {
          for (const descriptor2 of checkBlockStatement(fn.body)) {
            context.report(descriptor2);
          }
          return;
        }
        const descriptor = checkExpression(fn.body);
        if (descriptor != null) {
          context.report(descriptor);
        }
      },
      "CallExpression:exit"(node) {
        if (!core.isChildrenToArrayCall(context, node)) {
          return;
        }
        state.isWithinChildrenToArray = false;
      },
      JSXFragment(node) {
        if (state.isWithinChildrenToArray) {
          return;
        }
        if (node.parent.type === types.AST_NODE_TYPES.ArrayExpression) {
          context.report({
            messageId: "unexpectedFragmentSyntax",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
function isArrayFromCall(node) {
  return node.type === types.AST_NODE_TYPES.CallExpression && node.callee.type === types.AST_NODE_TYPES.MemberExpression && node.callee.property.type === types.AST_NODE_TYPES.Identifier && node.callee.property.name === "from";
}
var RULE_NAME30 = "no-nested-components";
var RULE_FEATURES30 = [
  "CHK"
];
var no_nested_components_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable nested components",
      [Symbol.for("rule_features")]: RULE_FEATURES30
    },
    messages: {
      nestedComponent: "Do not nest components inside other components. Move it to the top level.",
      nestedComponentInProps: "Do not nest components inside props. Move it to the top level or pass it as a prop."
    },
    schema: []
  },
  name: RULE_NAME30,
  create(context) {
    const hint = core.ERComponentHint.SkipMapCallback | core.ERComponentHint.SkipNullLiteral | core.ERComponentHint.SkipUndefined | core.ERComponentHint.SkipBooleanLiteral | core.ERComponentHint.SkipStringLiteral | core.ERComponentHint.SkipNumberLiteral | core.ERComponentHint.StrictLogical | core.ERComponentHint.StrictConditional;
    const collector = core.useComponentCollector(context, { hint });
    const collectorLegacy = core.useComponentCollectorLegacy();
    return {
      ...collector.listeners,
      ...collectorLegacy.listeners,
      "Program:exit"(node) {
        const functionComponents = [
          ...collector.ctx.getAllComponents(node).values()
        ];
        const classComponents = [
          ...collectorLegacy.ctx.getAllComponents(node).values()
        ];
        const isFunctionComponent = (node2) => {
          return AST11__namespace.isFunction(node2) && functionComponents.some((component) => component.node === node2);
        };
        const isClassComponent11 = (node2) => {
          return AST11__namespace.isClass(node2) && classComponents.some((component) => component.node === node2);
        };
        for (const { name: name5, node: component } of functionComponents) {
          if (core.isDirectValueOfRenderPropertyLoose(component)) {
            continue;
          }
          if (name5 == null) {
            continue;
          }
          const isInsideProperty = component.parent.type === types.AST_NODE_TYPES.Property;
          const isInsideJSXPropValue = component.parent.type === types.AST_NODE_TYPES.JSXAttribute || JSX8__namespace.findParentAttribute(node, (n) => n.value?.type === types.AST_NODE_TYPES.JSXExpressionContainer) != null;
          if (isInsideJSXPropValue) {
            if (!core.isDeclaredInRenderPropLoose(component)) {
              context.report({
                messageId: "nestedComponentInProps",
                node: component,
                data: {
                  name: name5
                }
              });
            }
            continue;
          }
          if (isInsideCreateElementProps(context, component)) {
            context.report({
              messageId: "nestedComponentInProps",
              node: component,
              data: {
                name: name5
              }
            });
            continue;
          }
          const parentComponent = AST11__namespace.findParentNode(component, isFunctionComponent);
          const isParentComponentNotDirectValueOfRenderProperty = parentComponent != null && !core.isDirectValueOfRenderPropertyLoose(parentComponent);
          if (isParentComponentNotDirectValueOfRenderProperty) {
            context.report({
              messageId: isInsideProperty ? "nestedComponentInProps" : "nestedComponent",
              node: component,
              data: {
                name: name5
              }
            });
            continue;
          }
          if (core.isInsideRenderMethod(component)) {
            context.report({
              messageId: "nestedComponent",
              node: component,
              data: {
                name: name5
              }
            });
          }
        }
        for (const { name: name5 = "unknown", node: component } of classComponents) {
          if (AST11__namespace.findParentNode(component, (n) => isClassComponent11(n) || isFunctionComponent(n)) == null) {
            continue;
          }
          context.report({
            messageId: "nestedComponent",
            node: component,
            data: {
              name: name5
            }
          });
        }
      }
    };
  },
  defaultOptions: []
});
function isInsideCreateElementProps(context, node) {
  const call = AST11__namespace.findParentNode(node, core.isCreateElementCall(context));
  if (call == null) return false;
  const prop = AST11__namespace.findParentNode(node, AST11__namespace.is(types.AST_NODE_TYPES.ObjectExpression));
  if (prop == null) return false;
  return prop === call.arguments[1];
}
var RULE_NAME31 = "no-prop-types";
var RULE_FEATURES31 = [
  "CHK"
];
var no_prop_types_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'propTypes' property in components",
      [Symbol.for("rule_features")]: RULE_FEATURES31
    },
    messages: {
      noPropTypes: "[Deprecated] Use TypeScript or another type-checking solution instead."
    },
    schema: []
  },
  name: RULE_NAME31,
  create(context) {
    if (!context.sourceCode.text.includes("propTypes")) {
      return {};
    }
    return {
      AssignmentExpression(node) {
        if (node.operator !== "=" || node.left.type !== types.AST_NODE_TYPES.MemberExpression) {
          return;
        }
        const { object, property } = node.left;
        if (object.type !== types.AST_NODE_TYPES.Identifier) {
          return;
        }
        if (property.type !== types.AST_NODE_TYPES.Identifier || property.name !== "propTypes") {
          return;
        }
        if (!core.isComponentNameLoose(object.name)) {
          return;
        }
        const variable = VAR__namespace.findVariable(object.name, context.sourceCode.getScope(node));
        const variableNode = VAR__namespace.getVariableInitNode(variable, 0);
        if (variableNode != null && (AST11__namespace.isFunction(variableNode) || core.isClassComponent(variableNode))) {
          context.report({ messageId: "noPropTypes", node: property });
        }
      },
      PropertyDefinition(node) {
        if (!core.isClassComponent(node.parent.parent)) {
          return;
        }
        if (!node.static || node.key.type !== types.AST_NODE_TYPES.Identifier || node.key.name !== "propTypes") {
          return;
        }
        context.report({ messageId: "noPropTypes", node });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME32 = "no-redundant-should-component-update";
var RULE_FEATURES32 = [
  "CHK"
];
function isShouldComponentUpdate(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "shouldComponentUpdate";
}
var no_redundant_should_component_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'shouldComponentUpdate' in class component extends 'React.PureComponent'",
      [Symbol.for("rule_features")]: RULE_FEATURES32
    },
    messages: {
      noRedundantShouldComponentUpdate: "'{{componentName}}' does not need 'shouldComponentUpdate' when extending 'React.PureComponent'."
    },
    schema: []
  },
  name: RULE_NAME32,
  create(context) {
    if (!context.sourceCode.text.includes("shouldComponentUpdate")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { name: name5 = "PureComponent", node: component, flag } of components.values()) {
          if ((flag & core.ERComponentFlag.PureComponent) === 0n) {
            continue;
          }
          const { body } = component.body;
          for (const member of body) {
            if (isShouldComponentUpdate(member)) {
              context.report({
                messageId: "noRedundantShouldComponentUpdate",
                node: member,
                data: {
                  componentName: name5
                }
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME33 = "no-set-state-in-component-did-mount";
var RULE_FEATURES33 = [
  "CHK"
];
function isComponentDidMount(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidMount";
}
var no_set_state_in_component_did_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidMount'",
      [Symbol.for("rule_features")]: RULE_FEATURES33
    },
    messages: {
      noSetStateInComponentDidMount: "Do not call `this.setState` in `componentDidMount` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME33,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidMount")) {
      return {};
    }
    return {
      CallExpression(node) {
        if (!core.isThisSetState(node)) {
          return;
        }
        const clazz = AST11__namespace.findParentNode(node, core.isClassComponent);
        const method = AST11__namespace.findParentNode(node, (n) => n === clazz || isComponentDidMount(n));
        if (clazz == null || method == null || method === clazz) return;
        const methodScope = context.sourceCode.getScope(method);
        const upperScope = context.sourceCode.getScope(node).upper;
        if (method.parent === clazz.body && upperScope === methodScope) {
          context.report({
            messageId: "noSetStateInComponentDidMount",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME34 = "no-set-state-in-component-did-update";
var RULE_FEATURES34 = [
  "CHK"
];
function isComponentDidUpdate(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentDidUpdate";
}
var no_set_state_in_component_did_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentDidUpdate'",
      [Symbol.for("rule_features")]: RULE_FEATURES34
    },
    messages: {
      noSetStateInComponentDidUpdate: "Do not call `this.setState` in `componentDidUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME34,
  create(context) {
    if (!context.sourceCode.text.includes("componentDidUpdate")) {
      return {};
    }
    return {
      CallExpression(node) {
        if (!core.isThisSetState(node)) {
          return;
        }
        const clazz = AST11__namespace.findParentNode(node, core.isClassComponent);
        const method = AST11__namespace.findParentNode(node, (n) => n === clazz || isComponentDidUpdate(n));
        if (clazz == null || method == null || method === clazz) return;
        const methodScope = context.sourceCode.getScope(method);
        const upperScope = context.sourceCode.getScope(node).upper;
        if (method.parent === clazz.body && upperScope === methodScope) {
          context.report({
            messageId: "noSetStateInComponentDidUpdate",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME35 = "no-set-state-in-component-will-update";
var RULE_FEATURES35 = [
  "CHK"
];
function isComponentWillUpdate3(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "componentWillUpdate";
}
var no_set_state_in_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'setState' in 'componentWillUpdate'",
      [Symbol.for("rule_features")]: RULE_FEATURES35
    },
    messages: {
      noSetStateInComponentWillUpdate: "Do not call `this.setState` in `componentWillUpdate` outside of functions, such as callbacks."
    },
    schema: []
  },
  name: RULE_NAME35,
  create(context) {
    if (!context.sourceCode.text.includes("componentWillUpdate")) {
      return {};
    }
    return {
      CallExpression(node) {
        if (!core.isThisSetState(node)) {
          return;
        }
        const clazz = AST11__namespace.findParentNode(node, core.isClassComponent);
        const method = AST11__namespace.findParentNode(node, (n) => n === clazz || isComponentWillUpdate3(n));
        if (clazz == null || method == null || method === clazz) return;
        const methodScope = context.sourceCode.getScope(method);
        const upperScope = context.sourceCode.getScope(node).upper;
        if (method.parent === clazz.body && upperScope === methodScope) {
          context.report({
            messageId: "noSetStateInComponentWillUpdate",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME36 = "no-string-refs";
var RULE_FEATURES36 = [
  "CHK"
];
function containsStringLiteral({ value }) {
  return value?.type === types.AST_NODE_TYPES.Literal && typeof value.value === "string";
}
function containsStringExpressionContainer({ value }) {
  if (value?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) {
    return false;
  }
  if (value.expression.type === types.AST_NODE_TYPES.Literal) {
    return typeof value.expression.value === "string";
  }
  return value.expression.type === types.AST_NODE_TYPES.TemplateLiteral;
}
var no_string_refs_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using deprecated string refs",
      [Symbol.for("rule_features")]: RULE_FEATURES36
    },
    messages: {
      noStringRefs: "[Deprecated] Use callback refs instead."
    },
    schema: []
  },
  name: RULE_NAME36,
  create(context) {
    return {
      JSXAttribute(node) {
        if (node.name.name !== "ref") {
          return;
        }
        if (containsStringLiteral(node) || containsStringExpressionContainer(node)) {
          context.report({
            messageId: "noStringRefs",
            node
          });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME37 = "no-unsafe-component-will-mount";
var RULE_FEATURES37 = [
  "CHK"
];
function isUnsafeComponentWillMount(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillMount";
}
var no_unsafe_component_will_mount_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillMount'",
      [Symbol.for("rule_features")]: RULE_FEATURES37
    },
    messages: {
      noUnsafeComponentWillMount: "Do not use 'UNSAFE_componentWillMount'."
    },
    schema: []
  },
  name: RULE_NAME37,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillMount")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillMount(member)) {
              context.report({
                messageId: "noUnsafeComponentWillMount",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME38 = "no-unsafe-component-will-receive-props";
var RULE_FEATURES38 = [
  "CHK"
];
function isUnsafeComponentWillReceiveProps(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillReceiveProps";
}
var no_unsafe_component_will_receive_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillReceiveProps'",
      [Symbol.for("rule_features")]: RULE_FEATURES38
    },
    messages: {
      noUnsafeComponentWillReceiveProps: "Do not use 'UNSAFE_componentWillReceiveProps'."
    },
    schema: []
  },
  name: RULE_NAME38,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillReceiveProps")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillReceiveProps(member)) {
              context.report({
                messageId: "noUnsafeComponentWillReceiveProps",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME39 = "no-unsafe-component-will-update";
var RULE_FEATURES39 = [
  "CHK"
];
function isUnsafeComponentWillUpdate(node) {
  return AST11__namespace.isMethodOrProperty(node) && node.key.type === types.AST_NODE_TYPES.Identifier && node.key.name === "UNSAFE_componentWillUpdate";
}
var no_unsafe_component_will_update_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using 'UNSAFE_componentWillUpdate'",
      [Symbol.for("rule_features")]: RULE_FEATURES39
    },
    messages: {
      noUnsafeComponentWillUpdate: "Do not use 'UNSAFE_componentWillUpdate'."
    },
    schema: []
  },
  name: RULE_NAME39,
  create(context) {
    if (!context.sourceCode.text.includes("UNSAFE_componentWillUpdate")) {
      return {};
    }
    const { ctx, listeners } = core.useComponentCollectorLegacy();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { body } = component.body;
          for (const member of body) {
            if (isUnsafeComponentWillUpdate(member)) {
              context.report({
                messageId: "noUnsafeComponentWillUpdate",
                node: member
              });
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME40 = "no-unstable-context-value";
var RULE_FEATURES40 = [
  "CHK"
];
var no_unstable_context_value_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow passing constructed values to context providers",
      [Symbol.for("rule_features")]: RULE_FEATURES40
    },
    messages: {
      unstableContextValue: "A/an '{{type}}' passed as the value prop to the context provider should not be constructed. It will change on every render. {{suggestion}}"
    },
    schema: []
  },
  name: RULE_NAME40,
  create(context) {
    const { version: version2 } = shared.getSettingsFromContext(context);
    const isReact18OrBelow = compareVersions.compare(version2, "19.0.0", "<");
    const { ctx, listeners } = core.useComponentCollector(context);
    const constructions = /* @__PURE__ */ new Map();
    return {
      ...listeners,
      JSXOpeningElement(node) {
        const fullName = JSX8__namespace.getElementType(node.parent);
        const selfName = fullName.split(".").at(-1);
        if (selfName == null) return;
        if (!isContextName(selfName, isReact18OrBelow)) return;
        const functionEntry = ctx.getCurrentEntry();
        if (functionEntry == null) return;
        const attribute = node.attributes.find(
          (attribute2) => attribute2.type === types.AST_NODE_TYPES.JSXAttribute && attribute2.name.name === "value"
        );
        if (attribute == null || !("value" in attribute)) return;
        const value = attribute.value;
        if (value?.type !== types.AST_NODE_TYPES.JSXExpressionContainer) return;
        const valueExpression = value.expression;
        const initialScope = context.sourceCode.getScope(valueExpression);
        const construction = VAR__namespace.getValueConstruction(valueExpression, initialScope);
        if (construction == null) return;
        if (core.isReactHookCall(construction.node)) {
          return;
        }
        eff.getOrUpdate(constructions, functionEntry.node, () => []).push(construction);
      },
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node).values();
        for (const { node: component } of components) {
          for (const construction of constructions.get(component) ?? []) {
            const { kind, node: constructionNode } = construction;
            const suggestion = kind.startsWith("Function") ? "Consider wrapping it in a useCallback hook." : "Consider wrapping it in a useMemo hook.";
            context.report({
              messageId: "unstableContextValue",
              node: constructionNode,
              data: {
                type: AST11__namespace.toReadableNodeType(constructionNode),
                suggestion
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
function isContextName(name5, isReact18OrBelow) {
  if (name5 === "Provider") return true;
  if (!isReact18OrBelow) {
    return name5.endsWith("Context") || name5.endsWith("CONTEXT");
  }
  return false;
}
var RULE_NAME41 = "no-unstable-default-props";
var RULE_FEATURES41 = [
  "CHK"
];
var no_unstable_default_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow using unstable value as default param in function component",
      [Symbol.for("rule_features")]: RULE_FEATURES41
    },
    messages: {
      noUnstableDefaultProps: "A/an '{{forbiddenType}}' as default prop. This could lead to potential infinite render loop in React. Use a variable instead of '{{forbiddenType}}'."
    },
    schema: []
  },
  name: RULE_NAME41,
  create(context) {
    const { ctx, listeners } = core.useComponentCollector(context);
    const declarators = /* @__PURE__ */ new Map();
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const { node: component } of components.values()) {
          const { params } = component;
          const [props] = params;
          if (props == null) {
            continue;
          }
          const properties = tsPattern.match(props).with({ type: types.AST_NODE_TYPES.ObjectPattern }, ({ properties: properties2 }) => properties2).with({ type: types.AST_NODE_TYPES.Identifier }, ({ name: name5 }) => {
            return declarators.get(component)?.filter((d) => d.init.name === name5).flatMap((d) => d.id.properties) ?? [];
          }).otherwise(() => []);
          for (const prop of properties) {
            if (prop.type !== types.AST_NODE_TYPES.Property || prop.value.type !== types.AST_NODE_TYPES.AssignmentPattern) {
              continue;
            }
            const { value } = prop;
            const { right } = value;
            const initialScope = context.sourceCode.getScope(value);
            const construction = VAR__namespace.getValueConstruction(
              value,
              initialScope,
              VAR__namespace.ValueConstructionHint.StrictCallExpression
            );
            if (construction == null) {
              continue;
            }
            if (core.isReactHookCall(construction.node)) {
              continue;
            }
            const forbiddenType = AST11__namespace.toReadableNodeType(right);
            context.report({
              messageId: "noUnstableDefaultProps",
              node: right,
              data: {
                forbiddenType
              }
            });
          }
        }
      },
      "VariableDeclarator[id.type='ObjectPattern'][init.type='Identifier']"(node) {
        const functionEntry = ctx.getCurrentEntry();
        if (functionEntry == null) return;
        eff.getOrUpdate(
          declarators,
          functionEntry.node,
          () => []
        ).push(node);
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME42 = "no-unused-class-component-members";
var RULE_FEATURES42 = [
  "CHK"
];
var LIFECYCLE_METHODS = /* @__PURE__ */ new Set([
  "componentDidCatch",
  "componentDidMount",
  "componentDidUpdate",
  "componentWillMount",
  "componentWillReceiveProps",
  "componentWillUnmount",
  "componentWillUpdate",
  "constructor",
  "getSnapshotBeforeUpdate",
  "render",
  "shouldComponentUpdate",
  "state",
  "UNSAFE_componentWillMount",
  "UNSAFE_componentWillReceiveProps",
  "UNSAFE_componentWillUpdate"
]);
function isKeyLiteral2(node, key) {
  return tsPattern.match(key).with({ type: types.AST_NODE_TYPES.Literal }, eff.constTrue).with({ type: types.AST_NODE_TYPES.TemplateLiteral, expressions: [] }, eff.constTrue).with({ type: types.AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(eff.constFalse);
}
var no_unused_class_component_members_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused class component members",
      [Symbol.for("rule_features")]: RULE_FEATURES42
    },
    messages: {
      noUnusedClassComponentMembers: "Unused method or property '{{methodName}}'' of class '{{className}}'."
    },
    schema: []
  },
  name: RULE_NAME42,
  create(context) {
    const classEntries = [];
    const methodEntries = [];
    const propertyDefs = /* @__PURE__ */ new WeakMap();
    const propertyUsages = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classEntries.push(node);
      if (!core.isClassComponent(node)) {
        return;
      }
      propertyDefs.set(node, /* @__PURE__ */ new Set());
      propertyUsages.set(node, /* @__PURE__ */ new Set());
    }
    function classExit() {
      const currentClass = classEntries.pop();
      if (currentClass == null || !core.isClassComponent(currentClass)) {
        return;
      }
      const className = AST11__namespace.getClassIdentifier(currentClass)?.name;
      const defs = propertyDefs.get(currentClass);
      const usages = propertyUsages.get(currentClass);
      if (defs == null) {
        return;
      }
      for (const def of defs) {
        const methodName = AST11__namespace.getPropertyName(def);
        if (methodName == null) {
          continue;
        }
        if (usages?.has(methodName) || LIFECYCLE_METHODS.has(methodName)) {
          continue;
        }
        context.report({
          messageId: "noUnusedClassComponentMembers",
          node: def,
          data: {
            className: className ?? "Component",
            methodName
          }
        });
      }
    }
    function methodEnter(node) {
      methodEntries.push(node);
      const currentClass = classEntries.at(-1);
      if (currentClass == null || !core.isClassComponent(currentClass)) {
        return;
      }
      if (node.static) {
        return;
      }
      if (isKeyLiteral2(node, node.key)) {
        propertyDefs.get(currentClass)?.add(node.key);
      }
    }
    function methodExit() {
      methodEntries.pop();
    }
    return {
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        const currentClass = classEntries.at(-1);
        const currentMethod = methodEntries.at(-1);
        if (currentClass == null || currentMethod == null) {
          return;
        }
        if (!core.isClassComponent(currentClass) || currentMethod.static) {
          return;
        }
        if (!AST11__namespace.isThisExpression(node.object) || !isKeyLiteral2(node, node.property)) {
          return;
        }
        if (node.parent.type === types.AST_NODE_TYPES.AssignmentExpression && node.parent.left === node) {
          propertyDefs.get(currentClass)?.add(node.property);
          return;
        }
        const propertyName = AST11__namespace.getPropertyName(node.property);
        if (propertyName != null) {
          propertyUsages.get(currentClass)?.add(propertyName);
        }
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classEntries.at(-1);
        const currentMethod = methodEntries.at(-1);
        if (currentClass == null || currentMethod == null) {
          return;
        }
        if (!core.isClassComponent(currentClass) || currentMethod.static) {
          return;
        }
        if (node.init != null && AST11__namespace.isThisExpression(node.init) && node.id.type === types.AST_NODE_TYPES.ObjectPattern) {
          for (const prop of node.id.properties) {
            if (prop.type === types.AST_NODE_TYPES.Property && isKeyLiteral2(prop, prop.key)) {
              const keyName = AST11__namespace.getPropertyName(prop.key);
              if (keyName != null) {
                propertyUsages.get(currentClass)?.add(keyName);
              }
            }
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME43 = "no-unused-state";
var RULE_FEATURES43 = [
  "CHK"
];
function isKeyLiteral3(node, key) {
  return tsPattern.match(key).with({ type: types.AST_NODE_TYPES.Literal }, eff.constTrue).with({ type: types.AST_NODE_TYPES.TemplateLiteral, expressions: [] }, eff.constTrue).with({ type: types.AST_NODE_TYPES.Identifier }, () => !node.computed).otherwise(eff.constFalse);
}
var no_unused_state_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused state of class component",
      [Symbol.for("rule_features")]: RULE_FEATURES43
    },
    messages: {
      noUnusedState: "Unused class component state in '{{className}}'"
    },
    schema: []
  },
  name: RULE_NAME43,
  create(context) {
    const classEntries = [];
    const methodEntries = [];
    const constructorEntries = [];
    const stateDefs = /* @__PURE__ */ new WeakMap();
    function classEnter(node) {
      classEntries.push(node);
    }
    function classExit() {
      const currentClass = classEntries.pop();
      if (currentClass == null || !core.isClassComponent(currentClass)) {
        return;
      }
      const className = AST11__namespace.getClassIdentifier(currentClass)?.name;
      const { node: defNode, isUsed = false } = stateDefs.get(currentClass) ?? {};
      if (defNode == null || isUsed) {
        return;
      }
      context.report({
        messageId: "noUnusedState",
        node: defNode,
        data: {
          className: className ?? "Component"
        }
      });
    }
    function methodEnter(node) {
      methodEntries.push(node);
      const currentClass = classEntries.at(-1);
      if (currentClass == null || !core.isClassComponent(currentClass)) {
        return;
      }
      if (node.static) {
        if (core.isGetDerivedStateFromProps(node) && tsPattern.isMatching({ params: [tsPattern.P.nonNullable, ...tsPattern.P.array()] })(node.value)) {
          const defNode = stateDefs.get(currentClass)?.node;
          stateDefs.set(currentClass, { node: defNode, isUsed: true });
        }
        return;
      }
      if (AST11__namespace.getPropertyName(node.key) === "state") {
        stateDefs.set(currentClass, { node: node.key, isUsed: false });
      }
    }
    function methodExit() {
      methodEntries.pop();
    }
    function constructorEnter(node) {
      constructorEntries.push(node);
    }
    function constructorExit() {
      constructorEntries.pop();
    }
    return {
      AssignmentExpression(node) {
        if (!core.isAssignmentToThisState(node)) {
          return;
        }
        const currentClass = classEntries.at(-1);
        if (currentClass == null || !core.isClassComponent(currentClass)) {
          return;
        }
        const currentConstructor = constructorEntries.at(-1);
        if (currentConstructor == null || !currentClass.body.body.includes(currentConstructor)) {
          return;
        }
        const isUsed = stateDefs.get(currentClass)?.isUsed ?? false;
        stateDefs.set(currentClass, { node: node.left, isUsed });
      },
      ClassDeclaration: classEnter,
      "ClassDeclaration:exit": classExit,
      ClassExpression: classEnter,
      "ClassExpression:exit": classExit,
      MemberExpression(node) {
        if (!AST11__namespace.isThisExpression(node.object)) {
          return;
        }
        if (AST11__namespace.getPropertyName(node.property) !== "state") {
          return;
        }
        const currentClass = classEntries.at(-1);
        if (currentClass == null || !core.isClassComponent(currentClass)) {
          return;
        }
        const currentMethod = methodEntries.at(-1);
        if (currentMethod == null || currentMethod.static) {
          return;
        }
        if (currentMethod === constructorEntries.at(-1)) {
          return;
        }
        if (!currentClass.body.body.includes(currentMethod)) {
          return;
        }
        const defNode = stateDefs.get(currentClass)?.node;
        stateDefs.set(currentClass, { node: defNode, isUsed: true });
      },
      MethodDefinition: methodEnter,
      "MethodDefinition:exit": methodExit,
      "MethodDefinition[key.name='constructor']": constructorEnter,
      "MethodDefinition[key.name='constructor']:exit": constructorExit,
      PropertyDefinition: methodEnter,
      "PropertyDefinition:exit": methodExit,
      VariableDeclarator(node) {
        const currentClass = classEntries.at(-1);
        if (currentClass == null || !core.isClassComponent(currentClass)) {
          return;
        }
        const currentMethod = methodEntries.at(-1);
        if (currentMethod == null || currentMethod.static) {
          return;
        }
        if (currentMethod === constructorEntries.at(-1)) {
          return;
        }
        if (!currentClass.body.body.includes(currentMethod)) {
          return;
        }
        if (node.init == null || !AST11__namespace.isThisExpression(node.init) || node.id.type !== types.AST_NODE_TYPES.ObjectPattern) {
          return;
        }
        const hasState = node.id.properties.some((prop) => {
          if (prop.type === types.AST_NODE_TYPES.Property && isKeyLiteral3(prop, prop.key)) {
            return AST11__namespace.getPropertyName(prop.key) === "state";
          }
          return false;
        });
        if (!hasState) {
          return;
        }
        const defNode = stateDefs.get(currentClass)?.node;
        stateDefs.set(currentClass, { node: defNode, isUsed: true });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME44 = "no-use-context";
var RULE_FEATURES44 = [
  "CHK",
  "MOD"
];
var no_use_context_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "replace usages of 'useContext' with 'use'",
      [Symbol.for("rule_features")]: RULE_FEATURES44
    },
    fixable: "code",
    messages: {
      noUseContext: "In React 19, 'use' is preferred over 'useContext' because it is more flexible."
    },
    schema: []
  },
  name: RULE_NAME44,
  create(context) {
    if (!context.sourceCode.text.includes("useContext")) return {};
    const settings4 = shared.getSettingsFromContext(context);
    const useContextAlias = /* @__PURE__ */ new Set();
    if (compareVersions.compare(settings4.version, "19.0.0", "<")) {
      return {};
    }
    return {
      CallExpression(node) {
        if (!core.isReactHookCall(node)) {
          return;
        }
        if (!core.isReactHookCallWithNameAlias(context, "useContext", [...useContextAlias])(node)) {
          return;
        }
        context.report({
          messageId: "noUseContext",
          node: node.callee,
          fix(fixer) {
            switch (node.callee.type) {
              case types.AST_NODE_TYPES.Identifier:
                return fixer.replaceText(node.callee, "use");
              case types.AST_NODE_TYPES.MemberExpression:
                return fixer.replaceText(node.callee.property, "use");
            }
            return null;
          }
        });
      },
      ImportDeclaration(node) {
        if (node.source.value !== settings4.importSource) {
          return;
        }
        const isUseImported = node.specifiers.some(tsPattern.isMatching({ local: { type: types.AST_NODE_TYPES.Identifier, name: "use" } }));
        for (const specifier of node.specifiers) {
          if (specifier.type !== types.AST_NODE_TYPES.ImportSpecifier) continue;
          if (specifier.imported.type !== types.AST_NODE_TYPES.Identifier) continue;
          if (specifier.imported.name === "useContext") {
            if (specifier.local.name !== "useContext") {
              useContextAlias.add(specifier.local.name);
            }
            context.report({
              messageId: "noUseContext",
              node: specifier,
              fix(fixer) {
                if (isUseImported) {
                  const tokenBefore = context.sourceCode.getTokenBefore(specifier);
                  return [
                    fixer.remove(specifier),
                    ...tokenBefore?.value === "," ? [fixer.replaceTextRange([tokenBefore.range[1], specifier.range[0]], "")] : [],
                    ...getAssociatedTokens(
                      context,
                      specifier
                    ).map((token) => fixer.remove(token))
                  ];
                }
                return fixer.replaceText(specifier.imported, "use");
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
function getAssociatedTokens(context, node) {
  {
    const tokenBefore = context.sourceCode.getTokenBefore(node);
    const tokenAfter = context.sourceCode.getTokenAfter(node);
    const tokens = [];
    if (tokenAfter?.value !== "," && tokenBefore?.value === ",") {
      tokens.push(tokenBefore);
    }
    if (tokenAfter?.value === ",") {
      tokens.push(tokenAfter);
    }
    return tokens;
  }
}
var RULE_NAME45 = "no-useless-forward-ref";
var RULE_FEATURES45 = [
  "CHK"
];
var no_useless_forward_ref_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "require a 'ref' parameter to be set when using 'forwardRef'",
      [Symbol.for("rule_features")]: RULE_FEATURES45
    },
    messages: {
      noUselessForwardRef: "A 'forwardRef' is used with this component but no 'ref' parameter is set."
    },
    schema: []
  },
  name: RULE_NAME45,
  create(context) {
    return {
      CallExpression(node) {
        if (!core.isForwardRefCall(context, node)) {
          return;
        }
        const [component] = node.arguments;
        if (component == null || !AST11__namespace.isFunction(component)) {
          return;
        }
        const ref = component.params[1];
        if (ref != null) {
          return;
        }
        context.report({
          messageId: "noUselessForwardRef",
          node: component
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME46 = "no-useless-fragment";
var defaultOptions = [{
  allowExpressions: true
}];
function trimLikeReact(text) {
  const leadingSpaces = /^\s*/.exec(text)?.[0] ?? "";
  const trailingSpaces = /\s*$/.exec(text)?.[0] ?? "";
  const start = leadingSpaces.includes("\n") ? leadingSpaces.length : 0;
  const end = trailingSpaces.includes("\n") ? text.length - trailingSpaces.length : text.length;
  return text.slice(start, end);
}
function checkAndReport(context, node, allowExpressions) {
  function fix(fixer) {
    if (node.parent.type !== types.AST_NODE_TYPES.JSXElement && node.parent.type !== types.AST_NODE_TYPES.JSXFragment) {
      if (node.children.length === 0) {
        return null;
      }
      if (node.children.some(
        (child) => JSX8__namespace.isLiteral(child) && !JSX8__namespace.isWhiteSpace(child) || AST11__namespace.is(types.AST_NODE_TYPES.JSXExpressionContainer)(child)
      )) {
        return null;
      }
    }
    if (JSX8__namespace.isUserDefinedElement(node.parent)) {
      return null;
    }
    const opener = node.type === types.AST_NODE_TYPES.JSXFragment ? node.openingFragment : node.openingElement;
    const closer = node.type === types.AST_NODE_TYPES.JSXFragment ? node.closingFragment : node.closingElement;
    const childrenText = opener.type === types.AST_NODE_TYPES.JSXOpeningElement && opener.selfClosing ? "" : context.sourceCode.getText().slice(opener.range[1], closer?.range[0]);
    return fixer.replaceText(node, trimLikeReact(childrenText));
  }
  const initialScope = context.sourceCode.getScope(node);
  if (JSX8__namespace.isKeyedElement(node, initialScope)) {
    return;
  }
  if (JSX8__namespace.isBuiltInElement(node.parent)) {
    context.report({
      messageId: "uselessFragment",
      node,
      data: {
        reason: "placed inside a built-in component"
      },
      fix
    });
  }
  if (node.children.length === 0) {
    context.report({
      messageId: "uselessFragment",
      node,
      data: {
        reason: "contains less than two children"
      },
      fix
    });
    return;
  }
  const isChildElement = AST11__namespace.isOneOf([types.AST_NODE_TYPES.JSXElement, types.AST_NODE_TYPES.JSXFragment])(node.parent);
  switch (true) {
    // <Foo content={<>ee eeee eeee ...</>} />
    case (allowExpressions && !isChildElement && node.children.length === 1 && JSX8__namespace.isLiteral(node.children.at(0))): {
      return;
    }
    // <Foo><>hello, world</></Foo>
    case (!allowExpressions && isChildElement): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix
      });
      return;
    }
    case (!allowExpressions && !isChildElement && node.children.length === 1): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix
      });
      return;
    }
  }
  const nonPaddingChildren = node.children.filter((child) => !JSX8__namespace.isPaddingSpaces(child));
  const firstNonPaddingChild = nonPaddingChildren.at(0);
  switch (true) {
    case nonPaddingChildren.length === 0:
    case (nonPaddingChildren.length === 1 && firstNonPaddingChild?.type !== types.AST_NODE_TYPES.JSXExpressionContainer): {
      context.report({
        messageId: "uselessFragment",
        node,
        data: {
          reason: "contains less than two children"
        },
        fix
      });
      return;
    }
  }
  return;
}
var no_useless_fragment_default = createRule({
  meta: {
    type: "problem",
    defaultOptions: [...defaultOptions],
    docs: {
      description: "disallow useless fragments"
    },
    fixable: "code",
    messages: {
      uselessFragment: "A fragment {{reason}} is useless."
    },
    schema: [{
      type: "object",
      additionalProperties: false,
      properties: {
        allowExpressions: {
          type: "boolean",
          description: "Allow fragments with a single expression child"
        }
      }
    }]
  },
  name: RULE_NAME46,
  create(context, [option]) {
    const { allowExpressions = true } = option;
    return {
      JSXElement(node) {
        if (!JSX8__namespace.isFragmentElement(node)) return;
        checkAndReport(context, node, allowExpressions);
      },
      JSXFragment(node) {
        checkAndReport(context, node, allowExpressions);
      }
    };
  },
  defaultOptions
});
var RULE_NAME47 = "prefer-destructuring-assignment";
var RULE_FEATURES46 = [
  "CHK"
];
function isMemberExpressionWithObjectName(node) {
  return node.object.type === types.AST_NODE_TYPES.Identifier && "name" in node.object;
}
var prefer_destructuring_assignment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce using destructuring assignment in component props and context",
      [Symbol.for("rule_features")]: RULE_FEATURES46
    },
    messages: {
      preferDestructuringAssignment: "Use destructuring assignment for {{name}}."
    },
    schema: []
  },
  name: RULE_NAME47,
  create(context) {
    const { ctx, listeners } = core.useComponentCollector(context);
    const memberExpressionWithNames = [];
    return {
      ...listeners,
      MemberExpression(node) {
        if (isMemberExpressionWithObjectName(node)) {
          const scope = context.sourceCode.getScope(node);
          memberExpressionWithNames.push([scope, node]);
        }
      },
      "Program:exit"(node) {
        const components = [
          ...ctx.getAllComponents(node).values()
        ];
        function isFunctionComponent(block) {
          if (!AST11__namespace.isFunction(block)) {
            return false;
          }
          const id = AST11__namespace.getFunctionIdentifier(block);
          return id != null && core.isComponentNameLoose(id.name) && components.some((component) => component.node === block);
        }
        for (const [initialScope, memberExpression] of memberExpressionWithNames) {
          let scope = initialScope;
          let isComponent = isFunctionComponent(scope.block);
          while (!isComponent && scope.upper != null && scope.upper !== scope) {
            scope = scope.upper;
            isComponent = isFunctionComponent(scope.block);
          }
          if (!isComponent) {
            continue;
          }
          const component = scope.block;
          if (!("params" in component)) {
            continue;
          }
          const [props, ctx2] = component.params;
          const isMatch = (node2) => node2 != null && node2.type === types.AST_NODE_TYPES.Identifier && node2.name === memberExpression.object.name;
          if (isMatch(props)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "props"
              }
            });
          }
          if (isMatch(ctx2)) {
            context.report({
              messageId: "preferDestructuringAssignment",
              node: memberExpression,
              data: {
                name: "context"
              }
            });
          }
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME48 = "prefer-react-namespace-import";
var RULE_FEATURES47 = [
  "CHK",
  "FIX"
];
var prefer_react_namespace_import_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce React is imported via a namespace import",
      [Symbol.for("rule_features")]: RULE_FEATURES47
    },
    fixable: "code",
    messages: {
      preferReactNamespaceImport: 'Prefer importing React as `import * as React from "{{importSource}}";`'
    },
    schema: []
  },
  name: RULE_NAME48,
  create(context) {
    const { importSource } = shared.getSettingsFromContext(context);
    return {
      [`ImportDeclaration[source.value="${importSource}"] ImportDefaultSpecifier`](node) {
        const hasOtherSpecifiers = node.parent.specifiers.length > 1;
        context.report({
          messageId: "preferReactNamespaceImport",
          node: hasOtherSpecifiers ? node : node.parent,
          data: { importSource },
          fix(fixer) {
            const quote = node.parent.source.raw.at(0) ?? "'";
            const isTypeImport = node.parent.importKind === "type";
            const importStringPrefix = `import${isTypeImport ? " type" : ""}`;
            const importSourceQuoted = `${quote}${importSource}${quote}`;
            const sourceCode = context.sourceCode.getText(node.parent);
            const semiColon = sourceCode.endsWith(";") ? ";" : "";
            if (!hasOtherSpecifiers) {
              return fixer.replaceText(
                node.parent,
                `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semiColon}`
              );
            }
            const specifiers = sourceCode.slice(sourceCode.indexOf("{"), sourceCode.indexOf("}") + 1);
            return fixer.replaceText(
              node.parent,
              `${importStringPrefix} * as ${node.local.name} from ${importSourceQuoted}${semiColon}
${importStringPrefix} ${specifiers} from ${importSourceQuoted}${semiColon}`
            );
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME49 = "prefer-read-only-props";
var RULE_FEATURES48 = [
  "CHK",
  "TSC"
];
var prefer_read_only_props_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce read-only props in components",
      [Symbol.for("rule_features")]: RULE_FEATURES48
    },
    messages: {
      preferReadOnlyProps: "A function component's props should be read-only."
    },
    schema: []
  },
  name: RULE_NAME49,
  create(context) {
    const services = utils.ESLintUtils.getParserServices(context, false);
    const { ctx, listeners } = core.useComponentCollector(context);
    return {
      ...listeners,
      "Program:exit"(node) {
        const components = ctx.getAllComponents(node);
        for (const [, component] of components) {
          const [props] = component.node.params;
          if (props == null) {
            continue;
          }
          const propsType = typeUtils.getConstrainedTypeAtLocation(services, props);
          if (typeUtils.isTypeReadonly(services.program, propsType)) {
            continue;
          }
          context.report({ messageId: "preferReadOnlyProps", node: props });
        }
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME50 = "prefer-shorthand-boolean";
var RULE_FEATURES49 = [
  "CHK",
  "FIX"
];
var prefer_shorthand_boolean_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce the use of shorthand syntax for boolean attributes",
      [Symbol.for("rule_features")]: RULE_FEATURES49
    },
    fixable: "code",
    messages: {
      preferShorthandBoolean: "Use shorthand boolean attribute '{{propName}}'."
    },
    schema: []
  },
  name: RULE_NAME50,
  create(context) {
    return {
      JSXAttribute(node) {
        const { value } = node;
        const propName = JSX8__namespace.getAttributeName(node);
        const hasValueTrue = value?.type === types.AST_NODE_TYPES.JSXExpressionContainer && value.expression.type === types.AST_NODE_TYPES.Literal && value.expression.value === true;
        if (!hasValueTrue) {
          return;
        }
        context.report({
          messageId: "preferShorthandBoolean",
          node,
          data: {
            propName
          },
          fix: (fixer) => fixer.removeRange([node.name.range[1], value.range[1]])
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME51 = "prefer-shorthand-fragment";
var RULE_FEATURES50 = [
  "CHK",
  "FIX"
];
var prefer_shorthand_fragment_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "enforce the use of shorthand syntax for fragments",
      [Symbol.for("rule_features")]: RULE_FEATURES50
    },
    fixable: "code",
    messages: {
      preferShorthandFragment: "Use fragment shorthand syntax instead of 'Fragment' component."
    },
    schema: []
  },
  name: RULE_NAME51,
  create(context) {
    return {
      JSXElement(node) {
        if (!JSX8__namespace.isFragmentElement(node)) return;
        const hasAttributes = node.openingElement.attributes.length > 0;
        if (hasAttributes) {
          return;
        }
        context.report({
          messageId: "preferShorthandFragment",
          node,
          fix: (fixer) => {
            const { closingElement, openingElement } = node;
            if (closingElement == null) {
              return [];
            }
            return [
              fixer.replaceTextRange([openingElement.range[0], openingElement.range[1]], "<>"),
              fixer.replaceTextRange([closingElement.range[0], closingElement.range[1]], "</>")
            ];
          }
        });
      }
    };
  },
  defaultOptions: []
});
var RULE_NAME52 = "use-jsx-vars";
var RULE_FEATURES51 = [];
var use_jsx_vars_default = createRule({
  meta: {
    type: "problem",
    docs: {
      description: "marks variables used in JSX as used",
      [Symbol.for("rule_features")]: RULE_FEATURES51
    },
    messages: {
      useJsxVars: ""
    },
    schema: []
  },
  name: RULE_NAME52,
  create(context) {
    return {
      JSXOpeningElement(node) {
        switch (node.name.type) {
          case types.AST_NODE_TYPES.JSXIdentifier: {
            if (/^[a-z]/u.test(node.name.name)) {
              return;
            }
            context.sourceCode.markVariableAsUsed(node.name.name, node);
            break;
          }
          case types.AST_NODE_TYPES.JSXMemberExpression: {
            const { object } = node.name;
            if (object.type === types.AST_NODE_TYPES.JSXIdentifier) {
              context.sourceCode.markVariableAsUsed(object.name, node);
            }
            break;
          }
        }
      }
    };
  },
  defaultOptions: []
});

// src/plugin.ts
var plugin = {
  meta: {
    name: name4,
    version
  },
  rules: {
    "avoid-shorthand-boolean": avoid_shorthand_boolean_default,
    "avoid-shorthand-fragment": avoid_shorthand_fragment_default,
    "no-access-state-in-setstate": no_access_state_in_setstate_default,
    "no-array-index-key": no_array_index_key_default,
    "no-children-count": no_children_count_default,
    "no-children-for-each": no_children_for_each_default,
    "no-children-map": no_children_map_default,
    "no-children-only": no_children_only_default,
    "no-children-prop": no_children_prop_default,
    "no-children-to-array": no_children_to_array_default,
    "no-class-component": no_class_component_default,
    "no-clone-element": no_clone_element_default,
    "no-comment-textnodes": no_comment_textnodes_default,
    "no-complex-conditional-rendering": no_complex_conditional_rendering_default,
    "no-component-will-mount": no_component_will_mount_default,
    "no-component-will-receive-props": no_component_will_receive_props_default,
    "no-component-will-update": no_component_will_update_default,
    "no-context-provider": no_context_provider_default,
    "no-create-ref": no_create_ref_default,
    "no-default-props": no_default_props_default,
    "no-direct-mutation-state": no_direct_mutation_state_default,
    "no-duplicate-jsx-props": no_duplicate_jsx_props_default,
    "no-duplicate-key": no_duplicate_key_default,
    "no-forward-ref": no_forward_ref_default,
    "no-implicit-key": no_implicit_key_default,
    "no-leaked-conditional-rendering": no_leaked_conditional_rendering_default,
    "no-missing-component-display-name": no_missing_component_display_name_default,
    "no-missing-context-display-name": no_missing_context_display_name_default,
    "no-missing-key": no_missing_key_default,
    "no-nested-components": no_nested_components_default,
    "no-prop-types": no_prop_types_default,
    "no-redundant-should-component-update": no_redundant_should_component_update_default,
    "no-set-state-in-component-did-mount": no_set_state_in_component_did_mount_default,
    "no-set-state-in-component-did-update": no_set_state_in_component_did_update_default,
    "no-set-state-in-component-will-update": no_set_state_in_component_will_update_default,
    "no-string-refs": no_string_refs_default,
    "no-unsafe-component-will-mount": no_unsafe_component_will_mount_default,
    "no-unsafe-component-will-receive-props": no_unsafe_component_will_receive_props_default,
    "no-unsafe-component-will-update": no_unsafe_component_will_update_default,
    "no-unstable-context-value": no_unstable_context_value_default,
    "no-unstable-default-props": no_unstable_default_props_default,
    "no-unused-class-component-members": no_unused_class_component_members_default,
    "no-unused-state": no_unused_state_default,
    "no-use-context": no_use_context_default,
    "no-useless-forward-ref": no_useless_forward_ref_default,
    "no-useless-fragment": no_useless_fragment_default,
    "prefer-destructuring-assignment": prefer_destructuring_assignment_default,
    "prefer-react-namespace-import": prefer_react_namespace_import_default,
    "prefer-read-only-props": prefer_read_only_props_default,
    "prefer-shorthand-boolean": prefer_shorthand_boolean_default,
    "prefer-shorthand-fragment": prefer_shorthand_fragment_default,
    "use-jsx-vars": use_jsx_vars_default,
    // Part: deprecated rules
    /** @deprecated Use `no-useless-forward-ref` instead */
    "ensure-forward-ref-using-ref": no_useless_forward_ref_default,
    /** @deprecated Use `no-duplicate-jsx-props` instead */
    "jsx-no-duplicate-props": no_duplicate_jsx_props_default,
    /** @deprecated Use `use-jsx-vars` instead */
    "jsx-uses-vars": use_jsx_vars_default,
    /** @deprecated Use `no-complex-conditional-rendering` instead */
    "no-complicated-conditional-rendering": no_complex_conditional_rendering_default
  }
};

// src/index.ts
function makeConfig(config) {
  return {
    ...config,
    plugins: {
      "react-x": plugin
    }
  };
}
function makeLegacyConfig({ rules: rules4 }) {
  return {
    plugins: ["react-x"],
    rules: rules4
  };
}
var index_default = {
  ...plugin,
  configs: {
    ["recommended"]: makeConfig(recommended_exports),
    ["recommended-legacy"]: makeLegacyConfig(recommended_exports),
    ["recommended-type-checked"]: makeConfig(recommended_type_checked_exports),
    ["recommended-type-checked-legacy"]: makeLegacyConfig(recommended_type_checked_exports),
    ["recommended-typescript"]: makeConfig(recommended_typescript_exports),
    ["recommended-typescript-legacy"]: makeLegacyConfig(recommended_typescript_exports)
  }
};

module.exports = index_default;
